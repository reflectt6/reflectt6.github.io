---
layout: page-with-sidebar-math
title:  "Filter往事(二)RibbonFilter理论分析"
date:   2023-12-21 10:47:03 +0800
author: reflectt6
categories: "大数据"
#permalink: 
mainTag: "大数据"
secondaryTag: "预研"
hideTag: false
---

## [Ribbon Filter](https://arxiv.org/abs/2103.02515)

### 盲僧发现了华点

1、参考[知乎](https://zhuanlan.zhihu.com/p/565523164)

2、一个r位数，每个位可能的取值为0或者1: $$ \{0,1\}^r $$

3、异或: $$\bigoplus$$

4、同或: $$\bigodot$$

5、看知乎上说Ribbon Filter用的是高斯消元，而Rox Filter用的是Peeling，什么是Peeling？这个也是论文里面定义的，原文如下：

`Standard Xor filters use a fast solving process called peeling that limits their space efficiency to ≥ 1.22𝜆 bits per key7`



### 论文概述

```
Section 2
简短的回顾了“static functions”，这个和java中的静态方法不是一个东西。作者想通过“static functions”定义一个过滤器

Section 3
分析Ribbon的构造算法；提出一个提升空间效率的优化“smash”；这些特性会导致，key数量上升的同时，空间或者时间开销上升。

Section 4
提出Homogeneous Ribbon filter，和Blocked bloom filter 共享许多参数。优点为：1、构造的成功性是可以保证的 2、扩展至任意的key数量，都是高效的。实现简单，但是要分析更多

Section 5
描述一些实验性的问题：
	1、有效利用任意key数量的内存
	2、高效查询的数据分布
	3、高效满足hash需求
	4、扩展标准Ribbon通过数据共享

Section 6
提出Balanced ribbon，通过连续ribbon，贪婪的加载balancing表。极大优化了“smash”的ribbon空间效率。

Section 7
更多实验验证。
```



### Section3（重要）

静态方法就是我们之前讨论的要插入的key的集合已知的一种情况，“静态方法”的实现来自[论文](https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ESA.2019.39)，通过矩阵高效求解高斯消元问题，ribbon过滤器实际上就是这个高斯方法的应用。

#### sgauss构造器


对于一个我们称为带宽 *w* 的参数 *w*∈N，向量 $\vec h(x)∈\{0,1\}^m$ 由一个随机的起始位置 *s*(*x*)∈[*m*−*w*−1] 和一个随机系数向量 *c*(*x*)∈{0,1}*w* 给出，即 $h(x)=0^{s−1}c(x)0^{m−s−w+1}$​请注意，即使像 **h**(*x*) 这样的 *m* 位向量用于简化数学讨论，这样的向量也可以用 log(*m*)+*w* 位表示。

由$(\vec h(x))_{x∈S}$ 按 s(x) 排序的矩阵，其所有的 "1-条目"都位于一个宽度为 w 的“ribbon”中，该带从矩阵的左上角随机穿过矩阵到右下角，如图 2 所示。

在文献 [22] 中，作者证明了对于 $(h(x)⋅Z=b(x))_{x∈S}$，可以使用 $Z∈\\{0,1\\}^{m×r}$快速计算出解：

定理 3.1（[22, 定理 2]）。对于任意常数 $0<ε<{1 \over 2}$，令 $w={logn \over ε}$ 和 ${n \over m}=1−ε$，有很高的概率使得线性系统 $(h(x)⋅Z=b(x))_{x∈S}$对于任何 r∈N 和任何 $b:S→\\{0,1\\}^r$ 是可解的。

而且，在按s(x) 排序$(\vec h(x))_{x∈S} $后，高斯消元法可以在期望时间$O({n \over {ε^2}})$ 内计算出一个解Z。

#### Ribbon Filter的逻辑结构：

![image-20240204111514092](/assets/images/2023-12-21-Filter往事(二)RibbonFilter理论分析//image-20240204111514092.png)

#### Ribbon Filter的构造算法（插入/banding）：

![image-20240204111602181](/assets/images/2023-12-21-Filter往事(二)RibbonFilter理论分析//image-20240204111602181.png)

#### Banding stage 两个特点：

1、On-the-Fly：对于键序列𝑆 = (𝑥1, 𝑥2, 𝑥3, . . . )，我们可以轻松确定构建成功的𝑆的最长前缀（𝑥1, . . . , 𝑥𝑛）：只需插入键直到第一次失败。

2、incremental：插入阶段是增量的，因为我们可以轻松地撤消最近一组成功插入操作：只需移除添加的𝑀中的行。这些特性与sgauss不同，并将在第6节中加以利用。



#### Ribbon Filter相较sgauss有相同成功率

定理3.2. 设𝑆 ⊆ U是任意的键集。

 (i) 如果sgauss构建对𝑆成功，那么Ribbon构建也会成功。

 (ii) 如果两种构建在𝑆上都成功，期望的运行时间在常数因子上是相同的。

证明略



#### Ribbon Filter相较sgauss有更高效率

虽然sgauss和Ribbon在O-符号表示法中处于相同的水平，但Ribbon在以下几个方面的常数因子上优于sgauss：

1、无需按𝑠(𝑥)预先对键进行排序。

2、sgauss需要明确存储每行的主元位置。这是因为sgauss不计算阶梯形式，而只确保在每行中最左侧的1条目（主元）是其列中最底部的1条目。

3、sgauss执行大约𝐷次消元步骤，这取决于某些位，结果可能是异或操作或无操作。另一方面，Ribbon执行大约𝐷/2位移和𝐷/2（无条件的）异或操作。尽管细节复杂，但在分支复杂性上的直觉似乎更有利于Ribbon。



#### 常规Ribbon存在一些问题

![image-20240204164054237](/assets/images/2023-12-21-Filter往事(二)RibbonFilter理论分析//image-20240204164054237.png)

图4：(a) 考虑在方形的Ribbon系统中的对角线（虚线）。它的起始点和终点可能位于（阴影）ribbon区域之外。 (b) 我们的“smash”变体解决了这个问题。

我们可以通过人为增加第一个和最后一个起始位置的概率Pr[𝑠(𝑥) = 1]和Pr[𝑠(𝑥) = 𝑚 −𝑤 + 1]来解决这个问题，增加的倍数被称为smash值。对于𝑠的这种分布很容易通过在[−ℓ + 2, 𝑚 − 𝑤 + ℓ]上进行均匀分布，并使用min和max函数将抽样值夹紧到[1, 𝑚 − 𝑤 + 1]来实现。微基准测试显示，对于smash查询，Intel Skylake CPU每个查询大约有3纳秒的额外开销。

对于ℓ = 𝑤/2的smash值和𝑤 = 𝜔(√𝑛)的ribbon宽度，矩阵对角线牢固地位于ribbon内，参见图4（b）。不难证明，这样的矩阵渐近地与完全随机的𝑛 × 𝑛矩阵具有相似的正则概率。该概率为𝑐2 ≈ 0.289；参见[16]。

在第5.4节中，我们提出经验性的发现，表明非零的smash值在实际上更相关的情况下，即𝜀 > 0且𝑤 = O(log𝑛/𝜀)，也有助于成功概率。

### Section4

HOMOGENEOUS RIBBON FILTERS是齐次ribbon过滤器的意思。就是线性代数里面齐次线性方程的齐次。也就是右侧的矩阵为0矩阵。齐次线性方程必有零解。

回顾一下Ribbon过滤器的基本思想是选择哈希函数$\vec h: U → \\{0, 1\\}^𝑚$和$𝑏: U → \\{0, 1\\} ^𝑟$，然后找到$𝑍 ∈ \\{0, 1\\}^ {𝑚×𝑟}$，使得所有𝑥 ∈ 𝑆都满足$ \vec h(𝑥) · 𝑍 = 𝑏(𝑥)$，而大多数𝑥 ∈ U \ 𝑆则不满足。

现在我们来看看当我们有效地去掉指纹函数𝑏，即对所有𝑥 ∈ U设置𝑏(𝑥) = 0时会发生什么。然后，一个过滤器由对齐次系统的解𝑍给出 $(\vec h(𝑥) · 𝑍 = 0^𝑟 )_{𝑥 ∈𝑆}$。 

𝑍的FP率为$𝑓_𝑍 = Pr_{𝑎∼𝐻} [𝑎 * 𝑍 = 0^𝑟 ]$，其中𝐻是$\vec h(𝑥)$对应于𝑥 ∈ U的分布。该想法的一个直接问题是$𝑍 = 0 ^{𝑚×𝑟}$ 是一个解，导致$𝑓_Z = 1$。

然而，从所有解中随机选择一个𝑍效果更好。为了得到一个解，所有自由变量，即对应于𝑀的空行的变量，在回代过程中都是随机初始化的。总体的FP率为$𝑓 = E[𝑓_𝑍]$，其中𝑍取决于$( \vec h(𝑥))_{𝑥 ∈𝑆}$​和自由变量的随机性。我们将得到的构造称为 Homogeneous Ribbon过滤器。它相对于标准的Ribbon过滤器有两个明显的优势：

​	1、建筑始终不会失败，无论 𝑛、𝜀 和 𝑤 为何。这是因为齐次线性系统始终至少具有平凡解。

​	2、指纹缺失略微改善了建筑的时间和空间效果。（在优化实现中，查询时间基本相同。）

一个复杂性在于假阳率 𝑓 可能高于 2 − 𝑟。直观地说，如果太多的方程约束了 𝑍 的某个部分，那么该部分将不足够随机。对于 𝜀𝑤 > 𝐶𝑟（对于某个常数 𝐶 > 0）和大 𝑛，我们将在定理 4.1 中进行论证，此效应可以忽略不计。这仍然给我们留下了两个劣势，特别是对于小 𝑛 和高 𝑟 的情况：

​	1、乘积 𝜀𝑤 必须与 𝑟 成正比（对于可接受的 𝑓），而对于标准 Ribbon，𝜀𝑤 只需与 log𝑛 成正比（对于可接受的成功概率）。因此，我们不应该期望在 𝑟 = Ω(log𝑛) 时超过标准 Ribbon 的性能。

​	2、对于小 𝑛，$𝑓_𝑍$ 的方差相当高，这意味着小型过滤器偶尔会出现显着更多的假阳性（例如，由于$（𝑠(𝑥))_{𝑥∈𝑆}$​ 中的随机偏斜），在建筑过程中无法明显检测到。这可能对某些应用程序构成潜在风险。

我们可以为Homogeneous Ribbon 过滤器提出有力的论据，证明在任意大的尺寸 𝑛 上可以实现任意小的空间开销。这既不需要带宽 𝑤 随 𝑛 缩放，也不需要偏离纯粹的构建方式（例如，通过将密钥集划分为小的分片）。 

这里的空间开销是指 ${space \over opt} − 1$，其中 space 是每个键的比特空间使用量，$opt = − log_2(𝑓 )$ 是信息理论下界，适用于达到相同假阳率的过滤器。之前其实计算过空间的信息理论下界为：$opt = − nlog_2(𝑓 )$。那么空间开销为：${allSpace \over opt * n}$

上下同除以n，则得到当前公式：${space \over opt}$，最后减1，算出增量。

#### 空间开销实践

为了在Homogeneous Ribbon 过滤器中选择的 𝑟 和 𝑤 的情况下最小化空间开销${r(1+ε) \over {logf^{-1}}} - 1$ , ε既不能太大也不能太小（因为过小的 ε 会导致由于密集约束而使假阳率 f 增加）。为了选择 ε，我们转向对随机数据进行模拟，构建大型结构并测试假阳率。使用 $m=3×10^7$（等等），w∈{16,32,64,128}，和 r∈[1,16]，我们观察到对于任何大的n，空间开销在哪些参数下最小：

方程(7)：$$ε \approx {4 + {r \over 4}\over w}$$

注意，从定理 4.1（模糊地）得出的建议 $ε>{Cmax(logw,r) \over w} $​大致是一致的。我们在所有实验中使用公式 (7)。在图 5 中，我们展示了对于 w∈{16,32,64,128} 和大 n，可以从Homogeneous Ribbon 过滤器中期望的空间开销和假阳率的组合。

![image-20240205144942973](/assets/images/2023-12-21-Filter往事(二)RibbonFilter理论分析//image-20240205144942973.png)

在图 5 中，还讨论了平衡 Ribbon 过滤器，详见第 6 节。 

例如，考虑使用 *r*=7 实现大约 1% 的假阳率，以及 *w*=64 实现合理的时空权衡。使用方程 (7) 中的 *ε*≈0.09，我们观察到 *f*≈0.81%>0.78%≈$2^{−7}$​，因此实际空间开销更接近于 10% 而不是用 *ε* 分配的 9%。



### Section5 Ribbon实践

#### 可配置型和弹性

Bloom过滤器具有一个有用且可能之前未被复制的特性，即在表示任意数量的键时，能够高效利用任意数量的空间来最小化假阳率。我们将这称为“可配置性”，并建议它在实践中对于空间效率非常重要。考虑一个应用程序，它对进入过滤器的键的数量几乎没有控制权。即使我们对于特定的假阳率使用了一个完全空间高效的过滤器，由于分配器的内部碎片化，我们可能会浪费大量空间。像 jemalloc [33] 这样的内存分配器在任意大小的分配上平均约有10%的内部碎片，这理论上应该由过滤器使用以减少其假阳率。

更具体地说，诸如Cuckoo、Quotient和Xor之类的Bloom替代方案通常使用一些整数比特的单元，就像Ribbon对于 𝑟 一样。整数值的 𝑟 限制了在不同假阳率和每个键的比特数之间进行高效选择的可能性。例如，当可用5.5比特每个单元时，仅使用5比特的单元会给我们的过滤器增加大约10%的空间开销。除了Ribbon，它与两元素场相关联外，这些相同的Bloom替代方案可以使用分数位单元大小。一些配置甚至可以变得高效，比如每个单元64/𝑖比特，其中 𝑖 是整数（在第7节测试了现有的Xor10.666实现），但细粒度肯定会更加CPU密集。

一种有效将 𝑟 泛化到分数的替代方法是将可用空间分配给两个结构：一个使用 ⌈𝑟⌉ 个解决列（或每个单元的比特数），另一个使用 ⌊𝑟⌋ 个解决列，用于 𝑟 的加权平均，以适应可用空间。这仅会稍微增加整体的空间开销。例如，使用 𝑟 = 5.5 会产生（非均匀的）3/128 的假阳率。这个率的下界是 𝜆 = 5.415 比特每个键，所以该方法对整体空间开销增加了 1.57%。对于 𝑟 = 1.5，这个增加更大，为 6.00%，对于每个键 10.5 比特的情况下，增加较小，为 0.82%。将结构分割成两部分的实际问题包括 (a) 在适用时实质性地使许多与小结构相关的空间使用惩罚加倍，和 (b) 独立地种子哈希或接受联合构造成功概率（在适用时）。

对于 Ribbon，我们推荐在一个单一结构内使用该方法的一种变体：为某些行仅使用 ⌊𝑟⌋ 个解决比特，对于其余的行使用 ⌈𝑟⌉ 个解决比特。banding过程（算法1）保持不变，但在回代和查询中需要进行一些小的更改（更多细节请参见第5.2节）。由于 Ribbon 在查询中的探测具有局部性，与标准 Xor 过滤器不同，一个逐渐减小的小部分查询会穿过 ⌊𝑟⌋ 和 ⌈𝑟⌉ 列之间的边界（在这种情况下仅使用 ⌊𝑟⌋），因此空间效率非常接近理想的分割方法，并在实践中可能更好：对于常见配置额外的空间开销约为 1%（例如在第7节中的 𝑟 = 7.7）。

尽管分割方法为许多类型的过滤器提供了近乎连续的可配置性，但 Ribbon 过滤器的单一结构方法具有一种称为"弹性"的优势，适用于 ElasticBF [46] 等应用。与 Xor 过滤器类似，可以从 Ribbon 过滤器中删除整个列，从而获得相应更高的假阳率。对于 Ribbon 过滤器，我们还有能力删除最后一列的一部分，因此可以通过位粒度将完成的过滤器修剪下来。进一步泛化，完成的 Ribbon 过滤器可以拆分成具有独立假阳率的多个较小结构，其乘积可以小至起始结构的假阳率。类似地，完成的 Ribbon 过滤器可以在任意边界处进行物理（重新）分区，每个分区边界仅复制 (𝑤 − 1)𝑟 位，以便每个查询仅访问一个分区。

#### Solution结构布局

在这里，我们研究了解决矩阵 $Z∈{0,1}^{m×r}$ 的内存布局，这对于快速的 Ribbon 过滤器查询至关重要。之前的工作只评估了 r=1 的情况，其中Z 是一个布尔（比特）向量。

Xor 过滤器通常使用解决结构的行优先布局，其中在内存中整个行 i 的Z 立即在整个行 i+1 之前。一个w=64 的 Ribbon 过滤器在条件下合并了大约比标准 Xor 过滤器无条件合并的行数多一个数量级（三行）。实际上，由于解决列通常在 5≤r≤15 的范围内，标准 Xor 过滤器通常访问的列比行多，而 Ribbon 过滤器通常访问的行比列多。尽管行优先布局在某些特殊情况下可能可以通过 SIMD 实现高效，但我们发现它在一般情况下不太适用于实现一个快速且高度可配置的过滤器。

相反的是列优先布局，其中整个列 i 的 Z 在内存中在列 i+1 之前。对于查询单个键的结果位，列优先布局基本上是理想的，因为我们只需要访问一个“连续”的（通常不对齐的）w 比特，与*c(x) 逐位与运算，并获取比特的奇偶性。列优先布局的问题是访问更多的结果比特不是相邻的内存访问。虽然几个内存地址可以轻松计算并且可以并行获取，但一些测试显示对于对内存缓存不热的 r>2 的过滤器来说，这相对昂贵。

![image-20240205160610854](/assets/images/2023-12-21-Filter往事(二)RibbonFilter理论分析//image-20240205160610854.png)

我们对于 Ribbon 过滤器的首选解决方案布局是交织的列优先布局（ICML），因为它在本质上具有非常接近行优先的局部性，并且在解码效率上非常接近列优先。内存空间被划分为方便大小的 ICML 字，然后分组成 Z 的 r 个字的块。每个块都是 Z 的一些连续行的列优先布局。参见图 6，该图将此布局推广到分数 r 的列数。

对于 ICML 字大小等于 w，用于重建每个结果比特的最多且几乎总是两个字。这意味着每次完整查询访问的相邻内存量为 2rw 比特，而理想最小值是 rw 比特。例如，当 r=6 且 w=64 时，ICML 每次查询访问 768 比特，以 384 比特对齐，这相当于平均访问 2.25 个 Intel 缓存行（512 比特）和本质上每次查询 1 页（4KB）；而仅有 6 比特“对齐”的情况下，行优先布局每次查询访问 1.5 个缓存行。标准的 Xor 过滤器每次查询基本上访问 3 个缓存行以及几乎相同数量的页面。

Ribbon的回代是基于列优先布局的一种特别快速的流操作。我们可以将 w 行的 Z 缓冲到宽度为 w 的 r 个临时值中，这很可能适应于 CPU 寄存器，并使用这些缓冲区来进行 (a) 计算每列的逻辑上一个比特，以及 (b) 对每个 w 行（rw 比特）刷新到我们的解决结构中。

众所周知，对于Bloom过滤器，查询可以通过短路求值进行优化：即在检查到探测到的位为零时立即从“负”查询返回，确保查询必须返回false。对于基于列优先布局的 Ribbon 过滤器，类似的方法也适用，即一旦结果比特不符合期望，就立即返回。尽管本地缓存的Bloom过滤器经过优化，很少再使用这种方法 [44]，我们的 Ribbon 实现除了在编译时固定的 r≤4 时，都使用了短路求值。这一区别在第7节的观察到的查询时间范围中可见。

我们还喜欢基于列优先的布局的清晰可配置性。参数 �*r* 应该自由选择以平衡假阳率与空间使用，而当它不影响指令级数据对齐时，选择就更加自由，只影响 CPU 缓存和页面中的对齐，我们认为这是一个相对较小的问题。对于使用 ⌊𝑟⌋ 列然后是 ⌈𝑟⌉ 列的 Ribbon 宽度 ICML（第5.1节）是很好的，因为一旦确定了起始内存位置和（最小的）适用列数，这可以在没有条件分支的情况下完成，剩余的查询代码就不必考虑混合列数；请参见图 6。（⌈𝑟⌉ 在 ⌊𝑟⌋ 之前对于纯列优先更好。）

ICML 的一个小缺点是解决行数 m 必须是 ICML 字中比特数的倍数，这可能在配置性（适应任意数量的键）和对于小 n 的空间效率之间存在冲突。

#### Ribbon的实用Hash Fun

##### 哈希扩展

某个量的哈希信息“消耗” Filter 结构可以从原始键 x 的较小哈希 H(x) 中操作 [28, 29]。对于 Ribbon 过滤器的实际要求如下：

- H(x) 的值必须足够大，以便由于完整哈希碰撞导致的基线假阳率可以忽略不计，即对于 $x1 \neq x2$，有 H(x1)=H(x2)。对于几乎所有非加密应用，64位哈希对于 H 应该足够，因为在单个过滤器中有$2^{23}$个键会产生仅为 $2^{-23}$ 的基线假阳率。
- H(x) 被有效地扩展/展开/重排为被消耗的内容。对于 Ribbon，最重要的是要最小化起始位置与其他哈希消费者之间的相关性。使用在 H(x) 上进行的 fastrange [45] 计算的起始位置主要依赖于高位，因此将H(x) 乘以一个大奇数常数（例如 Knuth 乘法哈希 [42]）似乎足以消除相关性。详细信息可以在 Ribbon 的参考实现中找到 [25]。

##### Re-seeding

一些 Ribbon 设计需要能够通过具有足够独立的哈希来重试构建，以具有独立的构建成功的概率。请注意，在 Ribbon 过滤器中，完整的哈希碰撞不会干扰构建成功（它只会产生一个多余的方程）。在大量测试中，我们发现使用未经播种的常规哈希值，通过与伪随机种子进行简单的异或，然后乘以一个大奇数常数足以获得独立的构建成功概率。详细信息请参阅 [25]。假设哈希是均匀的，重新播种失败的构建的一个有效替代方法是简单地将 m 增加一个因子，即 ${w+1} \over w$。

### Section6 Balanced Ribbon

Balanced Ribbon是一种用于扩展和空间优化标准 Ribbon 的实验性设计；有关实现细节，请参阅 [26]。我们将 Balanced Ribbon 视为新的即时和增量高斯消元算法开辟的设计空间中的一个示例，并鼓励后续工作来探索、优化和分析这个设计空间。

Balanced Ribbon通过软分片和适用于该领域的新的平衡分配方案扩展了标准 Ribbon（相关：[4, 6, 7, 17, 49, 58]）。与许多其他哈希方案一样，我们从每个条目在 Ribbon 中有两个可能位置的想法开始，由两个哈希给出：一个较早的主要位置和一个稍后的次要位置在一个不同的分片中。具有主要位置的分片在具有次要位置的分片之前构建，并在可能的情况下容纳键。如果不能容纳，我们称该键被“撞开”，必须在其次要分片中容纳，因此分片首先添加“撞开”的条目，以获得最佳成功机会。元数据被构建以指示哪些键被撞开 [21]。构建是贪婪的，因为分片尽量容纳尽可能多的键，而不考虑键将被撞到哪里，并且已构建的分片永远不会被重新访问。如果使用两个均匀的哈希，一个较小的主要哈希和一个较大的次要哈希，就会出现困难：后续的分片会被其次要位置的条目所主导。

#### 组织碰撞撞击的分片

为了使这个方案生效，我们将软分片组织成级别 1 到 𝓁，其中级别 𝑖 包含精确地 ⌈$2 ^{𝓁−𝑖−1}$⌉ 个分片，因此我们假设整体上有 $2 ^{𝓁−1}$ 个分片，即 𝑠 = $2 ^{𝓁−1}$ 。与一些多级哈希方案不同 [12, 41, 43]，一个条目的主要位置可以在任何级别 𝑖 上，而其次要位置均匀分布在级别 min(𝑖 + 1, 𝓁) 上。由于没有次要位置在级别 1 上，我们重载它以用于主要位置；级别 1 的分片具有主要位置的相对权重 1 + 𝛼，而其他级别的分片的权重为 1 - 𝛼。请参见图 7。由于每个分片平均有 𝑛/𝑠 个键，我们选择 𝛼 ≈ 3.5/$\sqrt {𝑛/𝑠}$，以确保即使对于具有三个泊松标准差低于平均条目数量的分片，也有足够的条目供应。（对于 𝑛/𝑠 ≈ 1000，我们使用 𝛼 = 1/8。）假设我们分配了空间开销。



