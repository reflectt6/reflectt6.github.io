---
layout: page-with-sidebar
title:  "过滤器优化"
date:   2023-11-21 10:47:03 +0800
author: reflectt6
categories: "大数据"
#permalink: 
mainTag: "大数据"
secondaryTag: "预研"
---

## [XOR Filter](https://arxiv.org/pdf/1912.08258.pdf)

业界如Lindorm，曾将Bloom Filter替换为Ribbon Filter提升缓存命中率。Ribbon Filter是由Xor Filter优化而来。所以Xor Filter需要作为前置条件理解一下。

但是看了知乎、CSDN好几篇帖子，写的相当抽象，我就不给引用了。说他们写的不认真吧，还画了很多图；说他们写的认真吧，细节很多错误；并且很多段落是一样的，感觉都是互相抄的；理解上的易错点也没有讲出来，看完还是云里雾里的。

无奈Google到了[论文](https://arxiv.org/pdf/1912.08258.pdf)，自己啃一遍吧。啃论文是真不容易，但是啃完也是真的懂了。尤其结合伪代码理解，豁然开朗。

我也懒得详细讲一遍了，仅把几个理解上的关键难点写出来：

### 论文里面那些符号怎么理解？

![image-20231121160157285](/assets/images/2023-11-21-过滤器优化//image-20231121160157285.png)

> U：表示所有可能作为Filter输入的元素
>
> S：表示你要对哪一个集合构建过滤器，Bloom过滤器需要提前构造，需要把已知的数据映射到过滤器中。这个提前构造可能很多人没概念。
>
> |S|：目标集合的大小
>
> B：Xor过滤器最终存在形态就是这么一个数组，数组里面存的是k位的数值
>
> c = |B|：过滤器的长度，论文建议长度由(1.23*|S|)+23计算得来
>
> fingerprint：也是个hash函数，可以将U中任意元素，映射为一个固定长度为k位的数值。实现上可以参考：比如把任意元素分成三组，3的机器码为11，因此你总可以得到固定长度为2位的数值。例如1对应01，2对应10，3对应11。
>
> h1、h2、h3:三个hash函数，分别将U中的元素映射到[0, c/3]、[c/3, 2c/3]、[2c/3, c]

### 如何构造Xor FIlter

主要看以下三个伪代码：Algorithm2、3、4

![image-20231121163234079](/assets/images/2023-11-21-过滤器优化//image-20231121163234079.png)

下面这个Algorithm 3 有几率失败。

![image-20231121163506675](/assets/images/2023-11-21-过滤器优化//image-20231121163506675.png)

论文给出了失败的概率统计

![image-20231121163601434](/assets/images/2023-11-21-过滤器优化//image-20231121163601434.png)

![image-20231121163643314](/assets/images/2023-11-21-过滤器优化//image-20231121163643314.png)

### 如何判断元素是否存在？

![image-20231121163727997](/assets/images/2023-11-21-过滤器优化//image-20231121163727997.png)

### 为什么这样的算法可以用来判断元素存在？

首先我们需要了解异或运算本身的性质

异或运算有：

1、交换律

2、结合律

3、两个相同数xor的结果总为0

4、任何数和0 xor总为数本身

Algorithm2、3、4这三个算法保证了：

`对于任意的数x, B[h0(x)]、B[h1(x)]、B[h2(x)]中有且仅有一个apply了Algorithm4中的下面的赋值语句`

至于为什么能保证，请结合算法本身理解，这一部分的理解可以参考[知乎里面的图解](https://zhuanlan.zhihu.com/p/543943112)

![image-20231121165802686](/assets/images/2023-11-21-过滤器优化//image-20231121165802686.png)

假如只有B[h0(x)] apply 了上面的赋值语句，也就是i=h0(x)的情况，有 

`B[h0(x)] xor B[h1(x)] xor B[h2(x)] `

 `= `

 `(fingerprint(x) xor B[h0(x)] xor B[h1(x)] xor B[h2(x)]) `

`xor B[h1(x)]`

`xor B[h2(x)]`

`=`

`fingerprint(x) xor B[h0(x)] xor B[h1(x)] xor B[h2(x)] xor B[h1(x)] xor B[h2(x)]`

`=`

`fingerprint(x) xor B[h0(x)]`

`=fingerprint(x)    #由于i=h0(x)，所以B[h0(x)]被赋值为0；`



## Ribbon Filter
