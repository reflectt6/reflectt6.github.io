---
layout: page-with-sidebar-math
title:  "过滤器优化"
date:   2023-11-23 10:47:03 +0800
author: reflectt6
categories: "大数据"
#permalink: 
mainTag: "大数据"
secondaryTag: "预研"
---

## [XOR Filter](https://arxiv.org/abs/1912.08258)

业界如Lindorm，曾将Bloom Filter替换为Ribbon Filter提升缓存命中率。Ribbon Filter是由Xor Filter优化而来。所以Xor Filter需要作为前置条件理解一下。

但是看了知乎、CSDN好几篇帖子，写的相当抽象，我就不给引用了。说他们写的不认真吧，还画了很多图；说他们写的认真吧，细节很多错误；并且很多段落是一样的，感觉都是互相抄的；理解上的易错点也没有讲出来，看完还是云里雾里的。

无奈Google到了[论文](https://arxiv.org/pdf/1912.08258.pdf)，自己啃一遍吧。啃论文是真不容易，但是啃完也是真的懂了。尤其结合伪代码理解，豁然开朗。

我也懒得详细讲一遍了，仅把几个理解上的关键难点写出来：

### 论文里面那些符号怎么理解？

![image-20231121160157285](/assets/images/2023-11-21-过滤器优化//image-20231121160157285.png)

> U：表示所有可能作为Filter输入的元素
>
> S：表示你要对哪一个集合构建过滤器，Bloom过滤器需要提前构造，需要把已知的数据映射到过滤器中。这个提前构造可能很多人没概念。
>
> \|S\|：目标集合的大小
>
> B：Xor过滤器最终存在形态就是这么一个数组，数组里面存的是k位的数值
>
> c = \|B\|：过滤器的长度，论文建议长度由(1.23*\|S\|)+23计算得来
>
> fingerprint：也是个hash函数，可以将U中任意元素，映射为一个固定长度为k位的数值。实现上可以参考：比如把任意元素分成三组，3的机器码为11，因此你总可以得到固定长度为2位的数值。例如1对应01，2对应10，3对应11。
>
> h1、h2、h3:三个hash函数，分别将U中的元素映射到[0, c/3]、[c/3, 2c/3]、[2c/3, c]

### 如何构造Xor FIlter

主要看以下三个伪代码：Algorithm2、3、4

![image-20231121163234079](/assets/images/2023-11-21-过滤器优化//image-20231121163234079.png)

下面这个Algorithm 3 有几率失败。

![image-20231121163506675](/assets/images/2023-11-21-过滤器优化//image-20231121163506675.png)

论文给出了失败的概率统计

![image-20231121163601434](/assets/images/2023-11-21-过滤器优化//image-20231121163601434.png)

![image-20231121163643314](/assets/images/2023-11-21-过滤器优化//image-20231121163643314.png)

### 如何判断元素是否存在？

![image-20231121163727997](/assets/images/2023-11-21-过滤器优化//image-20231121163727997.png)

### 为什么这样的算法可以用来判断元素存在？

首先我们需要了解异或运算本身的性质

异或运算有：

1、交换律

2、结合律

3、两个相同数xor的结果总为0

4、任何数和0 xor总为数本身

Algorithm2、3、4这三个算法保证了：

`对于任意的数x, B[h0(x)]、B[h1(x)]、B[h2(x)]中有且仅有一个apply了Algorithm4中的下面的赋值语句`

至于为什么能保证，请结合算法本身理解，这一部分的理解可以参考[知乎里面的图解](https://zhuanlan.zhihu.com/p/543943112)

![image-20231121165802686](/assets/images/2023-11-21-过滤器优化//image-20231121165802686.png)

假如只有B[h0(x)] apply 了上面的赋值语句，也就是i=h0(x)的情况，有 

`B[h0(x)] xor B[h1(x)] xor B[h2(x)] `

 `= `

 `(fingerprint(x) xor B[h0(x)] xor B[h1(x)] xor B[h2(x)]) `

`xor B[h1(x)]`

`xor B[h2(x)]`

`=`

`fingerprint(x) xor B[h0(x)] xor B[h1(x)] xor B[h2(x)] xor B[h1(x)] xor B[h2(x)]`

`=`

`fingerprint(x) xor B[h0(x)]`

`=fingerprint(x)    #由于i=h0(x)，所以B[h0(x)]被赋值为0；`



## [Ribbon Filter](https://arxiv.org/abs/2103.02515)

受过知乎文章的折磨，这次直接看[论文](https://arxiv.org/pdf/2103.02515.pdf)吧

然后被论文这折磨了一遍，这论文比xor filter难懂的多，还好[知乎](https://zhuanlan.zhihu.com/p/565523164)上有个大佬分析了一波

### 一个r位数，每个位可能的取值为0或者1: $$ \{0,1\}^r $$

异或: $$\bigoplus$$

同或: $$\bigodot$$



看知乎上说Ribbon Filter用的是高斯消元，而Rox Filter用的是Peeling，什么是Peeling？这个也是论文里面定义的，原文如下：

` Standard Xor filters use a fast solving process called peeling that limits their space efficiency to ≥ 1.22𝜆 bits per key7`

#### 论文概述

Section 2

简短的回顾了“static functions”，这个和java中的静态方法不是一个东西。作者想通过“static functions”定义一个过滤器

Section 3

分析Ribbon的构造算法；提出一个提升空间效率的优化“smash”；这些特性会导致，key数量上升的同时，空间或者时间开销上升。

Section 4

提出Homogeneous Ribbon filter，和Blocked bloom filter 共享许多参数。优点为：1、构造的成功性是可以保证的 2、扩展至任意的key数量，都是高效的

实现简单，但是要分析更多

Section 5

描述一些实验性的问题：

1、有效利用任意key数量的内存

2、高效查询的数据分布

3、高效满足hash需求

4、扩展标准Ribbon通过数据共享

Section 6

提出Balanced ribbon，通过连续ribbon，贪婪的加载balancing表。极大优化了“smash”的ribbon空间效率。

Section 7

更多实验验证。



#### Section3

从“静态方法（没啥实际含义，当个称呼就行）”构建ribbon过滤器

这个“静态方法”来自一篇[论文](https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ESA.2019.39)，通过矩阵高效求解高斯消元问题。

ribbon过滤器实际上就是这个高斯方法的应用。

[论文PDF](https://drops.dagstuhl.de/storage/00lipics/lipics-vol144-esa2019/LIPIcs.ESA.2019.39/LIPIcs.ESA.2019.39.pdf)，挺离谱的，一个图都没有，全是字！

然后用图文给出了ribbon构造算法。

介绍了ribbon的一种错误场景（没看懂），以及解决思路。



#### Section4

HOMOGENEOUS RIBBON FILTERS是齐次ribbon过滤器的意思。就是线性代数里面齐次线性方程的齐次。也就是右侧的矩阵为0矩阵。齐次线性方程必有零解。



## [RocksDB](https://github.com/facebook/rocksdb)

Facebook团队开发的key-value类型的存储库，采用c++开发，封装JNI给Java代码提供服务，但是Java的接口可能是滞后的（因为没时间同步，推荐开发者自发提PR）。

与HBase很类似，都是支持任意大小的键值对。区别在于HBase专注于大数据生态。而RocksDB支持各种存储硬件，包括纯内存，闪存、硬盘、远程存储等。

RocksDB详细文档在[github wiki](https://github.com/facebook/rocksdb/wiki)上

如何使用在[这里](https://github.com/facebook/rocksdb/wiki/Basic-Operations)

如何使用Java接口在[这里](https://github.com/facebook/rocksdb/wiki/RocksJava-Basics)

编译构建在[这里](https://github.com/facebook/rocksdb/blob/main/INSTALL.md)

针对



