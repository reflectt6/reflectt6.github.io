---
layout: page-with-sidebar-math
title:  "è¿‡æ»¤å™¨ä¼˜åŒ–"
date:   2023-11-23 10:47:03 +0800
author: reflectt6
categories: "å¤§æ•°æ®"
#permalink: 
mainTag: "å¤§æ•°æ®"
secondaryTag: "é¢„ç ”"
---

## [XOR Filter](https://arxiv.org/abs/1912.08258)

ä¸šç•Œå¦‚Lindormï¼Œæ›¾å°†Bloom Filteræ›¿æ¢ä¸ºRibbon Filteræå‡ç¼“å­˜å‘½ä¸­ç‡ã€‚Ribbon Filteræ˜¯ç”±Xor Filterä¼˜åŒ–è€Œæ¥ã€‚æ‰€ä»¥Xor Filteréœ€è¦ä½œä¸ºå‰ç½®æ¡ä»¶ç†è§£ä¸€ä¸‹ã€‚

ä½†æ˜¯çœ‹äº†çŸ¥ä¹ã€CSDNå¥½å‡ ç¯‡å¸–å­ï¼Œå†™çš„ç›¸å½“æŠ½è±¡ï¼Œæˆ‘å°±ä¸ç»™å¼•ç”¨äº†ã€‚è¯´ä»–ä»¬å†™çš„ä¸è®¤çœŸå§ï¼Œè¿˜ç”»äº†å¾ˆå¤šå›¾ï¼›è¯´ä»–ä»¬å†™çš„è®¤çœŸå§ï¼Œç»†èŠ‚å¾ˆå¤šé”™è¯¯ï¼›å¹¶ä¸”å¾ˆå¤šæ®µè½æ˜¯ä¸€æ ·çš„ï¼Œæ„Ÿè§‰éƒ½æ˜¯äº’ç›¸æŠ„çš„ï¼›ç†è§£ä¸Šçš„æ˜“é”™ç‚¹ä¹Ÿæ²¡æœ‰è®²å‡ºæ¥ï¼Œçœ‹å®Œè¿˜æ˜¯äº‘é‡Œé›¾é‡Œçš„ã€‚

æ— å¥ˆGoogleåˆ°äº†[è®ºæ–‡](https://arxiv.org/pdf/1912.08258.pdf)ï¼Œè‡ªå·±å•ƒä¸€éå§ã€‚å•ƒè®ºæ–‡æ˜¯çœŸä¸å®¹æ˜“ï¼Œä½†æ˜¯å•ƒå®Œä¹Ÿæ˜¯èƒ½æ‡‚å¾—ã€‚ä¸»è¦æ˜¯ç»“åˆä¼ªä»£ç ç†è§£ï¼Œè±ç„¶å¼€æœ—ã€‚çªç„¶æƒ³åˆ°æŸäººè¯´çš„ï¼Œ`talk is cheapï¼Œshow me the code`ï¼Œæ‰€ä»¥å°±æ˜¯è¯´è¿™äº›è®ºæ–‡åœ¨bbä»€ä¹ˆï¼Œç›´æ¥ç»™ä»£ç ä¸å°±å®Œäº‹äº†å—ã€‚ã€‚

å‡ ä¸ªç†è§£ä¸Šçš„å…³é”®éš¾ç‚¹ï¼š

### è®ºæ–‡é‡Œé¢é‚£äº›ç¬¦å·æ€ä¹ˆç†è§£ï¼Ÿ

![image-20231121160157285](/assets/images/2023-11-21-è¿‡æ»¤å™¨ä¼˜åŒ–//image-20231121160157285.png)

> Uï¼šè¡¨ç¤ºæ‰€æœ‰å¯èƒ½ä½œä¸ºFilterè¾“å…¥çš„å…ƒç´ 
>
> Sï¼šè¡¨ç¤ºä½ è¦å¯¹å“ªä¸€ä¸ªé›†åˆæ„å»ºè¿‡æ»¤å™¨ï¼ŒBloomè¿‡æ»¤å™¨éœ€è¦æå‰æ„é€ ï¼Œéœ€è¦æŠŠå·²çŸ¥çš„æ•°æ®æ˜ å°„åˆ°è¿‡æ»¤å™¨ä¸­ã€‚è¿™ä¸ªæå‰æ„é€ å¯èƒ½å¾ˆå¤šäººæ²¡æ¦‚å¿µã€‚
>
> \|S\|ï¼šç›®æ ‡é›†åˆçš„å¤§å°
>
> Bï¼šXorè¿‡æ»¤å™¨æœ€ç»ˆå­˜åœ¨å½¢æ€å°±æ˜¯è¿™ä¹ˆä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„é‡Œé¢å­˜çš„æ˜¯kä½çš„æ•°å€¼
>
> c = \|B\|ï¼šè¿‡æ»¤å™¨çš„é•¿åº¦ï¼Œè®ºæ–‡å»ºè®®é•¿åº¦ç”±(1.23*\|S\|)+23è®¡ç®—å¾—æ¥
>
> fingerprintï¼šä¹Ÿæ˜¯ä¸ªhashå‡½æ•°ï¼Œå¯ä»¥å°†Uä¸­ä»»æ„å…ƒç´ ï¼Œæ˜ å°„ä¸ºä¸€ä¸ªå›ºå®šé•¿åº¦ä¸ºkä½çš„æ•°å€¼ã€‚å®ç°ä¸Šå¯ä»¥å‚è€ƒï¼šæ¯”å¦‚æŠŠä»»æ„å…ƒç´ åˆ†æˆä¸‰ç»„ï¼Œ3çš„æœºå™¨ç ä¸º11ï¼Œå› æ­¤ä½ æ€»å¯ä»¥å¾—åˆ°å›ºå®šé•¿åº¦ä¸º2ä½çš„æ•°å€¼ã€‚ä¾‹å¦‚1å¯¹åº”01ï¼Œ2å¯¹åº”10ï¼Œ3å¯¹åº”11ã€‚
>
> h1ã€h2ã€h3:ä¸‰ä¸ªhashå‡½æ•°ï¼Œåˆ†åˆ«å°†Uä¸­çš„å…ƒç´ æ˜ å°„åˆ°[0, c/3]ã€[c/3, 2c/3]ã€[2c/3, c]

### å¦‚ä½•æ„é€ Xor FIlter

ä¸»è¦çœ‹ä»¥ä¸‹ä¸‰ä¸ªä¼ªä»£ç ï¼šAlgorithm2ã€3ã€4

![image-20231121163234079](/assets/images/2023-11-21-è¿‡æ»¤å™¨ä¼˜åŒ–//image-20231121163234079.png)

ä¸‹é¢è¿™ä¸ªAlgorithm 3 æœ‰å‡ ç‡å¤±è´¥ã€‚

![image-20231121163506675](/assets/images/2023-11-21-è¿‡æ»¤å™¨ä¼˜åŒ–//image-20231121163506675.png)

è®ºæ–‡ç»™å‡ºäº†å¤±è´¥çš„æ¦‚ç‡ç»Ÿè®¡

![image-20231121163601434](/assets/images/2023-11-21-è¿‡æ»¤å™¨ä¼˜åŒ–//image-20231121163601434.png)

![image-20231121163643314](/assets/images/2023-11-21-è¿‡æ»¤å™¨ä¼˜åŒ–//image-20231121163643314.png)

### å¦‚ä½•åˆ¤æ–­å…ƒç´ æ˜¯å¦å­˜åœ¨ï¼Ÿ

![image-20231121163727997](/assets/images/2023-11-21-è¿‡æ»¤å™¨ä¼˜åŒ–//image-20231121163727997.png)

### ä¸ºä»€ä¹ˆè¿™æ ·çš„ç®—æ³•å¯ä»¥ç”¨æ¥åˆ¤æ–­å…ƒç´ å­˜åœ¨ï¼Ÿ

é¦–å…ˆæˆ‘ä»¬éœ€è¦äº†è§£å¼‚æˆ–è¿ç®—æœ¬èº«çš„æ€§è´¨

å¼‚æˆ–è¿ç®—æœ‰ï¼š

1ã€äº¤æ¢å¾‹

2ã€ç»“åˆå¾‹

3ã€ä¸¤ä¸ªç›¸åŒæ•°xorçš„ç»“æœæ€»ä¸º0

4ã€ä»»ä½•æ•°å’Œ0 xoræ€»ä¸ºæ•°æœ¬èº«

Algorithm2ã€3ã€4è¿™ä¸‰ä¸ªç®—æ³•ä¿è¯äº†ï¼š

`å¯¹äºä»»æ„çš„æ•°x, B[h0(x)]ã€B[h1(x)]ã€B[h2(x)]ä¸­æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªapplyäº†Algorithm4ä¸­çš„ä¸‹é¢çš„èµ‹å€¼è¯­å¥`

è‡³äºä¸ºä»€ä¹ˆèƒ½ä¿è¯ï¼Œè¯·ç»“åˆç®—æ³•æœ¬èº«ç†è§£ï¼Œè¿™ä¸€éƒ¨åˆ†çš„ç†è§£å¯ä»¥å‚è€ƒ[çŸ¥ä¹é‡Œé¢çš„å›¾è§£](https://zhuanlan.zhihu.com/p/543943112)

![image-20231121165802686](/assets/images/2023-11-21-è¿‡æ»¤å™¨ä¼˜åŒ–//image-20231121165802686.png)

å‡å¦‚åªæœ‰B[h0(x)] apply äº†ä¸Šé¢çš„èµ‹å€¼è¯­å¥ï¼Œä¹Ÿå°±æ˜¯i=h0(x)çš„æƒ…å†µï¼Œæœ‰ 

`B[h0(x)] xor B[h1(x)] xor B[h2(x)] `

 `= `

 `(fingerprint(x) xor B[h0(x)] xor B[h1(x)] xor B[h2(x)]) `

`xor B[h1(x)]`

`xor B[h2(x)]`

`=`

`fingerprint(x) xor B[h0(x)] xor B[h1(x)] xor B[h2(x)] xor B[h1(x)] xor B[h2(x)]`

`=`

`fingerprint(x) xor B[h0(x)]`

`=fingerprint(x)    #ç”±äºi=h0(x)ï¼Œæ‰€ä»¥B[h0(x)]è¢«èµ‹å€¼ä¸º0ï¼›`



## [Ribbon Filter](https://arxiv.org/abs/2103.02515)

[è®ºæ–‡](https://arxiv.org/pdf/2103.02515.pdf)

è¿™è®ºæ–‡æ¯”xor filteréš¾æ‡‚çš„å¤šï¼Œå¯ä»¥é€‚å½“å‚è€ƒ[çŸ¥ä¹](https://zhuanlan.zhihu.com/p/565523164)å¤§ä½¬çš„åˆ†æ

ä¸€ä¸ªrä½æ•°ï¼Œæ¯ä¸ªä½å¯èƒ½çš„å–å€¼ä¸º0æˆ–è€…1: $$ \{0,1\}^r $$

å¼‚æˆ–: $$\bigoplus$$

åŒæˆ–: $$\bigodot$$



çœ‹çŸ¥ä¹ä¸Šè¯´Ribbon Filterç”¨çš„æ˜¯é«˜æ–¯æ¶ˆå…ƒï¼Œè€ŒRox Filterç”¨çš„æ˜¯Peelingï¼Œä»€ä¹ˆæ˜¯Peelingï¼Ÿè¿™ä¸ªä¹Ÿæ˜¯è®ºæ–‡é‡Œé¢å®šä¹‰çš„ï¼ŒåŸæ–‡å¦‚ä¸‹ï¼š

`Standard Xor filters use a fast solving process called peeling that limits their space efficiency to â‰¥ 1.22ğœ† bits per key7`

#### è®ºæ–‡æ¦‚è¿°

Section 2

ç®€çŸ­çš„å›é¡¾äº†â€œstatic functionsâ€ï¼Œè¿™ä¸ªå’Œjavaä¸­çš„é™æ€æ–¹æ³•ä¸æ˜¯ä¸€ä¸ªä¸œè¥¿ã€‚ä½œè€…æƒ³é€šè¿‡â€œstatic functionsâ€å®šä¹‰ä¸€ä¸ªè¿‡æ»¤å™¨

Section 3

åˆ†æRibbonçš„æ„é€ ç®—æ³•ï¼›æå‡ºä¸€ä¸ªæå‡ç©ºé—´æ•ˆç‡çš„ä¼˜åŒ–â€œsmashâ€ï¼›è¿™äº›ç‰¹æ€§ä¼šå¯¼è‡´ï¼Œkeyæ•°é‡ä¸Šå‡çš„åŒæ—¶ï¼Œç©ºé—´æˆ–è€…æ—¶é—´å¼€é”€ä¸Šå‡ã€‚

Section 4

æå‡ºHomogeneous Ribbon filterï¼Œå’ŒBlocked bloom filter å…±äº«è®¸å¤šå‚æ•°ã€‚ä¼˜ç‚¹ä¸ºï¼š1ã€æ„é€ çš„æˆåŠŸæ€§æ˜¯å¯ä»¥ä¿è¯çš„ 2ã€æ‰©å±•è‡³ä»»æ„çš„keyæ•°é‡ï¼Œéƒ½æ˜¯é«˜æ•ˆçš„

å®ç°ç®€å•ï¼Œä½†æ˜¯è¦åˆ†ææ›´å¤š

Section 5

æè¿°ä¸€äº›å®éªŒæ€§çš„é—®é¢˜ï¼š

1ã€æœ‰æ•ˆåˆ©ç”¨ä»»æ„keyæ•°é‡çš„å†…å­˜

2ã€é«˜æ•ˆæŸ¥è¯¢çš„æ•°æ®åˆ†å¸ƒ

3ã€é«˜æ•ˆæ»¡è¶³hashéœ€æ±‚

4ã€æ‰©å±•æ ‡å‡†Ribboné€šè¿‡æ•°æ®å…±äº«

Section 6

æå‡ºBalanced ribbonï¼Œé€šè¿‡è¿ç»­ribbonï¼Œè´ªå©ªçš„åŠ è½½balancingè¡¨ã€‚æå¤§ä¼˜åŒ–äº†â€œsmashâ€çš„ribbonç©ºé—´æ•ˆç‡ã€‚

Section 7

æ›´å¤šå®éªŒéªŒè¯ã€‚



#### Section3

ä»â€œé™æ€æ–¹æ³•ï¼ˆæ²¡å•¥å®é™…å«ä¹‰ï¼Œå½“ä¸ªç§°å‘¼å°±è¡Œï¼‰â€æ„å»ºribbonè¿‡æ»¤å™¨

è¿™ä¸ªâ€œé™æ€æ–¹æ³•â€æ¥è‡ªä¸€ç¯‡[è®ºæ–‡](https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ESA.2019.39)ï¼Œé€šè¿‡çŸ©é˜µé«˜æ•ˆæ±‚è§£é«˜æ–¯æ¶ˆå…ƒé—®é¢˜ã€‚

ribbonè¿‡æ»¤å™¨å®é™…ä¸Šå°±æ˜¯è¿™ä¸ªé«˜æ–¯æ–¹æ³•çš„åº”ç”¨ã€‚

[è®ºæ–‡PDF](https://drops.dagstuhl.de/storage/00lipics/lipics-vol144-esa2019/LIPIcs.ESA.2019.39/LIPIcs.ESA.2019.39.pdf)ï¼ŒæŒºç¦»è°±çš„ï¼Œä¸€ä¸ªå›¾éƒ½æ²¡æœ‰ï¼Œå…¨æ˜¯å­—ï¼

ç„¶åç”¨å›¾æ–‡ç»™å‡ºäº†ribbonæ„é€ ç®—æ³•ã€‚

ä»‹ç»äº†ribbonçš„ä¸€ç§é”™è¯¯åœºæ™¯ï¼ˆæ²¡çœ‹æ‡‚ï¼‰ï¼Œä»¥åŠè§£å†³æ€è·¯ã€‚



#### Section4

HOMOGENEOUS RIBBON FILTERSæ˜¯é½æ¬¡ribbonè¿‡æ»¤å™¨çš„æ„æ€ã€‚å°±æ˜¯çº¿æ€§ä»£æ•°é‡Œé¢é½æ¬¡çº¿æ€§æ–¹ç¨‹çš„é½æ¬¡ã€‚ä¹Ÿå°±æ˜¯å³ä¾§çš„çŸ©é˜µä¸º0çŸ©é˜µã€‚é½æ¬¡çº¿æ€§æ–¹ç¨‹å¿…æœ‰é›¶è§£ã€‚



## [RocksDB](https://github.com/facebook/rocksdb)

Facebookå›¢é˜Ÿå¼€å‘çš„key-valueç±»å‹çš„å­˜å‚¨åº“ï¼Œé‡‡ç”¨c++å¼€å‘ï¼Œå°è£…JNIç»™Javaä»£ç æä¾›æœåŠ¡ï¼Œä½†æ˜¯Javaçš„æ¥å£å¯èƒ½æ˜¯æ»åçš„ï¼ˆå› ä¸ºæ²¡æ—¶é—´åŒæ­¥ï¼Œæ¨èå¼€å‘è€…è‡ªå‘æPRï¼‰ã€‚

ä¸HBaseå¾ˆç±»ä¼¼ï¼Œéƒ½æ˜¯æ”¯æŒä»»æ„å¤§å°çš„é”®å€¼å¯¹ã€‚åŒºåˆ«åœ¨äºHBaseä¸“æ³¨äºå¤§æ•°æ®ç”Ÿæ€ã€‚è€ŒRocksDBæ”¯æŒå„ç§å­˜å‚¨ç¡¬ä»¶ï¼ŒåŒ…æ‹¬çº¯å†…å­˜ï¼Œé—ªå­˜ã€ç¡¬ç›˜ã€è¿œç¨‹å­˜å‚¨ç­‰ã€‚

RocksDBè¯¦ç»†æ–‡æ¡£åœ¨[github wiki](https://github.com/facebook/rocksdb/wiki)ä¸Š

å¦‚ä½•ä½¿ç”¨åœ¨[è¿™é‡Œ](https://github.com/facebook/rocksdb/wiki/Basic-Operations)

å¦‚ä½•ä½¿ç”¨Javaæ¥å£åœ¨[è¿™é‡Œ](https://github.com/facebook/rocksdb/wiki/RocksJava-Basics)

ç¼–è¯‘æ„å»ºåœ¨[è¿™é‡Œ](https://github.com/facebook/rocksdb/blob/main/INSTALL.md)

### æºç åˆ†æï¼ˆé™æ€ï¼‰

#### UTèµ·æ‰‹

ä»UTå…¥æ‰‹ï¼Œå…³äºribbon filterçš„UTå…¥å£åœ¨ribbon_test.ccæ–‡ä»¶ä¸­ã€‚ç”¨åˆ°äº†gtestæµ‹è¯•æ¡†æ¶

gtestæœ¬è´¨ä¸Šåšçš„äº‹æƒ…å°±æ˜¯å°†æµ‹è¯•å†…å®¹ä½œä¸ºå‚æ•°ä¼ é€’ï¼Œä¾‹å¦‚æµ‹è¯•çš„æ•°æ®ç±»å‹ä½œä¸ºå‚æ•°ï¼Œæµ‹è¯•æ•°æ®ä½œä¸ºå‚æ•°

```c++
using TestTypesAndSettings = ::testing::Types<
    TypesAndSettings_Coeff128, TypesAndSettings_Coeff128Smash,
    TypesAndSettings_Coeff64, TypesAndSettings_Coeff64Smash,
    TypesAndSettings_Coeff64Smash0, TypesAndSettings_Coeff128_Homog,
    TypesAndSettings_Coeff128Smash_Homog, TypesAndSettings_Coeff64_Homog,
    TypesAndSettings_Coeff64Smash_Homog, TypesAndSettings_Result16,
    TypesAndSettings_Result32, TypesAndSettings_IndexSizeT,
    TypesAndSettings_Hash32, TypesAndSettings_Hash32_Result16,
    TypesAndSettings_KeyString, TypesAndSettings_Seed8,
    TypesAndSettings_NoAlwaysOne, TypesAndSettings_AllowZeroStarts,
    TypesAndSettings_Seed64, TypesAndSettings_Rehasher,
    TypesAndSettings_Rehasher_Result16, TypesAndSettings_Rehasher_Result32,
    TypesAndSettings_Rehasher_Seed64, TypesAndSettings_Rehasher32,
    TypesAndSettings_Rehasher32_Coeff64, TypesAndSettings_SmallKeyGen,
    TypesAndSettings_Hash32_SmallKeyGen, TypesAndSettings_Coeff32,
    TypesAndSettings_Coeff32Smash, TypesAndSettings_Coeff16,
    TypesAndSettings_Coeff16Smash>;
TYPED_TEST_CASE(RibbonTypeParamTest, TestTypesAndSettings);
```

TYPED_TEST_CASEåº”è¯¥æ˜¯æ³¨å†Œäº†æµ‹è¯•çš„æ•°æ®ç±»å‹ã€‚

```c++
TYPED_TEST(RibbonTypeParamTest, CompactnessAndBacktrackAndFpRate) {
  IMPORT_RIBBON_TYPES_AND_SETTINGS(TypeParam);
  IMPORT_RIBBON_IMPL_TYPES(TypeParam);
  using KeyGen = typename TypeParam::KeyGen;
  using ConfigHelper =
      ROCKSDB_NAMESPACE::ribbon::BandingConfigHelper<TypeParam>;
  ã€‚ã€‚ã€‚ã€‚
```

æ³¨å†Œå®Œä¹‹åï¼Œä¸‹é¢å¯¹äºRibbonTypeParamTestçš„æµ‹è¯•åº”è¯¥å°±ä¼šå°†ä¸Šé¢æ‰€æœ‰ç±»å‹éƒ½è·‘ä¸€éï¼Œä¹Ÿå°±æ˜¯åˆ«çœ‹è¿™åªæ˜¯ä¸€ä¸ªUTï¼Œä½†å®é™…ä¸Šä¼šæµ‹å‡ åç§ç±»å‹ï¼Œä¹Ÿæ˜¯æ¡†æ¶çš„èƒ½åŠ›æ‰€åœ¨ã€‚è€ŒCompactnessAndBacktrackAndFpRateåº”è¯¥ç±»ä¼¼Java UTä¸­çš„case nameã€‚

æ—¢ç„¶æ‰¾åˆ°äº†UTï¼Œä¸‹ä¸€æ­¥å°±æ˜¯æ‰¾Ribbon filterçš„å®ç°ã€‚æ¢ä½æ€è€ƒï¼Œå¦‚æœæˆ‘å†™äº†ä¸€ä¸ªRibbon filter æˆ‘ä¼šå†™ä»€ä¹ˆæ ·çš„UTæ¥æµ‹ï¼Ÿ

â€‹	1ã€Ribbon filterç›®çš„åœ¨èŠ‚çœå†…å­˜ç©ºé—´ï¼Œé‚£ä¹ˆæˆ‘ä¸€å®šè¦å¯¹æ¯”è¿™ä¸ªfilterå’Œbloom filterçš„å ç”¨ç©ºé—´

â€‹	2ã€å¯¹æ¯”ribbonå’Œbloomçš„æ„å»ºæ—¶é—´ã€‚ã€‚ï¼ˆå¯èƒ½ï¼‰

â€‹	3ã€éšæœºç”Ÿæˆä¸€ä¸‹queryï¼ŒæŸ¥çœ‹Fp rate(é”™è¯¯ç‡)ï¼Œå¹¶ä¸”å’Œbloomå¯¹æ¯”

é‚£å†çœ‹ä¸‹å®é™…ä¸Šæœ‰å“ªäº›æµ‹è¯•å†…å®¹ï¼Œæ®æˆ‘çš„æµ‹è¯•TYPED_TESTä¼šapplyä¸Šé¢é‚£æ³¨å†Œçš„ä¸€å †ç±»å‹ï¼Œä½†æ˜¯TESTä¸ä¼šï¼Œåªä¼šè¿è¡Œä¸€æ¬¡ã€‚

```c++
//1ã€æµ‹è¯•å„ç§ç±»å‹
TYPED_TEST(RibbonTypeParamTest, CompactnessAndBacktrackAndFpRate) // å‹ç¼©ç‡å’Œé”™è¯¯ç‡

TYPED_TEST(RibbonTypeParamTest, Extremes) // æç«¯æƒ…å†µï¼Ÿ

// Not a real test, but a tool used to build APIs in ribbon_config.h
TYPED_TEST(RibbonTypeParamTest, FindOccupancy)

// Not a real test, but a tool to understand Homogeneous Ribbon
// behavior (TODO: configuration APIs & tests)
TYPED_TEST(RibbonTypeParamTest, OptimizeHomogAtScale) // è¿™ç©æ„æ˜¯ç†è§£Homogeneous Ribbonçš„å·¥å…·ï¼Ÿ
```

å…³æ³¨çš„å˜é‡æœ‰å“ªäº›ï¼Ÿåˆ†åˆ«å¯¹åº”ç®—æ³•ä¸­çš„ä»€ä¹ˆå€¼ï¼Ÿ

```c
TEST(RibbonTest, AllowZeroStarts) // å…è®¸ä»¥0å¼€å¤´ï¼Œé‚£ä¹ˆæ˜¯ä»€ä¹ˆçš„å¼€å¤´å‘¢ï¼Ÿ

TEST(RibbonTest, RawAndOrdinalSeeds) // åŸå§‹çš„ç§å­ æµ‹è¯•ï¼Œç§å­æ˜¯å¹²ä»€ä¹ˆçš„ï¼Ÿ ç”ŸæˆHashï¼Ÿ

TEST(RibbonTest, PhsfBasic) // phsfæ˜¯å•¥ï¼Ÿ
```

okï¼Œè¿™åå­—èµ·çš„éå¸¸å¥½ï¼Œçœ‹ä¼¼æ²¡å•¥ç”¨ï¼Œå®åˆ™ä¸€ç‚¹ç”¨æ²¡æœ‰ã€‚

ä¸¤ä¸ªå…³é”®å®

```c++
IMPORT_RIBBON_TYPES_AND_SETTINGS(TypeParam);
IMPORT_RIBBON_IMPL_TYPES(TypeParam);
```

ç¬¬ä¸€ä¸ªå®å¯ä»¥å¾—åˆ°ribbon filterå…³æ³¨çš„å˜é‡æœ‰å“ªäº›

```
CoeffRow -ã€‹ç³»æ•°çŸ©é˜µçš„è¡Œ
ResultRow â€”ã€‹ç»“æœçŸ©é˜µçš„è¡Œ
ä¸Šé¢ä¸¤ä¸ªçŸ©é˜µæ˜¯ä¸ºäº†æ±‚è§£solutionçŸ©é˜µ

Index
Hash
Key
Seed

/* Some more additions */    
QueryInput
AddInput
kCoeffBits --ã€‹å¯¹åº”è®ºæ–‡ä¸­çš„w

/* Export to algorithm */
kFirstCoeffAlwaysOne 
```

ç¬¬äºŒä¸ªå®ï¼Œå¯ä»¥å¾—åˆ°ribbon filterå®ç°æ‰€éœ€è¦çš„å‡ ä¸ªå…³é”®å¯¹è±¡

```
using Hasher = ROCKSDB_NAMESPACE::ribbon::StandardHasher<TypesAndSettings>;
using Banding = ROCKSDB_NAMESPACE::ribbon::StandardBanding<TypesAndSettings>;    
using SimpleSoln = ROCKSDB_NAMESPACE::ribbon::InMemSimpleSolution<TypesAndSettings>;
using InterleavedSoln = ROCKSDB_NAMESPACE::ribbon::SerializableInterleavedSolution<TypesAndSettings>;
```

æŠŠä¸Šé¢è¿™å‡ ä¸ªå‚æ•°å’Œå¯¹è±¡ææ˜ç™½ribbon filteråŸºæœ¬ä¸Šå¯ä»¥æå®š

#### ribbonç›¸å…³ä»£ç 

ä»UTå…¥æ‰‹å¯ä»¥å¾—åˆ°å‡ ä¸ªribbonç›¸å…³çš„ä»£ç æ–‡ä»¶

- ribbon_impl.h
- ribbon_alg.h
- ribbon_config.h

#### Hasher

`StandardHasher: A standard implementation of concepts RibbonTypes, PhsfQueryHasher, FilterQueryHasher, and BandingHasher from ribbon_alg.h.`



RibbonTypes, PhsfQueryHasher, FilterQueryHasher, and BandingHasheræ˜¯ä¾æ¬¡ç»§æ‰¿è¿‡æ¥çš„ï¼Œåœ¨åé¢æœ‰è§£é‡Š

ä»–ä»¬çš„å®ç°åœ¨ribbon_alg.hä¸­

å…³äº Hasherçš„æ³¨é‡Šï¼Œtranslated by chatGpt 3.5

```
è¿™ä¸ªå®ç°åœ¨å¤§å¤šæ•°å®é™…æƒ…å†µä¸‹åº”è¯¥æ˜¯åˆé€‚çš„ï¼Œå› ä¸ºå®ƒåœ¨å„ç§è®¾ç½®ä¸‹éƒ½èƒ½å¤Ÿâ€œè¡¨ç°â€è‰¯å¥½ï¼Œå‡ ä¹æ²¡æœ‰æ”¹è¿›çš„ä½™åœ°ã€‚åœ¨è¿™ä¸ªå“ˆå¸Œå‡½æ•°ä¸­çš„å…³é”®åŠŸèƒ½æ˜¯ä»ä¸€ä¸ªé€‚åº¦çš„64ä½æˆ–è€…ä»…ä»…32ä½çš„å“ˆå¸Œä¸­ç”ŸæˆCoeffRowsã€startså’Œï¼ˆå¯¹äºè¿‡æ»¤å™¨è€Œè¨€ï¼‰ResultRowsï¼Œè¿™å¯èƒ½æ˜¯150ä½ç”šè‡³æ›´å¤šçš„æ•°æ®ï¼Œå…·æœ‰è¶³å¤Ÿçš„å‡åŒ€æ€§å’Œä½ç‹¬ç«‹æ€§ï¼Œä»¥æ¥è¿‘åœ¨FPç‡å’Œç´§å‡‘æ€§æ–¹é¢åˆ©ç”¨å¯ç”¨å“ˆå¸Œä¿¡æ¯â€œåšåˆ°æœ€å¥½â€çš„æ°´å¹³ã€‚ï¼ˆå¯¹äºPHSFçš„å®é™…ç›®çš„ï¼Œæ¨èä½¿ç”¨64ä½å¹¶ä¸”è¶³å¤Ÿã€‚ï¼‰

è¿™ä¸ªå“ˆå¸Œå‡½æ•°çš„å¦ä¸€ä¸ªç‰¹æ€§æ˜¯åœ¨å°†ç§å­æä¾›ç»™TypesAndSettings::HashFnä¹‹å‰è¿›è¡Œæœ€å°ç¨‹åº¦çš„â€œé¢„æ··åˆâ€ï¼Œä»¥é˜²è¯¥å‡½æ•°åœ¨ä»…æŒ‰é¡ºåºè¿­ä»£ç§å­æ—¶æ— æ³•æä¾›è¶³å¤Ÿç‹¬ç«‹çš„å“ˆå¸Œå€¼ã€‚ ï¼ˆä¾‹å¦‚ï¼Œè¿™å¯ä»¥è§£å†³RocksDBä¸­ä½¿ç”¨çš„XXH3é¢„è§ˆç‰ˆæœ¬0.7.2å­˜åœ¨çš„é—®é¢˜ï¼Œå³XXPH3æˆ–Hash64ï¼Œä»¥åŠRocksDBä¸­ä½¿ç”¨çš„MurmurHash1ï¼Œå³Hashï¼‰ã€‚æˆ‘ä»¬ç§°è¿™ä¸ªé¢„æ··åˆæ­¥éª¤å°†â€œåºæ•°ç§å­â€ï¼ˆæˆ‘ä»¬æŒ‰é¡ºåºè¿­ä»£ä»¥æ‰¾åˆ°è§£å†³æ–¹æ¡ˆçš„ç§å­ï¼‰è½¬æ¢ä¸ºâ€œåŸå§‹ç§å­â€ï¼Œåœ¨æ¯æ¬¡è¿­ä»£ä¸­æœ‰æ›´å¤šçš„ä½å‘ç”Ÿå˜åŒ–ã€‚è¿™ç§è½¬æ¢æ˜¯ä¸€ç§æ˜“äºé€†è½¬çš„è½»é‡çº§æ··åˆï¼Œä¸é€‚åˆå•ç‹¬è¿›è¡Œå“ˆå¸Œã€‚è¿™ç§æ–¹æ³•çš„ä¼˜åŠ¿åœ¨äºStandardHasherå¯ä»¥ä»…å­˜å‚¨åŸå§‹ç§å­ï¼ˆä¾‹å¦‚64ä½ï¼‰ï¼Œä»¥å®ç°å¿«é€ŸæŸ¥è¯¢æ—¶é—´ï¼Œè€Œä»åº”ç”¨ç¨‹åºçš„è§’åº¦æ¥çœ‹ï¼Œæˆ‘ä»¬å¯ä»¥é™åˆ¶ä¿å­˜åœ¨å…ƒæ•°æ®ä¸­çš„åºæ•°é”®æ•°é‡ï¼ˆä¾‹å¦‚6ä½ä¸­çš„64ä¸ªï¼‰ã€‚

é»˜è®¤æ„é€ å‡½æ•°å°†ç§å­åˆå§‹åŒ–ä¸ºåºæ•°ç§å­é›¶ï¼Œè¿™ä¸åŸå§‹ç§å­é›¶ç›¸ç­‰ã€‚
```

#### Banding

```
tandardBanding: a canonical implementation of BandingStorage and BacktrackStorage, with convenience API for banding (solving with on-the-fly Gaussian elimination) with and without backtracking.
 
StandardBandingï¼šæ˜¯BandingStorageå’ŒBacktrackStorageçš„ç»å…¸å®ç°ï¼Œæä¾›äº†å¸¦æœ‰å’Œä¸å¸¦æœ‰å›æº¯çš„å¸¦å®½ï¼ˆé€šè¿‡å³æ—¶é«˜æ–¯æ¶ˆå…ƒæ±‚è§£ï¼‰çš„ä¾¿åˆ©APIã€‚
```

é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œ BandingStorageå’ŒBacktrackStorageæ˜¯ä»€ä¹ˆï¼Ÿå›æº¯çš„ç›®çš„æ˜¯ä»€ä¹ˆï¼Ÿ

replied by chat gptï¼š

```
BandingStorageå’ŒBacktrackStorageæ˜¯ä¸ç®—æ³•å’Œæ•°æ®ç»“æ„ç›¸å…³çš„æ¦‚å¿µï¼Œé€šå¸¸åœ¨è§£å†³é—®é¢˜æ—¶ç”¨äºå­˜å‚¨å’Œå¤„ç†ä¸­é—´ç»“æœã€‚

BandingStorageï¼ˆå¸¦å®½å­˜å‚¨ï¼‰ï¼š

å®šä¹‰ï¼š ç”¨äºåœ¨è§£å†³é—®é¢˜æ—¶å­˜å‚¨å’Œå¤„ç†å¸¦å®½çš„æ•°æ®ç»“æ„ã€‚
ç”¨é€”ï¼š åœ¨æŸäº›ç®—æ³•ä¸­ï¼Œå¸¦å®½æ˜¯æŒ‡ä¸€ç»„å€¼æˆ–èŒƒå›´ï¼Œç”¨äºæè¿°é—®é¢˜çš„ç‰¹å®šæ–¹é¢ã€‚BandingStorageé€šå¸¸ç”¨äºå­˜å‚¨è¿™äº›å¸¦å®½ï¼Œå¹¶æä¾›ä¸€ç§æœ‰æ•ˆçš„æ–¹å¼è¿›è¡Œæ“ä½œå’ŒæŸ¥è¯¢ã€‚
BacktrackStorageï¼ˆå›æº¯å­˜å‚¨ï¼‰ï¼š

å®šä¹‰ï¼š ç”¨äºåœ¨è§£å†³é—®é¢˜æ—¶å­˜å‚¨å’Œå¤„ç†å›æº¯ä¿¡æ¯çš„æ•°æ®ç»“æ„ã€‚
ç”¨é€”ï¼š åœ¨é—®é¢˜è§£å†³è¿‡ç¨‹ä¸­ï¼Œæœ‰æ—¶éœ€è¦å›æº¯ï¼ˆå³è¿”å›ä¹‹å‰çš„çŠ¶æ€ï¼‰ä»¥å°è¯•ä¸åŒçš„è·¯å¾„æˆ–é€‰æ‹©ã€‚BacktrackStorageç”¨äºè®°å½•åœ¨è§£å†³é—®é¢˜æ—¶æ‰€åšçš„é€‰æ‹©ï¼Œä»¥ä¾¿åœ¨éœ€è¦æ—¶èƒ½å¤Ÿå›é€€åˆ°ä¹‹å‰çš„çŠ¶æ€ï¼Œé‡æ–°æ¢ç´¢å…¶ä»–å¯èƒ½çš„è§£å†³æ–¹æ¡ˆã€‚
è¿™äº›æ¦‚å¿µé€šå¸¸ä¸ç‰¹å®šçš„ç®—æ³•æˆ–é—®é¢˜é¢†åŸŸç›¸å…³è”ï¼Œå› æ­¤å…·ä½“çš„å®ç°å’Œç”¨é€”å¯èƒ½ä¼šæ ¹æ®ä¸Šä¸‹æ–‡è€Œå¼‚ã€‚åœ¨ä½ æä¾›çš„æ–‡æœ¬ä¸­ï¼Œè¿™äº›æ¦‚å¿µå¯èƒ½æ˜¯ç”¨äºæŸç§è§£å†³æ–¹æ¡ˆçš„å…³é”®ç»„ä»¶ï¼Œæ¶‰åŠåˆ°å¸¦å®½å’Œå›æº¯çš„å­˜å‚¨å’Œå¤„ç†ã€‚
```



#### InMemSimpleSolution

```
 Implements concept SimpleSolutionStorage, mostly for demonstration
 purposes. This is "in memory" only because it does not handle byte
 ordering issues for serialization.
 
 
å®ç°SimpleSolutionStorageæ¦‚å¿µï¼Œä¸»è¦ç”¨äºæ¼”ç¤ºç›®çš„ã€‚è¿™ä»…ä»…æ˜¯â€œå†…å­˜ä¸­â€çš„ï¼Œå› ä¸ºå®ƒä¸å¤„ç†åºåˆ—åŒ–çš„å­—èŠ‚é¡ºåºé—®é¢˜ã€‚
```

é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼ŒSimpleSolutionStorageæ˜¯ä»€ä¹ˆï¼Ÿè¿™ä¸ªchat gptä¹Ÿä¸æ‡‚ï¼Œå¼€å§‹åˆ†æäº†ä¸€æ³¢

```
SimpleSolutionStorage æ˜¯ä¸€ä¸ªæ¦‚å¿µæˆ–è€…æ¥å£ï¼Œç”¨äºè¡¨ç¤ºä¸€ç§å­˜å‚¨è§£å†³æ–¹æ¡ˆçš„ç®€å•å®ç°ã€‚æ ¹æ®æä¾›çš„ä¸Šä¸‹æ–‡ï¼Œå®ƒå¯èƒ½æ˜¯ç”¨äºå­˜å‚¨é—®é¢˜è§£å†³æ–¹æ¡ˆçš„æ•°æ®ç»“æ„æˆ–æ¥å£çš„ä¸€éƒ¨åˆ†ã€‚

ä»¥ä¸‹æ˜¯å¯¹æ–‡æœ¬ä¸­æåˆ°çš„ SimpleSolutionStorage çš„ç¿»è¯‘ï¼š

å®ç°äº† SimpleSolutionStorage æ¦‚å¿µï¼Œä¸»è¦ç”¨äºæ¼”ç¤ºç›®çš„ã€‚è¿™ä»…ä»…æ˜¯â€œå†…å­˜ä¸­â€çš„ï¼Œå› ä¸ºå®ƒä¸å¤„ç†åºåˆ—åŒ–çš„å­—èŠ‚é¡ºåºé—®é¢˜ã€‚

è¿™æ®µæ–‡å­—è¡¨æ˜ SimpleSolutionStorage ä½œä¸ºä¸€ä¸ªæ¦‚å¿µè¢«å®ç°ï¼Œä¸»è¦ç”¨äºæ¼”ç¤ºã€‚å®ƒè¢«æè¿°ä¸ºä¸€ç§åœ¨å†…å­˜ä¸­å­˜å‚¨è§£å†³æ–¹æ¡ˆçš„ç®€å•å®ç°ï¼Œå¹¶ä¸”ç”±äºä¸æ¶‰åŠå¤„ç†åºåˆ—åŒ–çš„å­—èŠ‚é¡ºåºé—®é¢˜ï¼Œå®ƒè¢«é™å®šä¸ºâ€œå†…å­˜ä¸­â€ä½¿ç”¨ï¼Œå³åœ¨å†…å­˜ä¸­æ“ä½œè€Œä¸æ¶‰åŠå¤–éƒ¨å­˜å‚¨æˆ–ç½‘ç»œä¼ è¾“ã€‚

åœ¨å…·ä½“çš„ä¸Šä¸‹æ–‡ä¸­ï¼ŒSimpleSolutionStorage çš„å®ç°å¯èƒ½åŒ…æ‹¬å­˜å‚¨è§£å†³æ–¹æ¡ˆçš„æ•°æ®ç»“æ„ï¼Œä»¥åŠç”¨äºæŸ¥è¯¢ã€æ›´æ–°æˆ–å¤„ç†è§£å†³æ–¹æ¡ˆçš„ç›¸å…³æ–¹æ³•ã€‚
```



#### SerializableInterleavedSolution

```
 Implements concept InterleavedSolutionStorage always using little-endian
 byte order, so easy for serialization/deserialization. This implementation
 fully supports fractional bits per key, where any number of segments
 (number of bytes multiple of sizeof(CoeffRow)) can be used with any number
 of slots that is a multiple of kCoeffBits.

 The structure is passed an externally allocated/de-allocated byte buffer
 that is optionally pre-populated (from storage) for answering queries,
 or can be populated by BackSubstFrom.
 
å®ç°InterleavedSolutionStorageæ¦‚å¿µï¼Œå§‹ç»ˆä½¿ç”¨å°ç«¯å­—èŠ‚é¡ºåºï¼Œå› æ­¤ä¾¿äºåºåˆ—åŒ–å’Œååºåˆ—åŒ–ã€‚è¿™ä¸ªå®ç°å®Œå…¨æ”¯æŒæ¯ä¸ªé”®çš„åˆ†æ•°ä½ï¼Œå…¶ä¸­å¯ä»¥ä½¿ç”¨ä»»æ„æ•°é‡çš„æ®µï¼ˆå­—èŠ‚æ•°æ˜¯CoeffRowçš„sizeofå€æ•°ï¼‰ä»¥åŠä»»æ„æ•°é‡çš„æ’æ§½ï¼ˆæ˜¯kCoeffBitsçš„å€æ•°ï¼‰ã€‚

è¯¥ç»“æ„æ¥æ”¶ä¸€ä¸ªå¤–éƒ¨åˆ†é…/é‡Šæ”¾çš„å­—èŠ‚ç¼“å†²åŒºï¼Œå¯é€‰æ‹©åœ°é¢„å…ˆå¡«å……ï¼ˆä»å­˜å‚¨ä¸­ï¼‰ä»¥å›ç­”æŸ¥è¯¢ï¼Œæˆ–è€…å¯ä»¥ç”±BackSubstFromå¡«å……ã€‚
```

é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼ŒInterleavedSolutionStorageæ˜¯ä»€ä¹ˆï¼Ÿ

æ ¹æ®åˆ†æï¼Œinterleavedæ˜¯ä¸€ç§é«˜æ•ˆçš„å­˜å‚¨æ ¼å¼ï¼Œç±»ä¼¼åˆ—å¼å­˜å‚¨ã€‚

ä¸Šé¢æå‡ºçš„é—®é¢˜åŸºæœ¬å¯ä»¥åœ¨algæ–‡ä»¶çš„æ³¨é‡Šä¸­æ‰¾åˆ°ç­”æ¡ˆï¼Œä¸‹é¢ä¼šå¯¹algæ–‡ä»¶è¿›è¡Œåˆ†æã€‚

#### ribbon_alg.h

æ ¸å¿ƒç®—æ³•çš„é€šç”¨ç‰ˆæœ¬ï¼Œèšç„¦æ ¸å¿ƒç»†èŠ‚

```
ribbonæ˜¯ä¸€ä¸ªå®Œç¾çš„é™æ€hashæ–¹æ³•ï¼Œç»“åˆä¸€ä¸‹ä¼˜ç‚¹
1ã€å¸ƒå°”çº¿æ€§ç³»ç»Ÿ
2ã€å¢é‡ï¼Œå³æ—¶çš„é«˜æ–¯æ¶ˆå…ƒæ³•
3ã€é«˜æ•ˆçš„å­˜å‚¨æ–¹å¼
```



#### ribbon_impl.h



#### PHSF

å¦‚æœæˆ‘æ²¡çŒœé”™çš„è¯ï¼Œåº”è¯¥æ˜¯`A Perfect Hash Static Function`çš„ç¼©å†™ï¼Œä½œç”¨æ˜¯

`A Perfect Hash Static Function is a data structure representing a map from anything hashable (a "key") to values of some fixed size.`

æ›´é‡è¦çš„æ˜¯ï¼š

`Crucially, it is allowed to return garbage values for anything not in the original set of map keys`

è€Œä¸”æ„å»ºå¥½ä¹‹åï¼Œå®ƒçš„entrieså°±ä¸èƒ½å†å¢åŠ æˆ–è€…åˆ é™¤äº†



#### entry

çŒœæµ‹entryå°±æ˜¯æ„å»ºè¿‡æ»¤å™¨ç”¨çš„row



#### MWHC

åˆç§°ä¸ºXor Filter



#### Ribbon PHSF Construction

```
    C    *    S    =    R
 (n x m)   (m x b)   (n x b)
 where C = coefficients, S = solution, R = results
 and solving for S given C and R.
 
 è¿™ä¸ªmä¹Ÿå«soltæ•°
```

æ ¹æ®æ³¨é‡Šï¼Œnè¶Šå¤§ï¼Œåˆ™æœ‰è§£çš„å¯èƒ½æ€§è¶Šå°ã€‚è§£å°±æ˜¯æŒ‡SçŸ©é˜µã€‚

```
// æ˜ å°„å…³ç³»
GetStart() å¯¹åº”è®ºæ–‡ä¸­çš„s(x)
kCoeffBitsä¹Ÿç§°ä¸ºr å¯¹åº”è®ºæ–‡ä¸­çš„wå®½åº¦ï¼Œæ˜¯ä¸€ä¸ªå›ºå®šå®½åº¦
GetCoeffRow() å¯¹åº”è®ºæ–‡ä¸­æ˜ å°„ä¸ºwå®½åº¦çš„hashå‡½æ•°c(x)ï¼Œä¸€èˆ¬æ˜¯ä»¥1å¼€å¤´çš„

m/næˆ–rè¶Šå¤§ï¼Œæœ‰è§£çš„å¯èƒ½æ€§è¶Šå¤§
```

rocksdbæä¾›çš„æ•°æ®ï¼šå½“keyså¤„äº10ï½100kæ—¶ï¼Œré€‰æ‹©128æœ‰å¾ˆé«˜çš„æ€§ä»·æ¯”ã€‚



#### Banding

bandingæ˜¯ä¸€ä¸ªè¿‡ç¨‹ï¼Œåº”è¯¥æ˜¯æŒ‡å°†ç³»æ•°çŸ©é˜µåŒ–ç®€ä¸ºè¡Œé˜¶æ¢¯çŸ©é˜µçš„è¿‡ç¨‹ï¼Œç”±äºè¡Œé˜¶æ¢¯çŸ©é˜µç”±å®½åº¦ä¸ºrçš„bandç»„æˆï¼Œå› æ­¤ä¹Ÿå«â€œæ¡å¸¦åŒ–â€



#### "incremental" and "on-the-fly"

bandingç®—æ³•å°±å¦‚åŒè®ºæ–‡ä¸­ä¼ªä»£ç å±•ç¤ºçš„ä¸€æ ·ã€‚

å› ä¸ºå¯ä»¥ä¸æ–­æ·»åŠ ï¼Œç®—æ³•æ‹¥æœ‰â€œå¢é‡â€ç‰¹ç‚¹ã€‚

ç”±äºåœ¨å¤„ç†æ¯ä¸ªè¾“å…¥åï¼Œæˆ‘ä»¬åœ¨å¤„ç†åˆ°ç›®å‰ä¸ºæ­¢çš„æ‰€æœ‰è¾“å…¥æ—¶â€œå®Œæˆâ€äº†ï¼Œç®—æ³•æ‹¥æœ‰â€œåŠæ—¶â€çš„ç‰¹ç‚¹ã€‚

è¿™å°±æ˜¯"incremental" and "on-the-fly"å«ä¹‰ã€‚

```
 We call our banding algorithm "incremental" and "on-the-fly" because
 (like hash table insertion) we are "finished" after each input
 processed, with respect to all inputs processed so far. Although the
 band matrix is an intermediate step to the solution structure, we have
 eliminated intermediate steps and unnecessary data tracking for
 banding.
 
 æˆ‘ä»¬å°†æˆ‘ä»¬çš„å¸¦çŠ¶ç®—æ³•ç§°ä¸ºâ€œå¢é‡â€å’Œâ€œå³æ—¶â€çš„ï¼Œå› ä¸ºï¼ˆå°±åƒå“ˆå¸Œè¡¨æ’å…¥ä¸€æ ·ï¼‰åœ¨å¤„ç†æ¯ä¸ªè¾“å…¥åï¼Œæˆ‘ä»¬åœ¨å¤„ç†åˆ°ç›®å‰ä¸ºæ­¢çš„æ‰€æœ‰è¾“å…¥æ—¶â€œå®Œæˆâ€äº†ã€‚å°½ç®¡å¸¦çŠ¶çŸ©é˜µæ˜¯è§£ç»“æ„çš„ä¸€ä¸ªä¸­é—´æ­¥éª¤ï¼Œä½†æˆ‘ä»¬å·²ç»æ¶ˆé™¤äº†å¸¦çŠ¶çš„ä¸­é—´æ­¥éª¤å’Œä¸å¿…è¦çš„æ•°æ®è·Ÿè¸ªã€‚
```

ç”±äºè¿™ä¸ªç®—æ³•ä¸ä¼šè¦†ç›–åŸæœ‰çš„è¡Œï¼Œè€Œæ˜¯å¯¹æ–°çš„è¡Œèµ‹å€¼ï¼Œæ‰€ä»¥æ‹¥æœ‰å¯å›æº¯æ€§ï¼ˆbacktrackableï¼‰ã€‚

æ¥è‡ªæ³¨é‡Šçš„æ•°æ®ï¼šå½“CçŸ©é˜µçš„å¡«å……åº¦åˆ°è¾¾90%ï½95%ä¹‹åï¼Œè§£å†³å†²çªä¼šå æ®ä¸»è¦çš„æ„å»ºæ—¶é—´ï¼Œäºæ˜¯è€ƒè™‘ä½¿ç”¨æ›´é«˜çš„m/næ¯”ç‡ã€‚rocksdbå»ºè®®m/nçš„æ¯”ä¾‹åœ¨1.2æ¯”è¾ƒåˆé€‚ï¼Œå› ä¸ºBloomè¿‡æ»¤å™¨æ˜¯1.5ï¼Œè¿™ä¸ªæ¯”ä¾‹æ¯”bloomè¦ä½ï¼Œå¹¶ä¸”é€Ÿåº¦ä¹Ÿä¼šæå‡ã€‚

```
Back-substitution from an upper-triangular boolean band matrix is
 especially fast and easy. All the memory accesses are sequential or at
 least local, no random. If the number of result bits (b) is a
 compile-time constant, the back-substitution state can even be tracked
 in CPU registers. Regardless of the solution representation, we prefer
 column-major representation for tracking back-substitution state, as
 r (the band width) will typically be much larger than b (result bits
 or columns), so better to handle r-bit values b times (per solution
 row) than b-bit values r times.
 
ä»ä¸€ä¸ªä¸Šä¸‰è§’çš„å¸ƒå°”å¸¦çŠ¶çŸ©é˜µè¿›è¡Œå›ä»£æ³•æ˜¯ç‰¹åˆ«å¿«é€Ÿä¸”å®¹æ˜“çš„ã€‚æ‰€æœ‰å†…å­˜è®¿é—®éƒ½æ˜¯é¡ºåºçš„æˆ–è‡³å°‘æ˜¯å±€éƒ¨çš„ï¼Œæ²¡æœ‰éšæœºè®¿é—®ã€‚å¦‚æœç»“æœä½æ•°ï¼ˆbï¼‰æ˜¯ä¸€ä¸ªç¼–è¯‘æ—¶å¸¸é‡ï¼Œå›ä»£æ³•çš„çŠ¶æ€ç”šè‡³å¯ä»¥åœ¨CPUå¯„å­˜å™¨ä¸­è·Ÿè¸ªã€‚æ— è®ºè§£çš„è¡¨ç¤ºæ–¹å¼å¦‚ä½•ï¼Œæˆ‘ä»¬æ›´å–œæ¬¢ä½¿ç”¨åˆ—ä¼˜å…ˆçš„è¡¨ç¤ºæ–¹å¼æ¥è·Ÿè¸ªå›ä»£æ³•çš„çŠ¶æ€ï¼Œå› ä¸º rï¼ˆå¸¦å®½ï¼‰é€šå¸¸ä¼šæ¯” bï¼ˆç»“æœä½æˆ–åˆ—ï¼‰å¤§å¾—å¤šï¼Œå› æ­¤æœ€å¥½å¤„ç† r ä½å€¼ b æ¬¡ï¼ˆæ¯ä¸ªè§£çš„è¡Œï¼‰è€Œä¸æ˜¯ b ä½å€¼ r æ¬¡ã€‚

æ€»ç»“ï¼šè¿™é‡Œçš„ræ˜¯æŒ‡è®ºæ–‡ä¸­çš„wï¼Œä»–æ¯”è®ºæ–‡ä¸­çš„b(x)ä¸€èˆ¬è¦å¤§çš„å¤šï¼Œæ‰€ä»¥ä¸€èˆ¬é‡‡ç”¨åˆ—å¼å­˜å‚¨ã€‚
```



#### scalability

ribbonçš„å¯æ‰©å±•æ€§è¡¨ç°åœ¨rã€nã€mçš„å€¼æ”¯æŒè‡ªå®šä¹‰ï¼Œç†è®ºä¸Šå¯ä»¥æ˜¯ä»»æ„å€¼ã€‚

#### slot

ä¹Ÿå°±æ˜¯ç³»æ•°çŸ©é˜µï¼ˆn*mï¼‰çš„mï¼Œå¯¹åº”è®ºæ–‡é‡Œé¢çš„mï¼ˆè®ºæ–‡é‡Œç»™çš„å›¾n=mï¼‰



#### ribbonæ ¸å¿ƒç®—æ³•

```
 +-----------+     +---+     +-----------------+
 | AddInputs | --> | H | --> | BandingStorage  |
 +-----------+     | a |     +-----------------+
                   | s |             |
                   | h |      Back substitution
                   | e |             V
 +-----------+     | r |     +-----------------+
 | Query Key | --> |   | >+< | SolutionStorage |
 +-----------+     +---+  |  +-----------------+
                          V
                     Query result
                     
                     
è²Œä¼¼Back substitutionå°±æ˜¯è§£å‡ºSolutionçš„è§£æ³•ï¼Œè¿™ä¸ªè§£æ³•å’ŒSolutionStorageå¼ºç›¸å…³
```

##### RibbonTypesæ¦‚å¿µ

CoeffRowï¼šä¸€ä¸ªr-bitçš„ç³»æ•°å‘é‡ ,è‡³äºrï¼š

```
r (or kCoeffBits) is taken to be sizeof(CoeffRow) * 8
```

ResultRowï¼š

```
An unsigned integer type big enough to hold a result row (b bits, or number of solution/result columns).
```

Indexï¼šæ— ç¬¦å·æ•´æ•°ï¼Œè¡¨ç¤ºsolutionçŸ©é˜µä¸­çš„è¡Œå·

```
An unsigned integer type sufficient for representing the number of rows in the solution structure,
```



##### PhsfQueryHasher extend RibbonTypesæ¦‚å¿µ

Keyï¼š

```
Type for a lookup key, which is hashable.
```

Hashï¼š

```
Type for hashed summary of a Key. uint64_t is recommended.
```

å‡½æ•°GetHash(const Key &)ï¼š

```
Compute a hash value summarizing a Key
```

å‡½æ•°GetStart(Hash, Index num_starts):

```
ç»™ä¸€ä¸ªhashå€¼å’Œä¸€ä¸ªå¯ä»¥å¼€å§‹r-bitçš„ä½ç½®ï¼ˆm-r + 1ï¼‰ï¼Œè¿”å›è¿™ä¸ªHashåº”è¯¥å¼€å§‹çš„ä½ç½®ï¼Œä¹Ÿå°±æ˜¯è®ºæ–‡ä¸­çš„s()

GetNumStart() æ˜¯ç»™å‡ºstartçš„è¾¹ç•Œï¼Œå› ä¸ºstart å±äº [0, num_start]çš„èŒƒå›´
è€Œnum_startå°±æ˜¯è®ºæ–‡ä¸­çš„ m-w+1ï¼Œä¹Ÿå°±æ˜¯ä»£ç ä¸­çš„m - r + 1
```

å‡½æ•°GetCoeffRow(Hash):ç»™å®šä¸€ä¸ªå“ˆå¸Œå€¼ï¼Œè¿”å›ä¸ä¹‹å…³è”çš„ r ä½ç³»æ•°åºåˆ—,ä¸€èˆ¬è¿™ä¸ªåºåˆ—è¦å¤§äºæä¾›çš„Hashå€¼

```
Given a hash value, return the r-bit sequence of coefficients to
    associate with it. It's generally OK if
      sizeof(CoeffRow) > sizeof(Hash)
    as long as the hash itself is not too prone to collisions for the
    applications and the CoeffRow is generated uniformly from
    available hash data, but relatively independent of the start.

    Must be non-zero, because that's required for a solution to exist
    when mapping to non-zero result row. (Note: BandingAdd could be
    modified to allow 0 coeff row if that only occurs with 0 result
    row, which really only makes sense for filter implementation,
    where both values are hash-derived. Or BandingAdd could reject 0
    coeff row, forcing next seed, but that has potential problems with
    generality/scalability.)
    
    
ç»™å®šä¸€ä¸ªå“ˆå¸Œå€¼ï¼Œè¿”å›ä¸ä¹‹å…³è”çš„ r ä½ç³»æ•°åºåˆ—ã€‚é€šå¸¸ï¼Œå¦‚æœ sizeof(CoeffRow) > sizeof(Hash)ï¼Œåªè¦å“ˆå¸Œæœ¬èº«ä¸å¤ªå®¹æ˜“å‘ç”Ÿå†²çªå¯¹äºåº”ç”¨ç¨‹åºï¼Œå¹¶ä¸” CoeffRow æ˜¯ä»å¯ç”¨çš„å“ˆå¸Œæ•°æ®å‡åŒ€ç”Ÿæˆçš„ï¼Œè€Œç›¸å¯¹ç‹¬ç«‹äºèµ·å§‹ä½ç½®ï¼Œé‚£å°±æ²¡é—®é¢˜ã€‚å¿…é¡»æ˜¯éé›¶çš„ï¼Œå› ä¸ºè¿™å¯¹äºæ˜ å°„åˆ°éé›¶ç»“æœè¡Œæ—¶éœ€è¦å­˜åœ¨è§£ã€‚ï¼ˆæ³¨æ„ï¼šBandingAdd å¯èƒ½ä¼šè¢«ä¿®æ”¹ä»¥å…è®¸ 0 ç³»æ•°è¡Œï¼Œå¦‚æœåªæœ‰åœ¨ 0 ç»“æœè¡Œçš„æƒ…å†µä¸‹å‘ç”Ÿï¼Œè¿™å¯¹äºè¿‡æ»¤å™¨å®ç°æ‰æœ‰æ„ä¹‰ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªå€¼éƒ½æ˜¯å“ˆå¸Œæ´¾ç”Ÿçš„ã€‚æˆ–è€… BandingAdd å¯ä»¥æ‹’ç» 0 ç³»æ•°è¡Œï¼Œå¼ºåˆ¶ä½¿ç”¨ä¸‹ä¸€ä¸ªç§å­ï¼Œä½†è¿™å¯èƒ½å­˜åœ¨é€šç”¨æ€§/å¯æ‰©å±•æ€§çš„æ½œåœ¨é—®é¢˜ã€‚ï¼‰
```

##### FilterQueryHasher extends PhsfQueryHasheræ¦‚å¿µ

å‡½æ•°GetResultRowFromHash(Hash)ï¼šåº”è¯¥æ˜¯æŸ¥è¯¢æ—¶å€™ç”¨çš„ï¼Œé€šè¿‡Hashå¾—åˆ°ç»“æœè¡Œ

##### BandingHasher extends FilterQueryHasheræ¦‚å¿µ

AddInputï¼šç›®å‰ä¸å¤ªç†è§£

```
For a filter, this will generally be the same as Key.
For a general PHSF, it must either
(a) include a key and a result it maps to (e.g. in a std::pair), or
(b) GetResultRowFromInput looks up the result somewhere rather than
extracting it.

å¯¹è¿‡æ»¤å™¨è€Œè¨€ï¼Œä¸€èˆ¬ä»–å’Œkeyæ˜¯ä¸€ä¸ªæ„æ€
å¯¹äºä¸€èˆ¬çš„PHSFï¼Œ
è¦ä¹ˆ 1ã€åŒ…å«keyå’Œä»–å¯¹åº”çš„result
è¦ä¹ˆ 2ã€GetResultRowFromInputä»æŸåœ°æ‰¾åˆ°resultï¼Œè€Œä¸æ˜¯æå–ä»–
```

å‡½æ•°GetHash(const AddInput &)ï¼š

ä¸æ˜¯æå–ä»AddInputæå–Keyï¼Œè€Œæ˜¯è·å–AddInputçš„ä¸€éƒ¨åˆ†ï¼ˆè¿™ä¸€éƒ¨åˆ†æ˜¯Keyï¼‰çš„Hashã€‚å¦‚æœAddInputå’ŒKeyç›¸åŒï¼Œé‚£ä»€ä¹ˆç‰¹åˆ«è¦æ³¨æ„çš„äº†ã€‚

å‡½æ•°ResultRow GetResultRowFromInput(const AddInput &)ï¼š

```
å¯¹äºéfilterçš„PHSFï¼Œå®ƒæå–æˆ–æŸ¥æ‰¾ä¸è¾“å…¥ç›¸å…³çš„ç»“æœè¡Œ
å¯¹äºFilterçš„PHSFï¼Œå®ƒè¿”å›0
```

kFirstCoeffAlwaysOneï¼š

```
Whether the solver can assume the lowest bit of GetCoeffRow is always 1. When true, it should improve solver efficiency slightly.

æ±‚è§£å™¨æ˜¯å¦å¯ä»¥å‡å®š GetCoeffRow çš„æœ€ä½ä½å§‹ç»ˆä¸º1ã€‚å½“ä¸ºtrueæ—¶ï¼Œè¿™åº”è¯¥ä¼šç•¥å¾®æé«˜æ±‚è§£å™¨çš„æ•ˆç‡ã€‚
```

##### BandingStorage extends RibbonTypesæ¦‚å¿µ

bool UsePrefetch() constï¼š

```
Tells the banding algorithm to prefetch memory associated with
    the next input before processing the current input. Generally
    recommended iff the BandingStorage doesn't easily fit in CPU
    cache.

å‘Šè¯‰å¸¦çŠ¶ç®—æ³•åœ¨å¤„ç†å½“å‰è¾“å…¥ä¹‹å‰é¢„å–ä¸ä¸‹ä¸€ä¸ªè¾“å…¥ç›¸å…³è”çš„å†…å­˜ã€‚é€šå¸¸å»ºè®®åœ¨å¸¦çŠ¶å­˜å‚¨ä¸å®¹æ˜“é€‚åº” CPU ç¼“å­˜çš„æƒ…å†µä¸‹ä½¿ç”¨ã€‚
```

void Prefetch(Index i) constï¼š

```
Prefetches (e.g. __builtin_prefetch) memory associated with a slot index i.

é¢„å–ï¼ˆä¾‹å¦‚ä½¿ç”¨ __builtin_prefetchï¼‰ä¸æ§½ç´¢å¼• i ç›¸å…³è”çš„å†…å­˜ã€‚
```

void LoadRow(Index i, CoeffRow *cr, ResultRow *rr, bool for_back_subst) constï¼š
void StoreRow(Index i, CoeffRow cr, ResultRow rr)ï¼š

```
Load or store CoeffRow and ResultRow for slot index i.
    (Gaussian row operations involve both sides of the equation.)
    Bool `for_back_subst` indicates that customizing values for
    unconstrained solution rows (cr == 0) is allowed.

åŠ è½½æˆ–å­˜å‚¨ä¸æ§½ç´¢å¼• i ç›¸å…³çš„ CoeffRow å’Œ ResultRowã€‚ï¼ˆé«˜æ–¯è¡Œæ“ä½œæ¶‰åŠæ–¹ç¨‹çš„ä¸¤ä¾§ã€‚ï¼‰å¸ƒå°”å€¼ for_back_subst è¡¨ç¤ºå…è®¸ä¸ºæ— çº¦æŸè§£è¡Œï¼ˆcr == 0ï¼‰è‡ªå®šä¹‰å€¼ã€‚
```

Index GetNumStarts() constï¼š

```
Returns the number of columns that can start an r-sequence of
    coefficients, which is the number of slots minus r (kCoeffBits)
    plus one. (m - r + 1)

è¿”å›å¯ä»¥å¼€å§‹ä¸€ä¸ª r-ç³»æ•°åºåˆ—çš„åˆ—æ•°ï¼Œå³æ§½çš„æ•°é‡å‡å» rï¼ˆkCoeffBitsï¼‰å†åŠ ä¸€ã€‚ï¼ˆm - r + 1ï¼‰
```



##### BacktrackStorage extends RibbonTypes

bool UseBacktrack() constï¼š

```
If false, backtracking support will be disabled in the algorithm.
    This should preferably be an inline compile-time constant function.
    
   
å¦‚æœä¸º falseï¼Œåˆ™ç®—æ³•ä¸­å°†ç¦ç”¨å›æº¯æ”¯æŒã€‚æœ€å¥½å°†å…¶è®¾ç½®ä¸ºå†…è”çš„ç¼–è¯‘æ—¶å¸¸é‡å‡½æ•°ã€‚
```

void BacktrackPut(Index i, Index to_save)ï¼š

```
Records `to_save` as the `i`th backtrack entry

è®°å½• to_save ä½œä¸ºç¬¬ i ä¸ªå›æº¯æ¡ç›®ã€‚
```

Index BacktrackGet(Index i) constï¼š

```
Recalls the `i`th backtrack entry

å›æº¯åˆ°ç¬¬ i ä¸ªå›æº¯æ¡ç›®ã€‚
```



##### çŸ©é˜µè¿ç®—

bool BandingAddRangeï¼ˆ5ä¸ªå‚æ•°ï¼‰ï¼š*å…³é”®*

æ ¸å¿ƒç®—æ³•ï¼Œä¸‹é¢çš„ä¸¤ä¸ªADDæ–¹æ³•æœ€ç»ˆéƒ½æ˜¯è°ƒç”¨äº†è¿™ä¸ª5ä¸ªå‚æ•°çš„æ–¹æ³•

```
 Adds a range of entries to BandingStorage returning true if successful
 or false if solution is impossible with current hasher (and presumably
 its seed) and number of "slots" (solution or banding rows). (A solution
 is impossible when there is a linear dependence among the inputs that
 doesn't "cancel out".) Here "InputIterator" is an iterator over AddInputs.

 If UseBacktrack in the BacktrackStorage, this function call rolls back
 to prior state on failure. If !UseBacktrack, some subset of the entries
 will have been added to the BandingStorage, so best considered to be in
 an indeterminate state.
 
 
å‘BandingStorageæ·»åŠ ä¸€ä¸ªæ¡ç›®èŒƒå›´ï¼Œå¦‚æœæˆåŠŸåˆ™è¿”å›trueï¼Œå¦‚æœä½¿ç”¨å½“å‰çš„å“ˆå¸Œå‡½æ•°ï¼ˆä»¥åŠå…¶å¯èƒ½çš„ç§å­ï¼‰å’Œâ€œæ§½ä½â€ï¼ˆè§£æˆ–å¸¦çŠ¶è¡Œï¼‰æ— æ³•æ‰¾åˆ°è§£åˆ™è¿”å›falseï¼ˆå½“è¾“å…¥ä¹‹é—´å­˜åœ¨çº¿æ€§ç›¸å…³æ€§ä¸”æ— æ³•â€œå–æ¶ˆæ‰â€æ—¶ï¼Œè§£å°±æ— æ³•æ‰¾åˆ°ï¼‰ã€‚è¿™é‡Œçš„â€œInputIteratorâ€æ˜¯ä¸€ä¸ªåœ¨AddInputsä¸Šçš„è¿­ä»£å™¨ã€‚

å¦‚æœBacktrackStorageä¸­çš„UseBacktrackä¸ºtrueï¼Œåœ¨å¤±è´¥æ—¶æ­¤å‡½æ•°è°ƒç”¨å°†å›æ»šåˆ°å…ˆå‰çš„çŠ¶æ€ã€‚å¦‚æœUseBacktrackä¸ºfalseï¼Œåˆ™BandingStorageä¸­å°†æ·»åŠ ä¸€äº›æ¡ç›®çš„å­é›†ï¼Œå› æ­¤æœ€å¥½å°†å…¶è§†ä¸ºä¸ç¡®å®šçŠ¶æ€ã€‚
```

bool BandingAddRange(BandingStorage *bs, const BandingHasher &bh, InputIterator begin, InputIterator end)ï¼š

```
 Adds a range of entries to BandingStorage returning true if successful
 or false if solution is impossible with current hasher (and presumably
 its seed) and number of "slots" (solution or banding rows). (A solution
 is impossible when there is a linear dependence among the inputs that
 doesn't "cancel out".) Here "InputIterator" is an iterator over AddInputs.

 On failure, some subset of the entries will have been added to the
 BandingStorage, so best considered to be in an indeterminate state.
 
 
å‘BandingStorageæ·»åŠ ä¸€ä¸ªæ¡ç›®èŒƒå›´ï¼Œå¦‚æœæˆåŠŸåˆ™è¿”å›trueï¼Œå¦‚æœä½¿ç”¨å½“å‰çš„å“ˆå¸Œå‡½æ•°ï¼ˆä»¥åŠå…¶å¯èƒ½çš„ç§å­ï¼‰å’Œâ€œæ§½ä½â€ï¼ˆè§£æˆ–å¸¦çŠ¶è¡Œï¼‰æ— æ³•æ‰¾åˆ°è§£åˆ™è¿”å›falseï¼ˆå½“è¾“å…¥ä¹‹é—´å­˜åœ¨çº¿æ€§ç›¸å…³æ€§ä¸”æ— æ³•â€œå–æ¶ˆæ‰â€æ—¶ï¼Œè§£å°±æ— æ³•æ‰¾åˆ°ï¼‰ã€‚è¿™é‡Œçš„â€œInputIteratorâ€æ˜¯ä¸€ä¸ªåœ¨AddInputsä¸Šçš„è¿­ä»£å™¨ã€‚

åœ¨å¤±è´¥æ—¶ï¼ŒBandingStorageä¸­å°†æ·»åŠ ä¸€äº›æ¡ç›®çš„å­é›†ï¼Œå› æ­¤æœ€å¥½å°†å…¶è§†ä¸ºä¸ç¡®å®šçŠ¶æ€ã€‚
```

bool BandingAdd()ï¼š

```
Adds a single entry to BandingStorage (and optionally, BacktrackStorage),
 returning true if successful or false if solution is impossible with
 current hasher (and presumably its seed) and number of "slots" (solution
 or banding rows). (A solution is impossible when there is a linear
 dependence among the inputs that doesn't "cancel out".)

 Pre- and post-condition: the BandingStorage represents a band matrix
 ready for back substitution (row echelon form except for zero rows),
 augmented with result values such that back substitution would give a
 solution satisfying all the cr@start -> rr entries added.



å‘BandingStorageï¼ˆå’Œå¯é€‰çš„BacktrackStorageï¼‰æ·»åŠ å•ä¸ªæ¡ç›®ï¼Œå¦‚æœæˆåŠŸåˆ™è¿”å›trueï¼Œå¦‚æœä½¿ç”¨å½“å‰çš„å“ˆå¸Œå‡½æ•°ï¼ˆä»¥åŠå…¶å¯èƒ½çš„ç§å­ï¼‰å’Œâ€œæ§½ä½â€ï¼ˆè§£æˆ–å¸¦çŠ¶è¡Œï¼‰æ— æ³•æ‰¾åˆ°è§£åˆ™è¿”å›falseï¼ˆå½“è¾“å…¥ä¹‹é—´å­˜åœ¨çº¿æ€§ç›¸å…³æ€§ä¸”æ— æ³•â€œå–æ¶ˆæ‰â€æ—¶ï¼Œè§£å°±æ— æ³•æ‰¾åˆ°ï¼‰ã€‚

å‰ç½®å’Œåç½®æ¡ä»¶ï¼šBandingStorageè¡¨ç¤ºä¸€ä¸ªå‡†å¤‡è¿›è¡Œå›ä»£æ›¿æ¢çš„å¸¦çŠ¶çŸ©é˜µï¼ˆè¡Œæ¢¯é˜µå½¢å¼ï¼Œé™¤äº†é›¶è¡Œï¼‰ï¼Œé€šè¿‡å¢åŠ æ»¡è¶³æ‰€æœ‰æ·»åŠ çš„ cr@start -> rr æ¡ç›®çš„è§£çš„ç»“æœå€¼æ‰©å……ã€‚
```



#### ä¸¤ç§å­˜å‚¨æ–¹å¼

å›å¸¦è®¡ç®—Solutionç”±Storageå†³å®šå’Œå®ç°

`Back-substitution and query algorithms unfortunately depend on some details of data layout in the final data structure ("solution"). Thus, there is no common SolutionStorage covering all the reasonable possibilities. å›ä»£æ›¿æ¢å’ŒæŸ¥è¯¢ç®—æ³•ä¸å¹¸åœ°ä¾èµ–äºæœ€ç»ˆæ•°æ®ç»“æ„ï¼ˆâ€œè§£â€ï¼‰ä¸­çš„ä¸€äº›ç»†èŠ‚ã€‚å› æ­¤ï¼Œæ²¡æœ‰ä¸€ä¸ªé€šç”¨çš„SolutionStorageæ¶µç›–æ‰€æœ‰åˆç†çš„å¯èƒ½æ€§ã€‚`

ä¹Ÿå°±æ˜¯è¯´å›å¸¦å’ŒæŸ¥è¯¢ç®—æ³•éƒ½éœ€è¦ä¾èµ–æ•°æ®çš„å­˜å‚¨ç»“æ„ï¼Œä¸‹é¢æ˜¯ä¸¤ç§æ•°æ®å­˜å‚¨æ–¹å¼

##### SimpleSolutionStorage extends RibbonTypes

```
SimpleSolutionStorage is for a row-major storage, typically with no
unused bits in each ResultRow. This is mostly for demonstration
purposes as the simplest solution storage scheme. It is relatively slow
for filter queries.

SimpleSolutionStorage ç”¨äºè¡Œä¸»å­˜å‚¨ï¼Œé€šå¸¸æ¯ä¸ª ResultRow ä¸­æ²¡æœ‰æœªä½¿ç”¨çš„ä½ã€‚è¿™ä¸»è¦æ˜¯ä¸ºäº†æ¼”ç¤ºç›®çš„ï¼Œä½œä¸ºæœ€ç®€å•çš„è§£å†³æ–¹æ¡ˆå­˜å‚¨æ–¹æ¡ˆã€‚å¯¹äºè¿‡æ»¤æŸ¥è¯¢è€Œè¨€ï¼Œå®ƒç›¸å¯¹è¾ƒæ…¢ã€‚
```

void PrepareForNumStarts(Index num_starts) constï¼š

```
This is called at the beginning of back-substitution for the
    solution storage to do any remaining configuration before data
    is stored to it. If configuration is previously finalized, this
    could be a simple assertion or even no-op. Ribbon algorithms
    only call this from back-substitution, and only once per call,
    before other functions here.

è¿™åœ¨å›ä»£è§£é¢˜çš„å¼€å§‹æ—¶è°ƒç”¨ï¼Œç”¨äºåœ¨æ•°æ®å­˜å‚¨åˆ°è§£å†³æ–¹æ¡ˆå­˜å‚¨ä¹‹å‰æ‰§è¡Œä»»ä½•å‰©ä½™çš„é…ç½®ã€‚å¦‚æœé…ç½®å·²ç»æœ€ç»ˆç¡®å®šï¼Œè¿™å¯èƒ½æ˜¯ä¸€ä¸ªç®€å•çš„æ–­è¨€ï¼Œç”šè‡³æ˜¯ç©ºæ“ä½œã€‚Ribbon ç®—æ³•åªåœ¨å›ä»£è§£é¢˜ä¸­è°ƒç”¨æ­¤å‡½æ•°ï¼Œæ¯æ¬¡è°ƒç”¨åªè°ƒç”¨ä¸€æ¬¡ï¼Œåœ¨è°ƒç”¨å…¶ä»–å‡½æ•°ä¹‹å‰ã€‚
```

Index GetNumStarts() constï¼š

```
Must return num_starts passed to PrepareForNumStarts, or the most
recent call to PrepareForNumStarts if this storage object can be
reused. Note that num_starts == num_slots - kCoeffBits + 1 because
there must be a run of kCoeffBits slots starting from each start.

å¿…é¡»è¿”å›ä¼ é€’ç»™ PrepareForNumStarts çš„ num_startsï¼Œæˆ–è€…å¦‚æœæ­¤å­˜å‚¨å¯¹è±¡å¯ä»¥è¢«é‡ç”¨ï¼Œåˆ™è¿”å›æœ€è¿‘ä¸€æ¬¡è°ƒç”¨ PrepareForNumStartsã€‚è¯·æ³¨æ„ï¼Œnum_starts == num_slots - kCoeffBits + 1ï¼Œå› ä¸ºå¿…é¡»æœ‰ä¸€ä¸ªä»æ¯ä¸ª start å¼€å§‹çš„ kCoeffBits æ§½çš„è¿è¡Œã€‚
```

ResultRow Load(Index slot_num) constï¼š

```
Load the solution row (type ResultRow) for a slot
```

void Store(Index slot_num, ResultRow data)ï¼š

```
Store the solution row (type ResultRow) for a slot
```



##### InterleavedSolutionStorage extends RibbonTypes

```
 InterleavedSolutionStorage is row-major at a high level, for good
 locality, and column-major at a low level, for CPU efficiency
 especially in filter queries or relatively small number of result bits
 (== solution columns). The storage is a sequence of "blocks" where a
 block has one CoeffRow-sized segment for each solution column. Each
 query spans at most two blocks; the starting solution row is typically
 in the row-logical middle of a block and spans to the middle of the
 next block. (See diagram below.)

 InterleavedSolutionStorage supports choosing b (number of result or
 solution columns) at run time, and even supports mixing b and b-1 solution
 columns in a single linear system solution, for filters that can
 effectively utilize any size space (multiple of CoeffRow) for minimizing
 FP rate for any number of added keys. To simplify query implementation
 (with lower-index columns first), the b-bit portion comes after the b-1
 portion of the structure.
 
InterleavedSolutionStorage åœ¨é«˜å±‚æ¬¡ä¸Šæ˜¯è¡Œä¸»åºçš„ï¼Œä»¥æé«˜å±€éƒ¨æ€§ï¼Œå¹¶ä¸”åœ¨ä½å±‚æ¬¡ä¸Šæ˜¯åˆ—ä¸»åºçš„ï¼Œç‰¹åˆ«æ˜¯åœ¨è¿‡æ»¤æŸ¥è¯¢æˆ–ç»“æœä½æ•°ç›¸å¯¹è¾ƒå°ï¼ˆ== è§£å†³æ–¹æ¡ˆåˆ—ï¼‰çš„æƒ…å†µä¸‹ï¼Œä»¥æé«˜ CPU æ•ˆç‡ã€‚å­˜å‚¨æ˜¯ä¸€ç³»åˆ— "å—"ï¼Œå…¶ä¸­ä¸€ä¸ªå—å¯¹åº”æ¯ä¸ªè§£å†³æ–¹æ¡ˆåˆ—ä¸€ä¸ª CoeffRow å¤§å°çš„æ®µã€‚æ¯ä¸ªæŸ¥è¯¢æœ€å¤šæ¶‰åŠä¸¤ä¸ªå—ï¼›èµ·å§‹è§£å†³æ–¹æ¡ˆè¡Œé€šå¸¸ä½äºå—çš„é€»è¾‘è¡Œä¸­é—´ï¼Œå¹¶è·¨è¶³åˆ°ä¸‹ä¸€ä¸ªå—çš„ä¸­é—´ä½ç½®ã€‚ï¼ˆè§ä¸‹é¢çš„ç¤ºæ„å›¾ã€‚ï¼‰

InterleavedSolutionStorage æ”¯æŒåœ¨è¿è¡Œæ—¶é€‰æ‹© bï¼ˆç»“æœæˆ–è§£å†³æ–¹æ¡ˆåˆ—çš„æ•°é‡ï¼‰ï¼Œç”šè‡³æ”¯æŒåœ¨å•ä¸ªçº¿æ€§ç³»ç»Ÿè§£å†³æ–¹æ¡ˆä¸­æ··åˆ b å’Œ b-1 è§£å†³æ–¹æ¡ˆåˆ—ï¼Œä»¥é€‚åº”å¯ä»¥æœ‰æ•ˆåˆ©ç”¨ä»»æ„å¤§å°ç©ºé—´ï¼ˆCoeffRow çš„å€æ•°ï¼‰ä»¥æœ€å°åŒ–ä»»æ„æ•°é‡çš„æ·»åŠ å…³é”®å­—çš„ FP ç‡çš„è¿‡æ»¤å™¨ã€‚ä¸ºäº†ç®€åŒ–æŸ¥è¯¢å®ç°ï¼ˆä»¥è¾ƒä½ç´¢å¼•çš„åˆ—ä¼˜å…ˆï¼‰ï¼Œb ä½çš„éƒ¨åˆ†ä½äºç»“æ„çš„ b-1 éƒ¨åˆ†ä¹‹åã€‚



ç¤ºæ„å›¾ï¼ˆ=== æ ‡è®°é€»è¾‘å—è¾¹ç•Œï¼›b=4ï¼›### æ˜¯ç”±è·¨è¶Š b-1 åˆ° b è¾¹ç•Œçš„æŸ¥è¯¢ä½¿ç”¨çš„æ•°æ®ï¼Œæ¯ä¸ª Segment å…·æœ‰ç±»å‹ CoeffRowï¼‰ï¼š
Diagram (=== marks logical block boundary; b=4; ### is data used by a
 query crossing the b-1 to b boundary, each Segment has type CoeffRow):
 +======================+
 | S e g m e n t  col=0 |
 +----------------------+
 | S e g m e n t  col=1 |
 +----------------------+
 | S e g m e n t  col=2 |
 +======================+
 | S e g m e n #########|
 +----------------------+
 | S e g m e n #########|
 +----------------------+
 | S e g m e n #########|
 +======================+ Result/solution columns: above = 3, below = 4
 |#############t  col=0 |
 +----------------------+
 |#############t  col=1 |
 +----------------------+
 |#############t  col=2 |
 +----------------------+
 | S e g m e n t  col=3 |
 +======================+
 | S e g m e n t  col=0 |
 +----------------------+
 | S e g m e n t  col=1 |
 +----------------------+
 | S e g m e n t  col=2 |
 +----------------------+
 | S e g m e n t  col=3 |
 +======================+

 InterleavedSolutionStorage will be adapted by the algorithms from
 simple array-like segment storage. That array-like storage is templatized
 in part so that an implementation may choose to handle byte ordering
 at access time.
 
InterleavedSolutionStorage å°†è¢«ç®—æ³•ä»ç®€å•çš„ç±»ä¼¼æ•°ç»„çš„æ®µå­˜å‚¨ä¸­è¿›è¡Œè°ƒæ•´ã€‚è¯¥ç±»ä¼¼æ•°ç»„çš„å­˜å‚¨åœ¨ä¸€å®šç¨‹åº¦ä¸Šæ˜¯æ¨¡æ¿åŒ–çš„ï¼Œä»¥ä¾¿å®ç°å¯ä»¥é€‰æ‹©åœ¨è®¿é—®æ—¶å¤„ç†å­—èŠ‚é¡ºåºã€‚
```



void PrepareForNumStarts(Index num_starts) constï¼š

```
This is called at the beginning of back-substitution for the
solution storage to do any remaining configuration before data
is stored to it. If configuration is previously finalized, this
could be a simple assertion or even no-op. Ribbon algorithms
only call this from back-substitution, and only once per call,
before other functions here.

åœ¨è§£ä»£æ›¿æ¢çš„å¼€å§‹æ—¶è°ƒç”¨æ­¤å‡½æ•°ï¼Œç”¨äºåœ¨æ•°æ®å­˜å‚¨åˆ°è§£å†³æ–¹æ¡ˆå­˜å‚¨ä¹‹å‰æ‰§è¡Œä»»ä½•å‰©ä½™çš„é…ç½®ã€‚å¦‚æœé…ç½®å·²ç»æœ€ç»ˆç¡®å®šï¼Œè¿™å¯èƒ½æ˜¯ä¸€ä¸ªç®€å•çš„æ–­è¨€ï¼Œç”šè‡³æ˜¯ç©ºæ“ä½œã€‚Ribbon ç®—æ³•åªåœ¨è§£ä»£æ›¿æ¢æ—¶è°ƒç”¨æ­¤å‡½æ•°ï¼Œæ¯æ¬¡è°ƒç”¨åªè°ƒç”¨ä¸€æ¬¡ï¼Œåœ¨è°ƒç”¨æ­¤å¤„çš„å…¶ä»–å‡½æ•°ä¹‹å‰ã€‚
```

Index GetNumStarts() constï¼š

```
Must return num_starts passed to PrepareForNumStarts, or the most
recent call to PrepareForNumStarts if this storage object can be
reused. Note that num_starts == num_slots - kCoeffBits + 1 because
there must be a run of kCoeffBits slots starting from each start.

å¿…é¡»è¿”å›ä¼ é€’ç»™ PrepareForNumStarts çš„ num_startsï¼Œæˆ–è€…å¦‚æœæ­¤å­˜å‚¨å¯¹è±¡å¯ä»¥è¢«é‡ç”¨ï¼Œåˆ™è¿”å›æœ€è¿‘ä¸€æ¬¡è°ƒç”¨ PrepareForNumStartsã€‚è¯·æ³¨æ„ï¼Œnum_starts == num_slots - kCoeffBits + 1ï¼Œå› ä¸ºå¿…é¡»æœ‰ä¸€ä¸ªä»æ¯ä¸ª start å¼€å§‹çš„ kCoeffBits æ§½çš„è¿è¡Œã€‚
```

Index GetUpperNumColumns() constï¼š

```
The larger number of solution columns used (called "b" above).
ä½¿ç”¨çš„è§£å†³æ–¹æ¡ˆåˆ—æ•°è¾ƒå¤§çš„æ•°å­—ï¼ˆä¸Šé¢ç§°ä¸ºâ€œbâ€ï¼‰ã€‚
```

Index GetUpperStartBlock() constï¼š

```
If returns > 0, then block numbers below that use
    GetUpperNumColumns() - 1 columns per solution row, and the rest
    use GetUpperNumColumns(). A block represents kCoeffBits "slots",
    where all but the last kCoeffBits - 1 slots are also starts. And
    a block contains a segment for each solution column.
    An implementation may only support uniform columns per solution
    row and return constant 0 here.

å¦‚æœè¿”å›å¤§äº 0ï¼Œåˆ™ä»¥ä¸‹çš„å—å·ä½¿ç”¨æ¯ä¸ªè§£å†³æ–¹æ¡ˆè¡Œ GetUpperNumColumns() - 1 åˆ—ï¼Œè€Œå…¶ä½™çš„ä½¿ç”¨ GetUpperNumColumns()ã€‚ä¸€ä¸ªå—è¡¨ç¤º kCoeffBits ä¸ªâ€œæ§½ä½â€ï¼Œå…¶ä¸­é™¤äº†æœ€åçš„ kCoeffBits - 1 ä¸ªæ§½ä½å¤–ï¼Œæ‰€æœ‰æ§½ä½ä¹Ÿæ˜¯å¼€å§‹ã€‚ä¸€ä¸ªå—åŒ…å«æ¯ä¸ªè§£å†³æ–¹æ¡ˆåˆ—çš„ä¸€ä¸ªæ®µã€‚ä¸€ä¸ªå®ç°å¯èƒ½åªæ”¯æŒæ¯ä¸ªè§£å†³æ–¹æ¡ˆè¡Œçš„å‡åŒ€åˆ—ï¼Œå¹¶åœ¨è¿™é‡Œè¿”å›å¸¸é‡0ã€‚
```

Index GetNumSegments() constï¼š

```
### "Array of segments" portion of API ###
    The number of values of type CoeffRow used in this solution
    representation. (This value can be inferred from the previous
    three functions, but is expected at least for sanity / assertion
    checking.)

API çš„ "æ•°ç»„æ®µ" éƒ¨åˆ†
åœ¨æ­¤è§£å†³æ–¹æ¡ˆè¡¨ç¤ºä¸­ä½¿ç”¨çš„ CoeffRow ç±»å‹çš„å€¼çš„æ•°é‡ã€‚ï¼ˆå°½ç®¡æ­¤å€¼å¯ä»¥ä»å‰ä¸‰ä¸ªå‡½æ•°ä¸­æ¨æ–­å‡ºæ¥ï¼Œä½†è‡³å°‘åœ¨è¿›è¡Œå¥å…¨æ€§/æ–­è¨€æ£€æŸ¥æ—¶åº”æä¾›ã€‚ï¼‰
```

CoeffRow LoadSegment(Index segment_num) constï¼š

```
Load an entry from the logical array of segments
```

void StoreSegment(Index segment_num, CoeffRow data)ï¼š

```
Store an entry to the logical array of segments
```

#### åŸºäºä¸¤ç§å­˜å‚¨æ–¹å¼ï¼Œå¯¹åº”çš„å›ä»£å’ŒæŸ¥è¯¢

##### SimpleSolutionStorage

æ–¹æ³•SimpleBackSubstï¼ˆï¼‰ï¼šä» BandingStorage ç”Ÿæˆè§£åˆ° SimpleSolutionStorage çš„è§£ä»£æ›¿æ¢ã€‚

æ–¹æ³•SimpleQueryHelperï¼ˆï¼‰ï¼šåœ¨ SimpleSolutionStorage ä¸­æŸ¥è¯¢ä¸€ä¸ªå·²ç»å“ˆå¸Œçš„å…³é”®å­—çš„é€šç”¨åŠŸèƒ½ã€‚

æ–¹æ³•SimplePhsfQueryï¼ˆï¼‰ï¼šä» SimpleSolutionStorage ä¸­è¿›è¡Œä¸€èˆ¬çš„ PHSF æŸ¥è¯¢ï¼ŒæŸ¥è¯¢ä¸€ä¸ªå…³é”®å­—ã€‚

æ–¹æ³•SimpleFilterQueryï¼ˆï¼‰ï¼š

##### InterleavedSolutionStorage

æ–¹æ³•BackSubstBlockï¼ˆï¼‰ï¼šå›ä»£æ–¹æ³•InterleavedBackSubstçš„helperæ–¹æ³•

æ–¹æ³•InterleavedBackSubstï¼ˆï¼‰ï¼šå›ä»£æ–¹æ³•

æ–¹æ³•InterleavedPrepareQueryï¼ˆï¼‰ï¼šPrefetch memory for a key in InterleavedSolutionStorage.

æ–¹æ³•InterleavedPhsfQueryï¼ˆï¼‰ï¼šä» InterleavedSolutionStorage ä¸­è¿›è¡Œçš„ä¸€èˆ¬ PHSF æŸ¥è¯¢ï¼Œä½¿ç”¨æ¥è‡ª InterleavedPrepareQuery çš„æŸ¥è¯¢å…³é”®å­—çš„æ•°æ®ã€‚

æ–¹æ³•InterleavedFilterQueryï¼ˆï¼‰ï¼šä» InterleavedFilterQuery è¿›è¡Œçš„å…³é”®å­—è¿‡æ»¤æŸ¥è¯¢ã€‚



å‡½æ•°SimpleBackSubstï¼ˆï¼‰ï¼š

å®ç°å›ä»£è§£é¢˜



#### ä»£ç ç»“æ„åˆ†æ

çŸ©é˜µå½¢æ€

```
    C    *    S    =    R
 (n x m)   (m x b)   (n x b)
 where C = coefficients, S = solution, R = results
 and solving for S given C and R.
 
 è¿™ä¸ªmä¹Ÿå«soltæ•°
```

æ¦‚å¿µæ¨¡å‹

```
 +-----------+                      +---+                 +-----------------+
 | AddInputs | ----BandingHasher--> | H | --------------> | BandingStorage  | æˆ‘ç†è§£åº”è¯¥æ˜¯å¤„ç†CçŸ©é˜µå’ŒRçŸ©é˜µ
 +-----------+                      | a |                 +-----------------+
                                    | s |                         |
                                    | h |                  Back substitution
                                    | e |                         V
 +-----------+  PhsfQueryHasher     | r |                 +-----------------+  å›ä»£è®¡ç®—SçŸ©é˜µ
 | Query Key | -FilterQueryHasher-> |   | >+++++++++++++< | SolutionStorage | ï¼ˆSimpleSolutionStorageï¼‰
 +-----------+                      +---+        |        +-----------------+ ï¼ˆInterleavedSolutionStorageï¼‰
                                                 V
                                            Query result
```

ä»£ç å®ç°æ¨¡å‹

```
 +-----------+                      +---+                 +-----------------+ æˆ‘ç†è§£åº”è¯¥æ˜¯å¤„ç†CçŸ©é˜µå’ŒRçŸ©é˜µ
 | AddInputs | ---StandardHasher--->| H | --------------> | BandingStorage  | StandardBanding
 +-----------+                      | a |                 +-----------------+
                                    | s |                         |
                                    | h |                  Back substitution
                                    | e |                         V
 +-----------+                      | r |                 +-----------------+  å›ä»£è®¡ç®—SçŸ©é˜µ
 | Query Key | ---StandardHasher--->|   | >+++++++++++++< | SolutionStorage | (InMemSimpleSolution)
 +-----------+                      +---+        |        +-----------------+ (SerializableInterleavedSolution)
                                                 V
                                            Query result
```

å¾ˆå®¹æ˜“å¾—åˆ°æ¦‚å¿µæ¨¡å‹ä¸å®é™…ä»£ç å®ç°çš„å¯¹åº”å…³ç³»

```
æ¦‚å¿µæ¨¡å‹                                             ä»£ç å®ç°

BandingHasher                ----------->      StandardHasher
PhsfQueryHasher              ----------->      StandardHasher
FilterQueryHasher            ----------->      StandardHasher
BandingStorage               ----------->      StandardBanding
SimpleSolutionStorage        ----------->      InMemSimpleSolution
InterleavedSolutionStorage   ----------->      SerializableInterleavedSolution

StandardHasherå­˜åœ¨å˜ä½“å®ç°StandardRehasherAdapter/StandardRehasher æš‚ä¸è®¨è®º
```



#### æ•°å­¦å‡½æ•°

FloorLog2ï¼ˆxï¼‰ï¼šfloorä»£è¡¨å‘ä¸‹å–æ•´ï¼Œ log2ä»£è¡¨ä»¥2ä¸ºåº•xçš„å¯¹æ•°

expï¼ˆxï¼‰ï¼šä»¥eä¸ºåº•xçš„å¯¹æ•°





### æ€§èƒ½å¯¹æ¯”UT

å¤§è‡´æŠŠrocksdbçš„ä»£ç çœ‹æ‡‚ä¹‹åï¼Œæˆ‘å†³å®šå¯¹æ¯”ä¸€ä¸‹ribbonå’Œbloomçš„æ€§èƒ½å·®å¼‚ï¼Œå…·ä½“ä¸ºåœ¨rocksdbçš„UTä¸­å®ç°HBaseä¸­çš„åŒæ¬¾Bloomã€‚ç„¶åè°ƒç”¨rocksdbçš„apiå¯¹æ¯”ä¸¤è€…æ€§èƒ½ã€‚

å¯¹äºHBaseä¸­çš„Bloomå¦‚ä½•å®ç°ï¼Œè¯·è§ [HBaseç« èŠ‚](/å¤§æ•°æ®/2023/10/28/HBase.html)

ä»£ç å·²ä¸Šä¼ [github](https://github.com/reflectt6/rocksdb)

å¾…è§£å†³é—®é¢˜ï¼š

1ã€å¤§é‡æŠ¥é”™ã€queryç˜«ç—ª

åœ¨ä¸‹é¢çš„é…ç½®ä¸‹ï¼š

```c++
struct Settings_Coeff128_Homog : public DefaultTypesAndSettings {
  // TODO ç›®å‰æœ‰ä¸¤ä¸ªé—®é¢˜éœ€è¦è§£å†³
  //  1ã€åœ¨è¿™ä¸ªå‚æ•°ä¸‹è¿è¡Œcellæµ‹è¯•ï¼Œæ±‚è§£å™¨ä¼šå´©æºƒï¼Œæ¯æ¬¡éƒ½è¿”å›trueï¼Œå¾…å®šä½
  //  2ã€cellè¿è¡Œè´¼æ…¢ï¼Œä¸çŸ¥é“ä¸ºå•¥ï¼Œä¸åº”è¯¥çš„
  static constexpr bool kHomogeneous = true;
  static constexpr bool kUseSmash = false;
  using Key = Cell;
  using KeyGen = HBaseKeyGen;
  static Hash HashFn(const HBASE_BLOOM_NAMESPACE::Cell& key, uint64_t raw_seed) {
    // This version 0.7.2 preview of XXH3 (a.k.a. XXPH3) function does
    // not pass SmallKeyGen tests below without some seed premixing from
    // StandardHasher. See https://github.com/Cyan4973/xxHash/issues/469
    return ROCKSDB_NAMESPACE::Hash64(
        reinterpret_cast<const char*>(key.cellArray), key.GetRowLength(), raw_seed);
  }
  static const std::vector<ConstructionFailureChance>& FailureChanceToTest() {
    return kFailureOnlyRare;
  }
};
```

è¿è¡Œè‡ªå®šä¹‰Keyä¸ºCellçš„æµ‹è¯•ç”¨ä¾‹RepeatCompactnessAndBacktrackAndFpRateä¸­ï¼Œè¿­ä»£æ¬¡æ•°å¤§äº0æ—¶ï¼Œä¼šå¤§é‡æŠ¥é”™

é”™è¯¯åŒ…å«ï¼š

- queryç˜«ç—ªï¼ŒæŸ¥è¯¢ä»»æ„å€¼éƒ½è¿”å›true

åŸå› æ˜¯ç”±äºåœ¨æµ‹è¯•ä»£ç ä¸­å¼•å…¥äº†ä¸é€šçš„é…ç½®ç±»ï¼Œæ˜¯å¾—æµ‹è¯•è¿‡ç¨‹ä¸­æµ‹è¯•ç±»ä¸­çš„å€¼ä¸æ­£ç¡®ï¼Œä¹Ÿå°±æ˜¯è¿™é‡Œ

```c++
if (DefaultTypesAndSettings::kHomogeneous || overhead_ratio < 1.01 ||
            batch_size == 0) {
.....
```

ç”±äºåœ¨å‰é¢å·²ç»å¯¹ç±»å‹åšè¿‡é‡å‘½åï¼Œè¿™é‡Œä¹Ÿåº”è¯¥ä½¿ç”¨ç»Ÿä¸€å‘½åçš„é…ç½®ç±»TypeParamï¼Œè€Œä¸æ˜¯DefaultTypesAndSettings

```c++
TEST(CompareTest, RepeatCompactnessAndBacktrackAndFpRate) {
  using TypeParam = Settings_Coeff128_Homog;
 .....
```

ä¿®æ”¹è¿™ç‚¹ä¹‹åï¼ŒUTæ²¡æœ‰å†æŠ¥é”™ï¼

2ã€è¿è¡Œæ—¶é—´è¿‡é•¿ï¼ˆå¯ä»¥è§„é¿ï¼‰

- åŸå› åœ¨äºæ¯ä¸ªCelléƒ½è¦ç”Ÿæˆä¸€ä¸ªéšæœºçš„colå€¼ï¼Œæ¯”è¾ƒè´¹æ—¶é—´ã€‚è§£å†³æ–¹å¼æš‚å®šä¸ºï¼š
  - å°†keyæ”¹ä¸ºuint32ï¼Œå’Œbloomå®ç°ä¿æŒä¸€è‡´ã€‚
  - ä¿®æ”¹bloomå¯¹åº”çš„ç”Ÿæˆé€»è¾‘ï¼Œä¹Ÿå°±æ˜¯ä½¿ç”¨Hash32KeyGenWrapper<StandardKeyGen>ç”Ÿæˆbloomçš„keyï¼Œç„¶åå†ç®€å•è®¡ç®—ä¸€ä¸‹bloomçš„fp

è€ƒè™‘æ–°çš„æµ‹è¯•æ–¹æ¡ˆï¼š

æœ€å¥½ä¿æŒribbonåŸç”Ÿä»£ç ä¸å˜ï¼Œå¼•å…¥hbase cellè¿›è¡Œæµ‹è¯•ï¼Œé¦–å…ˆåˆ†æä¸€ä¸‹ribbonåŸç”Ÿæµ‹è¯•é€»è¾‘

ä»¥é»˜è®¤é…ç½®ï¼ˆDefaultTypesAndSettingsï¼‰ä¸‹çš„æµ‹è¯•Fpçš„UTä¸ºä¾‹ï¼ˆå…¶å®å¾ˆå¤šæ˜¯é€šç”¨çš„ï¼‰ï¼š

```
1ã€ä½¿ç”¨äº†æ ‡å‡†çš„StandardKeyGenï¼Œä»–ä¼šç”Ÿæˆä¸€ä¸ª[64+prefixä½æ•°]ä½çš„stringï¼Œåœ¨ä¼ é€’ç»™HashFnæ—¶åšéšå¼ç±»å‹è½¬åŒ–ï¼Œå˜æˆSliceç±»å‹ï¼Œæœ€ç»ˆçš„Hashå€¼å°±æ˜¯é€šè¿‡è¿™ä¸ª[64+prefixä½æ•°]ä½çš„Sliceè®¡ç®—è€Œæ¥ã€‚ï¼ˆä¸ºäº†å¯¹ç…§ï¼Œæˆ‘ä»¬åœ¨è®¾è®¡HBaseæµ‹è¯•ç”¨ä¾‹æ—¶ï¼Œä¹Ÿè¦å°†å¾…Hashçš„éƒ¨åˆ†è®¾è®¡ä¸º[64+prefixä½æ•°]ä½ã€‚å…·ä½“ä¸€ç‚¹ï¼Œå¦‚æœrowä¸ºfilterï¼Œåˆ™rowçš„é•¿åº¦ä¸º[64+prefixä½æ•°]ä½ï¼Œå¦‚æœrow/colä¸ºfilterï¼Œåˆ™row+colä¸º[64+prefixä½æ•°]ä½ï¼‰ã€‚
```



ä¸´æ—¶æµ‹è¯•ç»“æœï¼š

1ã€ribbon homog smashï¼ˆæ—¶é—´æ˜¯ä¸¤ç§æ±‚è§£å™¨çš„æ€»æ—¶é—´ï¼Œå•ä¸ªæ—¶é—´ä¼šæ›´å°‘ï¼‰

```
ç¬¬3æ¬¡è¿­ä»£ï¼š
è®¡ç®—numæ—¶é—´ï¼š0msï¼Œ å…¶ä¸­ num_to_add = 146706, num_slots = 155136
ç”ŸæˆHBaseKey å®šä¹‰solnæ—¶é—´ï¼š0msï¼Œ å…¶ä¸­ overhead_ratio = 1.05746
bandingçš„æ—¶é—´ï¼š90msï¼Œ æ­¤æ—¶æ·»åŠ äº†num_to_addä¸ªkeyï¼š146706bandingå æ®æ•°é‡146706
æµ‹è¯•backtrackingçš„æ—¶é—´ï¼š0msï¼Œæ˜¯å¦è¢«è·³è¿‡ï¼š0
æµ‹è¯•æ·»åŠ å†—ä½™keyçš„æ—¶é—´ï¼š6ms
solnæ±‚è§£çš„æ—¶é—´ï¼š94msï¼Œæ˜¯å¦è·³è¿‡isolnï¼š0
æµ‹è¯•é€šè¿‡å°å¹…åº¦å¢åŠ ç©ºé—´ï¼Œæ˜¯å¦å¯ä»¥å¢åŠ bandingçš„æˆåŠŸç‡çš„æ—¶é—´ï¼ˆexpandï¼‰ï¼š0msï¼Œæ˜¯å¦è¢«è·³è¿‡ï¼š1, seed = 0
æŸ¥è¯¢å·²æ·»åŠ çš„keyæ—¶é—´ï¼š333msï¼Œæ˜¯å¦è·³è¿‡isolnï¼š0
æŸ¥è¯¢soln æœªæ·»åŠ çš„keyï¼Œå¹¶è®¡ç®—fp æ—¶é—´ï¼š12ms
æŸ¥è¯¢isoln æœªæ·»åŠ çš„keyï¼Œå¹¶è®¡ç®—fp æ—¶é—´ï¼š4msï¼Œ æ˜¯å¦è·³è¿‡0
å¯¹æ¯”bloomçš„æ—¶é—´ï¼š1msï¼Œ æ­¤æ—¶ç¬¬3æ¬¡è¿­ä»£ç»“æŸ
```

2ã€bloom  one chunkï¼Œ expected fp rate = 0.01

```
utilizationRate = 0.0518068
bloom chunk size = 131kb
save keys = 109306
expected fp rate = 0.01
construction time = 215ms
overhead rate = 1.19913
fp rate = 0.0084
cnt = 10000
fp_count = 84
æŸ¥è¯¢å·²æ’å…¥çš„keyï¼Œè¿”å›trueçš„æ•°é‡ = 0
æŸ¥è¯¢10000æ¬¡ = 19ms
æŸ¥è¯¢å·²æ’å…¥çš„keyçš„æ—¶é—´ = 219ms
```



### XXPHæ˜¯ä»€ä¹ˆï¼Ÿ

rocksdbä¸­å­˜åœ¨XXPH3.hå¤´æ–‡ä»¶ï¼Œribbon filterçš„å®ç°ä¸­ä¹Ÿå­˜åœ¨XXPHçš„å­—æ ·ï¼Œè¿™æ˜¯å•¥å‘¢ï¼Ÿ

æ ¹æ®å¤´æ–‡ä»¶ä¸­çš„æ³¨é‡Šï¼ŒXXPHå°±æ˜¯XX Preview Hashçš„ç¼©å†™ã€‚XX Hashæ˜¯ä¸€ç§å¿«é€Ÿhashç®—æ³•ï¼Œåœ¨[githubä¸Šå¼€æº](https://github.com/Cyan4973/xxHash)ã€‚è€ŒXX Preview Hashå°±æ˜¯XX Hashçš„å‰ç»ç‰ˆã€‚
