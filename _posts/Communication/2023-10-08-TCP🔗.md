---
layout: page-with-sidebar
title:  "TCP🔗"
date:   2023-10-08 11:11:03 +0800
author: reflectt6
categories: "通信"
#permalink: 
mainTag: "通信"
secondaryTag: "网络"
---

## 前言

TCP连接为什么要进行三次握手、四次挥手？这个问题困扰我已久。

最近在思考DDos攻击时，查了波[资料](https://mp.weixin.qq.com/s?__biz=MzI4NjE4NTUwNQ==&mid=2247494421&idx=1&sn=8a1e925f02a3c491c3a0b34f201c344c&chksm=ebe26a5bdc95e34d590609df45c207948c0fd97ec9baee54c70a8993e2c7937c8d0da2086ab2&scene=27)，忽然悟了，借此机会详细论述一番！

在讨论三次握手之前，我们先来了解一下什么是TCP连接。

## 认识TCP连接

TCP准确来说是一种网络协议。提到网络协议就不得不提一下，OSI七层模型。从上到下依次为：

- 应用层
- 表示层
- 会话层
- 传输层
- 网络层
- 数据链路层
- 物理层

表示层和会话层不好理解。所以我更喜欢另一个TPC/IP五层模型，从上到下依次为：

- 应用层：HTTP
- 传输层：TCP/UDP
- 网络层：IP
- 数据链路层
- 物理层

可以看到TCP协议属于传输层，他将应用层得到的数据包，通过某种方式和另外一侧的对象建立可靠的连接。

本质上，TCP规定了这个“某种方式”的实现方式。

## TCP的数据结构

![图片](/assets/images/2023-10-08-TCP🔗/TCP数据格式1.png)

![图片](/assets/images/2023-10-08-TCP🔗/TCP数据头.png)

## TCP连接方式

TCP采取三次握手，四次挥手的连接方式，如下图：

![图片](/assets/images/2023-10-08-TCP🔗/三次握手四次挥手.png)

由此也产生了两个经典的疑问？

- 为什么三次握手就可以建立可靠连接？

- 为什么断开连接需要四次挥手？

## 为啥是三次握手

为什么不是两次握手，为什么不是100次握手？

### 猜疑链

在解释这个问题之前，我们先讨论一下下面的观点：

`不管几次握手，通信双方都没办法100%确认，两人的交流不出问题。`这也是TCP仍然可能丢包的原因所在。

设想一下，假如a和b通信，a如何能保证b能收到自己的下一条信息呢？想要b一定收到自己的消息，那么有几个必要条件：

1. b自己不出问题：b的服务器得有电，b的服务得正常运行，b的网卡不能出问题等等。
2. a到b的通路不出问题：可能a到b中间有很多段道路，那么这每一段道路都不能出问题，每一段道路两边的路由都不能阻塞或瘫痪等等。
3. a自己不出问题：a服务器的网络设备等不能崩溃。

还挺多的吧，想想这些哪一条，是可以通过握手解决的？a收到了b的回信，但是a还是会担心在实际通讯过程中发生以上问题，a只能再发一条信息确认，直到收到b的回信，a才能确认上一次的通信没有问题；b也是如此。a和b双方互不信任，形成猜疑链，一直握手试探，这是个没有终止的死循环，永远也无法实现可靠的连接。

`根本原因在于通过握手，只能确认上一次的通信情况，而不能确认下一次的通信状况；而确认上一次的通信情况，没有意义；那我们是否可以推断说握手没有意义？`

### 何为可靠？

由上述逻辑，我们推出了握手没有意义。那为什么大家都说三次握手建立了可靠连接呢？

既然握手无法确认下一次的通信情况，那握手的意义在哪？

一旦我们接受了 `不管几次握手，通信双方都没办法100%确认，两人的交流不出问题。`的结论，那建立可靠连接的目标，也要改变一下才行了。我不一定要建立100%可靠的连接，我只需要建立一个相比UDP等无握手协议更可靠的连接即可。

没有绝对的可靠，只有相对的可靠

以这个思路再来看三次握手，握手的意义在哪？

我们知道握手能确认上一次的通信结果；上一次通信距离下一次通信的时间越短，那么是否可以认为下一次通信越可靠？所以超时时间的设计很关键。

a向b发起连接请求（第一次握手）；a在规定时间内收到了b的回复（第二次握手），此时对于a来讲，b是相对可靠的，不考虑各种意外情况，至少说明b在 `当前一段时间内`具有和a快速通信的能力。同样，b也要如此确认一下，因此有了第三次握手，b在规定时间内收到了a的回复，此时b也确定了a的快速通信能力。在不考虑天灾人祸的情况下，两者进入了相对可靠的连接状态。

这也就是为什么要三次握手的原因。

### 分类讨论推协议

其实这里有很多种情况需要分类讨论，我挑一个：

如果a发出第一次握手后，没有收到回信，那么有三种情况：

1. b没有收到消息
2. b收到了消息，但是b的回信在路上被阻塞了，过一段时间这个回信还是会发到a的
3. b收到了消息，但是b的回信在路上被消灭了，例如停电、路由器重启导致数据包丢了等原因

针对三种情况，a应该如何处理：

1. a再发一次给b，请求连接。
2. a再发一次给b，请求连接。但是在接受到b迟到的消息之后，直接丢弃掉。
3. a再发一次给b，请求连接。

由此我们得出了两条TCP协议的内容：

1. 一段时间没收到回信，我就再发一次
2. 收到的过期回信，统统丢掉

由上述的思路继续分析一下场景，

- 如果b发出第二次握手之后，没有收到回信，b该怎么办？

- 如果a发出第三次握手之后，没有收到回信，a该怎么办？

- 如果b发出正文数据之后，没有收到回信，b该怎么办？

- 如果a收到了重复的正文数据，a该怎么办？

由此即可推出TCP协议剩余内容。



## 为什么是四次挥手？

在考虑这个问题之前，先考虑一个问题，为什么要挥手？

两个人建立连接，通信完就完事了呗，为什么要让双方都达成一致，结束通信呢。有些经验的人应该已经想到了，因为TCP连接是占用内存资源的，服务端和客户端维护一个连接池，存放已经沟通好的连接。防止连接过多导致资源不足，因此我们通讯完，需要释放掉这个内存资源，这才有了四次挥手。



至于为什么是四次挥手？

a想要断开连接时，如果b还有数据没发完怎么办，第三次和第四次挥手就是来确认b的数据发完了用的。



