---
layout: page-with-sidebar
title:  "C++11"
date:   2024-12-22 9:47:03 +0800
author: reflectt6
categories: "C和C++"
mainTag: "编程基础"
secondaryTag: "C和C++"
hideTag: false

---

## std::array

- gpt

  `std::array<Wheel, 4> w;` 是一段 C++ 代码，声明了一个固定大小的数组，包含 4 个类型为 `Wheel` 的对象。这段代码基于 `std::array`，是 C++ 标准库提供的模板类，用于管理固定大小的数组。下面是详细讲解：

  ------

  ### **代码解析**

  1. **`std::array`**
     - 是 C++11 引入的模板类。
     - 提供了一种更安全、更灵活的固定大小数组管理方式。
     - 替代了传统 C 风格数组（如 `Wheel w[4];`）。
  2. **`Wheel`**
     - 这是一个用户自定义的类或结构体类型。
     - 数组中的每个元素是 `Wheel` 类型的实例。
  3. **`4`**
     - 指定了数组的大小，即固定存储 4 个 `Wheel` 对象。
  4. **`w`**
     - 数组变量的名字。

  ------

  ### **使用示例**

  假设我们有一个简单的 `Wheel` 类：

  ```cpp
  #include <array>
  #include <iostream>
  
  class Wheel {
  public:
      Wheel() { std::cout << "Wheel created\n"; }
      ~Wheel() { std::cout << "Wheel destroyed\n"; }
      void rotate() const { std::cout << "Wheel rotating\n"; }
  };
  
  int main() {
      // 创建 std::array
      std::array<Wheel, 4> wheels;
  
      // 访问元素并调用方法
      wheels[0].rotate();
      wheels[1].rotate();
  
      return 0;
  }
  ```

  ------

  ### **主要特性**

  1. **固定大小**

     - `std::array` 的大小在编译时确定，不能动态调整。
     - 与动态容器（如 `std::vector`）不同，它没有内存分配的开销。

  2. **支持 STL 接口**

     - 提供了 STL 风格的接口，比如 `size()`, `begin()`, `end()` 等。

     ```cpp
     for (const auto& wheel : wheels) {
         wheel.rotate();
     }
     ```

  3. **安全性**

     - 提供了 `at()` 方法，支持边界检查；直接使用下标 `[]` 不会检查边界。

     ```cpp
     wheels.at(0).rotate(); // 安全访问
     wheels[4].rotate();    // 未定义行为，因为越界
     ```

  4. **拷贝和赋值**

     - 支持拷贝、赋值操作，并且遵循值语义。

     ```cpp
     std::array<Wheel, 4> wheels2 = wheels; // 拷贝整个数组
     ```

  5. **初始化列表**

     - 可以使用统一的初始化方式：

     ```cpp
     std::array<Wheel, 4> wheels = {Wheel(), Wheel(), Wheel(), Wheel()};
     ```

  ------

  ### **对比 C 风格数组**

  | **特性**     | **`std::array`**                         | **C 风格数组**   |
  | ------------ | ---------------------------------------- | ---------------- |
  | **大小确定** | 编译时固定大小                           | 编译时固定大小   |
  | **边界检查** | `at()` 提供边界检查                      | 不支持           |
  | **接口支持** | 提供 STL 风格接口，如 `begin()`, `end()` | 不支持           |
  | **拷贝赋值** | 支持整个数组的拷贝赋值                   | 仅支持逐元素赋值 |
  | **类型安全** | 强类型                                   | 容易与指针混淆   |
  | **性能开销** | 与 C 风格数组性能相近，无额外开销        | 性能最优         |

  ------

  ### **常见问题**

  1. **数组大小可否动态调整？**

     - 不可以，`std::array` 的大小是编译时固定的。如果需要动态调整大小，应该使用 `std::vector`。

  2. **`Wheel` 是否必须有默认构造函数？**

     - 是的，`std::array` 中的元素会在数组创建时默认初始化，`Wheel` 类型必须有默认构造函数。如果没有，可以使用自定义构造方式：

     ```cpp
     std::array<Wheel, 4> wheels = {Wheel(1), Wheel(2), Wheel(3), Wheel(4)};
     ```

  3. **如何传递 `std::array`？**

     - 可以通过值、引用或指针传递：

     ```cpp
     void processArray(std::array<Wheel, 4>& wheels) {
         wheels[0].rotate();
     }
     ```

  ------

  ### 总结

  - `std::array<Wheel, 4> w;` 声明了一个固定大小的数组，包含 4 个 `Wheel` 类型的对象。
  - 它结合了 C 风格数组的高效性和 STL 容器的灵活性，是现代 C++ 中处理固定大小数组的首选方式。



## [[maybe_unused]]

也可以将参数注释掉

```c
int GetAge(int /*id*/)
```



- gpt

  C++ 的 `[[maybe_unused]]` 是一种 **属性（attribute）**，引入于 C++17，用于告知编译器某些变量、函数、参数、或其他实体虽然未被显式使用，但这是有意的，编译器不需要因此发出警告。

  ------

  ### **用法场景**

  #### **1. 未使用的变量**

  在调试或条件编译中，某些变量可能被定义但没有使用。`[[maybe_unused]]` 可以抑制编译器发出的未使用警告。

  **示例：变量**

  ```cpp
  void example() {
      [[maybe_unused]] int unusedVariable = 42; // 无论是否使用都不会发出警告
  }
  ```

  ------

  #### **2. 未使用的函数参数**

  函数定义中，有些参数可能在某些版本中未使用，或者是为将来扩展保留的。这种情况下可以使用 `[[maybe_unused]]` 避免警告。

  **示例：函数参数**

  ```cpp
  void process([[maybe_unused]] int debugFlag) {
      // debugFlag 暂未使用，但将来可能会用
      std::cout << "Processing...\n";
  }
  ```

  ------

  #### **3. 未使用的函数**

  某些函数可能暂时未调用，但你想保留它们而不删除代码。

  **示例：未调用的函数**

  ```cpp
  [[maybe_unused]] void helperFunction() {
      // 辅助功能代码
  }
  ```

  ------

  #### **4. 结合条件编译**

  在跨平台代码中，不同平台可能会使用不同的变量或参数。`[[maybe_unused]]` 可用于避免特定情况下未使用的警告。

  **示例：跨平台代码**

  ```cpp
  void platformSpecificCode() {
  #ifdef _WIN32
      [[maybe_unused]] int windowsSpecific = 1;
  #else
      [[maybe_unused]] int linuxSpecific = 2;
  #endif
  }
  ```

  ------

  ### **`[[maybe_unused]]` 的作用范围**

  `[[maybe_unused]]` 可以用于以下实体：

  - **变量**（包括局部变量和成员变量）
  - **函数**
  - **函数参数**
  - **模板参数**
  - **类型声明**

  ------

  ### **示例：各种适用场景**

  ```cpp
  #include <iostream>
  
  // 对变量的使用
  void testVariable() {
      [[maybe_unused]] int x = 10; // 未使用，但不会警告
  }
  
  // 对函数参数的使用
  void testParameter([[maybe_unused]] int flag) {
      std::cout << "Running test...\n";
  }
  
  // 对函数的使用
  [[maybe_unused]] void unusedFunction() {
      std::cout << "This function is not yet used.\n";
  }
  
  // 对模板参数的使用
  template <typename T>
  void testTemplate([[maybe_unused]] T value) {
      std::cout << "Template function\n";
  }
  
  // 对类型声明的使用
  class [[maybe_unused]] UnusedType {
      int a;
  };
  ```

  ------

  ### **与 `#pragma` 的区别**

  `[[maybe_unused]]` 提供了一种标准化的方法，与平台相关的 `#pragma` 或特定编译器的选项（如 `-Wunused-parameter`）相比：

  - **可移植性**：`[[maybe_unused]]` 是标准化的写法，跨编译器表现一致。
  - **更精细**：可将属性直接应用于需要标记的实体，而不影响其他代码。

  ------

  ### **常见注意事项**

  1. **不是静默忽略**
      使用 `[[maybe_unused]]` 不会改变程序的行为，只是告知编译器不需要发出未使用警告。
  2. **不适用于强制未使用**
      如果确实需要确保某些变量未被使用，应该用其他方法检测。
  3. **兼容性**
      `[[maybe_unused]]` 是 C++17 引入的属性，在更早版本中可能无法使用。如果需要兼容性，可以使用编译器特定的指令来替代。

  ------

  ### **总结**

  - **`[[maybe_unused]]` 的核心作用：**避免未使用实体的警告。
  - **适用范围：**变量、函数、参数、类型等。
  - 推荐使用场景：
    - 条件编译。
    - 为将来扩展预留的代码。
    - 避免误导性警告而保持代码清晰。



## 可变参数模版

- gpt

  **可变参数模板**（Variadic Template）是 C++11 引入的强大功能，用于处理不定数量的模板参数。与传统的 C 风格可变参数函数相比，模板提供了类型安全和更强的灵活性。

  ------

  ### **定义与语法**

  可变参数模板通过以下两种方式支持不定数量的模板参数：

  1. **模板参数包**（`T...`）：表示任意数量的模板参数。
  2. **函数参数包**（`args...`）：表示函数的参数包。

  #### 基本语法

  ```cpp
  template <typename... T>        // 模板参数包
  void func(T... args) {          // 函数参数包
      // 处理参数
  }
  ```

  ------

  ### **示例：打印任意数量的参数**

  ```cpp
  #include <iostream>
  
  // 可变参数模板
  template <typename... Args>
  void print(Args... args) {
      (std::cout << ... << args) << std::endl; // 使用折叠表达式
  }
  
  int main() {
      print(1, 2, 3, "hello", 4.5); // 打印多个参数
      return 0;
  }
  ```

  **输出：**

  ```
  123hello4.5
  ```

  ------

  ### **可变参数模板的核心概念**

  #### **1. 模板参数包**

  `typename... T` 定义了一个模板参数包，表示模板可以接收任意数量的类型参数。

  #### **2. 函数参数包**

  `T... args` 定义了一个函数参数包，表示函数可以接收任意数量的参数，这些参数的类型由模板参数包 `T...` 决定。

  #### **3. 参数展开**

  参数包需要展开才能逐一处理，主要有以下两种方式：

  - **递归展开**
  - **折叠表达式**（C++17 引入）

  ------

  ### **递归展开示例**

  递归展开是一种常见的方式，通过递归调用函数来逐一处理参数。

  ```cpp
  #include <iostream>
  
  // 处理单个参数的基函数
  void print() {}
  
  // 可变参数模板：递归展开
  template <typename T, typename... Args>
  void print(T first, Args... rest) {
      std::cout << first << " ";
      print(rest...); // 递归调用，处理剩余参数
  }
  
  int main() {
      print(1, 2.5, "hello", true);
      return 0;
  }
  ```

  **输出：**

  ```
  1 2.5 hello 1
  ```

  ------

  ### **折叠表达式（C++17）**

  折叠表达式是处理参数包的一种简洁方式，它通过运算符将参数包中的参数折叠为一个表达式。

  #### 语法形式

  - **一元左折叠**：`(... op pack)`
  - **一元右折叠**：`(pack op ...)`
  - **二元左折叠**：`(init op ... op pack)`
  - **二元右折叠**：`(pack op ... op init)`

  #### 示例：参数求和

  ```cpp
  #include <iostream>
  
  // 使用折叠表达式计算参数和
  template <typename... Args>
  auto sum(Args... args) {
      return (... + args); // 左折叠
  }
  
  int main() {
      std::cout << "Sum: " << sum(1, 2, 3, 4) << std::endl;
      return 0;
  }
  ```

  **输出：**

  ```
  Sum: 10
  ```

  #### 示例：打印参数

  ```cpp
  #include <iostream>
  
  // 使用折叠表达式打印参数
  template <typename... Args>
  void print(Args... args) {
      (std::cout << ... << args) << std::endl; // 左折叠
  }
  
  int main() {
      print("Hello", ", ", "world", "!");
      return 0;
  }
  ```

  **输出：**

  ```
  Hello, world!
  ```

  ------

  ### **典型应用场景**

  #### **1. 实现多参数的安全处理**

  可变参数模板比传统的 C 风格可变参数函数更安全。例如：

  ```cpp
  template <typename... Args>
  void log(const Args&... args) {
      (std::cout << ... << args) << std::endl; // 类型安全
  }
  ```

  #### **2. 类型检查**

  通过模板参数包可以对参数类型进行严格检查。例如：

  ```cpp
  #include <iostream>
  #include <type_traits>
  
  // 检查是否所有参数都是整数
  template <typename... Args>
  constexpr bool allIntegers = (std::is_integral_v<Args> && ...);
  
  int main() {
      static_assert(allIntegers<int, long, short>, "Not all integers!");
      // static_assert(allIntegers<int, double>, "Not all integers!"); // 编译报错
      return 0;
  }
  ```

  #### **3. 构造多参数容器**

  在 STL 中，可变参数模板被用来实现容器的多参数构造。例如：

  ```cpp
  #include <vector>
  
  template <typename T, typename... Args>
  std::vector<T> makeVector(Args&&... args) {
      return {std::forward<Args>(args)...};
  }
  
  int main() {
      auto v = makeVector<int>(1, 2, 3, 4, 5);
      for (auto i : v) {
          std::cout << i << " ";
      }
      return 0;
  }
  ```

  **输出：**

  ```
  1 2 3 4 5
  ```

  ------

  ### **递归展开 vs 折叠表达式**

  | 特性           | 递归展开                   | 折叠表达式     |
  | -------------- | -------------------------- | -------------- |
  | **引入版本**   | C++11                      | C++17          |
  | **实现复杂度** | 需要基函数和递归调用       | 简洁，直接展开 |
  | **编译性能**   | 编译器需要处理多层递归调用 | 更高效         |
  | **可读性**     | 可读性稍低                 | 可读性更好     |

  ------

  ### **注意事项**

  1. **参数包展开**
     - 参数包必须显式展开。
     - 使用递归展开或折叠表达式实现逐一处理。
  2. **类型匹配**
     - 模板参数包的类型由调用时的参数推导。
     - 可变参数模板可以接受不定数量的不同类型。
  3. **C++17 推荐使用折叠表达式**
     - 更简洁高效，推荐优先使用。

  ------

  ### **总结**

  1. **核心概念**
     - 模板参数包 `typename... T` 和函数参数包 `T... args` 是可变参数模板的基础。
     - 参数包需要通过递归展开或折叠表达式处理。
  2. **应用场景**
     - 动态处理不定数量的参数。
     - 实现多参数容器构造、类型检查、日志系统等。
  3. **现代 C++ 的推荐**
     - 使用折叠表达式替代递归展开。
     - 尽量利用模板的类型安全特性，避免传统 C 风格的可变参数函数。



## 声明时初始化

- gpt

  **声明时初始化**是指在变量声明的同时对其进行赋值或初始化。它是变量管理的基本操作，在 C++ 中，良好的初始化习惯可以避免使用未初始化变量导致的错误。

  ------

  ### **基本形式**

  #### **1. 内置类型的声明时初始化**

  对于简单的内置类型（如 `int`、`double` 等），可以在声明时赋初值：

  ```cpp
  int a = 10;  // 声明时初始化为 10
  double pi = 3.14; // 声明时初始化为 3.14
  char c = 'A'; // 声明时初始化为 'A'
  ```

  #### **2. 类类型的声明时初始化**

  对于类类型（如 `std::string` 或用户定义的类），可以直接通过构造函数进行初始化：

  ```cpp
  std::string name = "John";  // 使用构造函数初始化
  std::vector<int> numbers = {1, 2, 3}; // 列表初始化
  ```

  ------

  ### **三种初始化语法**

  C++ 提供了三种主要的初始化语法：

  #### **1. 拷贝初始化**

  通过赋值语法对变量进行初始化：

  ```cpp
  int a = 10; // 拷贝初始化
  std::string s = "Hello"; // 拷贝初始化
  ```

  #### **2. 直接初始化**

  通过括号 `()` 的形式初始化变量：

  ```cpp
  int a(10); // 直接初始化
  std::string s("Hello"); // 直接初始化
  ```

  #### **3. 列表初始化**

  通过花括号 `{}` 的形式初始化变量：

  ```cpp
  int a{10}; // 列表初始化
  std::string s{"Hello"}; // 列表初始化
  std::vector<int> v{1, 2, 3}; // 列表初始化
  ```

  ------

  ### **声明时初始化的优点**

  1. **提高代码可读性**：声明时就明确了变量的初始值。
  2. **减少未初始化变量的风险**：避免因忘记初始化导致未定义行为。
  3. **高效与安全**：对于类对象，直接初始化可以减少不必要的拷贝或默认构造。

  ------

  ### **示例：声明时初始化对比**

  以下是一个简单的类，展示了如何使用声明时初始化：

  ```cpp
  #include <iostream>
  #include <string>
  
  class Person {
  private:
      std::string name;
      int age;
  
  public:
      // 构造函数
      Person(const std::string& n, int a) : name(n), age(a) {} // 初始化列表
  
      void print() const {
          std::cout << "Name: " << name << ", Age: " << age << std::endl;
      }
  };
  
  int main() {
      Person p("Alice", 25); // 声明时初始化
      p.print();
  
      return 0;
  }
  ```

  **输出：**

  ```
  Name: Alice, Age: 25
  ```

  ------

  ### **总结**

  - 声明时初始化是变量管理的基础，可以通过 **拷贝初始化**、**直接初始化** 或 **列表初始化** 实现。
  - 对于内置类型，初始化赋初值；对于类类型，利用构造函数或初始化列表。
  - 初始化时避免未定义行为，是良好编程习惯的体现。



## 移动构造函数、移动赋值操作符

- gpt

  在 C++ 中，**移动构造函数**和**移动赋值操作符**是为了实现**移动语义**（move semantics），它们可以提高程序效率，特别是对于资源管理类（如 `std::vector`, `std::unique_ptr` 等），避免不必要的拷贝操作。

  ### **1. 移动构造函数（Move Constructor）**

  

  `移动构造函数常常加上noexcept，因为移动构造函数、delete操作符、移动赋值操作符等常会被开源库、高性能库调用，如果这些库在调用过程中，我们抛出了异常，可能会导致未定义的行为`

  
  
  移动构造函数用于通过**转移资源**来构造一个新的对象，而不是拷贝已有对象的数据。它的目的是将资源的所有权从一个临时对象转移到新对象，避免深拷贝。

  #### **语法：**

  ```cpp
  ClassName(ClassName&& other) noexcept;  // 移动构造函数 
  // 1、加上noexcept可以让编译器放心优化 实现移动语义
  // 2、因为移动构造函数、delete操作符、移动赋值操作符等常会被开源库、高性能库调用，如果这些库在调用过程中，我们抛出了异常，可能会导致未定义的行为
  ```
  
  #### **行为：**
  
  - 将临时对象 `other` 的资源转移到新对象 `this`。
  - 将 `other` 的状态置为有效但不再使用（通常将其设置为默认构造状态）。
  
  #### **示例：**
  
  ```cpp
  #include <iostream>
  #include <vector>
  
  class MyClass {
  public:
      std::vector<int> data;
  
      // 构造函数
      MyClass(std::initializer_list<int> values) : data(values) {}
  
      // 移动构造函数
      MyClass(MyClass&& other) noexcept {
          data = std::move(other.data);  // 通过 std::move 转移资源
          std::cout << "Move constructor called" << std::endl;
      }
  
      void print() {
          for (auto val : data) {
              std::cout << val << " ";
          }
          std::cout << std::endl;
      }
  };
  
  int main() {
      MyClass obj1{1, 2, 3};
      MyClass obj2 = std::move(obj1);  // 使用移动构造函数
  
      obj2.print();  // 输出: 1 2 3
      obj1.print();  // 输出: 空的 (因为 obj1 的资源已经被转移)
  
      return 0;
  }
  ```
  
  #### **输出：**
  
  ```
  Move constructor called
  1 2 3
  ```

  ------
  
  ### **2. 移动赋值操作符（Move Assignment Operator）**

  移动赋值操作符用于将一个临时对象的资源**移动**到已存在的对象，而不是拷贝数据。它通常用于已创建的对象接收来自另一个临时对象的资源。

  #### **语法：**
  
  ```cpp
  ClassName& operator=(ClassName&& other);  // 移动赋值操作符
  ```

  #### **行为：**
  
  - 将 `other` 的资源转移到当前对象（`this`）。
  - 如果 `this` 和 `other` 是不同对象，则释放当前对象的资源，并转移 `other` 的资源。
  - 将 `other` 的状态置为有效但不再使用。
  
  #### **示例：**
  
  ```cpp
  #include <iostream>
  #include <vector>
  
  class MyClass {
  public:
      std::vector<int> data;
  
      // 构造函数
      MyClass(std::initializer_list<int> values) : data(values) {}
  
      // 移动构造函数
      MyClass(MyClass&& other) noexcept {
          data = std::move(other.data);
          std::cout << "Move constructor called" << std::endl;
      }
  
      // 移动赋值操作符
      MyClass& operator=(MyClass&& other) noexcept {
          if (this != &other) {  // 防止自赋值
              data = std::move(other.data);  // 转移资源
              std::cout << "Move assignment called" << std::endl;
          }
          return *this;
      }
  
      void print() {
          for (auto val : data) {
              std::cout << val << " ";
          }
          std::cout << std::endl;
      }
  };
  
  int main() {
      MyClass obj1{1, 2, 3};
      MyClass obj2{4, 5, 6};
      
      obj2 = std::move(obj1);  // 使用移动赋值操作符
  
      obj2.print();  // 输出: 1 2 3
      obj1.print();  // 输出: 空的 (因为 obj1 的资源已经被转移)
  
      return 0;
  }
  ```

  #### **输出：**

  ```
  Move constructor called
  Move assignment called
  1 2 3
  ```
  
  ------
  
  ### **总结：**
  
  1. **移动构造函数**：用于通过**构造**一个新对象并转移资源（如内存、指针等）。
     - 适用于临时对象或将对象移动到新的容器中。
     - 使用 `std::move` 将资源转移。
  2. **移动赋值操作符**：用于将一个已存在的对象的资源转移到另一个对象。
     - 适用于已存在的对象被赋值一个临时对象。
     - 需要处理自赋值（即检查 `this != &other`）。
  
  通过使用移动构造函数和移动赋值操作符，C++ 程序能够避免不必要的拷贝操作，提升性能，特别是在处理大型数据或资源管理的类时。



## noexcept

- gpt

  `noexcept` 是 C++11 引入的一个关键字，用来声明一个函数不会抛出异常。它是对函数的**异常保证**的一种明确声明，告诉编译器和开发者该函数不会抛出任何异常，从而使得编译器能够进行优化，提高程序的效率和安全性。

  ### **1. 使用 `noexcept` 的原因**

  - **优化**：编译器可以对 `noexcept` 声明的函数进行更多优化，例如函数调用时避免生成异常处理代码。
  - **提供更强的异常保证**：明确函数不抛出异常，让调用者知道该函数的行为更加可预测。
  - **用于标准库**：在 C++ 标准库中，`noexcept` 常用于标记不抛出异常的函数，这有助于编译器优化。

  ------

  ### **2. 基本语法**

  #### **函数声明中使用 `noexcept`**

  ```cpp
  void foo() noexcept;  // 表示 foo 不会抛出异常
  
  int add(int a, int b) noexcept {  // 这个函数不会抛出异常
      return a + b;
  }
  ```

  #### **条件性 `noexcept`**

  `noexcept` 也可以带有条件，即依赖于某些表达式的计算结果：

  ```cpp
  template <typename T>
  void func(T& obj) noexcept(noexcept(obj.some_method())) {
      obj.some_method();
  }
  ```

  在这个例子中，`func` 的 `noexcept` 保证依赖于 `obj.some_method()` 是否会抛出异常。

  ------

  ### **3. 影响**

  #### **编译器优化**

  当编译器知道某个函数不会抛出异常时，它可以优化这个函数的调用。例如，异常处理机制通常会为函数调用准备额外的代码，`noexcept` 可以让编译器跳过这些代码，提升性能。

  #### **移动语义中的作用**

  在移动构造函数和移动赋值操作符中，标记为 `noexcept` 可以帮助编译器决定是否可以进行更高效的移动操作。

  ```cpp
  class MyClass {
  public:
      MyClass(MyClass&& other) noexcept {  // 如果没有异常，编译器可以优化移动操作
          // 移动资源
      }
  };
  ```

  ------

  ### **4. 与异常处理的关系**

  - 如果一个函数声明为 `noexcept`，但在执行过程中抛出了异常，程序将调用 `std::terminate`，导致程序终止。
  - 如果一个函数没有声明 `noexcept`，且抛出了异常，那么程序将进入常规的异常处理流程。

  #### **示例：**

  ```cpp
  void foo() noexcept {
      // 这里的代码不会抛出异常
  }
  
  void bar() {
      throw std::runtime_error("error");  // 这个函数抛出了异常
  }
  
  int main() {
      try {
          foo();  // 不会抛出异常
          bar();  // 会抛出异常
      } catch (const std::exception& e) {
          std::cout << "Caught: " << e.what() << std::endl;
      }
  }
  ```

  ------

  ### **5. 总结**

  - `noexcept` 用于声明函数不会抛出异常，提供了异常保证并帮助编译器进行优化。
  - 在标准库中，很多函数会标记为 `noexcept` 来提高性能。
  - 如果一个声明为 `noexcept` 的函数抛出异常，程序会调用 `std::terminate`，导致程序终止。

  通过使用 `noexcept`，你可以让程序更高效，并使代码的异常处理更加明确。



## = delete 显式禁用某个函数

- gpt

  在 C++11 中，`= delete` 是一种特殊的语法，用来**删除函数**，即禁用某个特定函数的使用。通过将函数标记为 `delete`，你可以明确禁止该函数的调用，防止它被错误使用。

  ### **1. 语法**

  ```cpp
  void myFunction() = delete;
  ```

  ### **2. 主要用途**

  1. **禁用特定的函数**：
     - 当你希望禁止某些不合理的操作时，可以使用 `= delete`。比如，在某些类中，你可能不希望进行拷贝构造或拷贝赋值操作，或者希望禁止某些不符合逻辑的函数调用。
  2. **防止编译器自动生成函数**：
     - C++ 编译器通常会为一些类自动生成拷贝构造函数、拷贝赋值操作符、移动构造函数等。如果这些函数的默认实现不符合你的需求，可以显式地删除这些函数，从而避免它们被生成和使用。

  ### **3. 常见应用**

  #### **禁用拷贝构造和拷贝赋值操作符**

  在一些类中，禁止拷贝操作可能是合理的，比如管理动态资源的类。

  ```cpp
  class MyClass {
  public:
      MyClass() = default;  // 默认构造函数
  
      // 禁用拷贝构造和拷贝赋值操作符
      MyClass(const MyClass&) = delete;  
      MyClass& operator=(const MyClass&) = delete;  
  
      // 可以提供移动构造和移动赋值操作符
      MyClass(MyClass&&) noexcept = default;
      MyClass& operator=(MyClass&&) noexcept = default;
  };
  ```

  - 上面的代码中，通过 `= delete` 禁用了拷贝构造和拷贝赋值操作符。这意味着无法创建 `MyClass` 类型的对象的拷贝，也无法将一个对象赋值给另一个对象。

  #### **禁用某些不合理的函数**

  ```cpp
  class MyClass {
  public:
      MyClass(int x) : x(x) {}
  
      void operator=(int) = delete;  // 禁止将 MyClass 对象赋值为 int 类型
  
  private:
      int x;
  };
  ```

  - 在这个例子中，`MyClass` 类型的对象不能直接与整数 `int` 类型进行赋值。

  #### **禁用默认构造函数**

  ```cpp
  class MyClass {
  public:
      MyClass(int x) : x(x) {}
  
      // 禁用默认构造函数
      MyClass() = delete;  
  
  private:
      int x;
  };
  ```

  - 如果一个类只有一个带参数的构造函数，且没有提供默认构造函数，那么使用 `= delete` 显式禁止默认构造函数，防止无参构造函数的意外调用。

  ### **4. 删除函数的作用**

  - **禁止某些操作**：通过显式禁用某些函数，避免程序员错误地使用不符合需求的功能，增强程序的安全性。
  - **防止编译器自动生成函数**：在类中禁用默认的拷贝构造和拷贝赋值操作符，可以防止编译器为类自动生成这些函数，从而避免不必要的资源复制操作。
  - **明确接口设计**：通过显式删除函数，开发者能更加清晰地表达哪些操作是不可用的，从而避免不必要的误用。

  ### **5. 总结**

  `= delete` 是 C++11 引入的特性，允许开发者显式删除某个函数，防止它被错误调用或编译器自动生成。常用于禁止拷贝构造、拷贝赋值等操作，或者禁止某些不合理的函数调用，确保类的设计和接口更加清晰和安全。



## = default

- gpt

  在 C++11 中，`= default;` 是一种特殊的语法，用来指示编译器**使用默认的实现**来定义某个特殊成员函数（如构造函数、拷贝构造函数、拷贝赋值操作符等）。这意味着你可以显式地要求编译器生成默认实现，而不是编写自己的实现。

  ### **1. 语法**

  ```cpp
  class MyClass {
  public:
      MyClass() = default;  // 默认构造函数
  
      MyClass(const MyClass&) = default;  // 默认拷贝构造函数
  
      MyClass& operator=(const MyClass&) = default;  // 默认拷贝赋值操作符
  };
  ```

  ### **2. 用途**

  1. **显式要求使用编译器的默认实现**： 如果你没有提供构造函数、拷贝构造函数或拷贝赋值操作符等，编译器会自动生成它们。但你也可以显式地使用 `= default` 来告诉编译器生成默认的实现。这对于明确表示你的意图非常有用，尤其是当类有复杂的成员或特殊需求时。
  2. **显式禁用某些函数**： `= default;` 也可以用于恢复某些默认操作。例如，如果你删除了拷贝构造函数 `= delete`，但希望为移动构造函数提供默认实现，你可以使用 `= default` 来恢复移动构造函数的默认实现。

  ### **3. 常见应用**

  #### **默认构造函数**

  ```cpp
  class MyClass {
  public:
      MyClass() = default;  // 使用默认构造函数
  };
  ```

  - 如果你没有定义任何构造函数，编译器会自动生成一个默认构造函数。但是，使用 `= default;` 可以显式地声明默认构造函数，并且它可以与其他自定义构造函数一起使用。

  #### **拷贝构造函数**

  ```cpp
  class MyClass {
  public:
      MyClass(const MyClass&) = default;  // 使用默认拷贝构造函数
  };
  ```

  - 如果你的类包含动态分配的资源（如指针成员），并且你希望拷贝构造函数执行**浅拷贝**，那么你可以显式使用 `= default;` 来告诉编译器生成默认的拷贝构造函数。否则，编译器可能会为类生成自己的版本，可能不符合你的需求。

  #### **拷贝赋值操作符**

  ```cpp
  class MyClass {
  public:
      MyClass& operator=(const MyClass&) = default;  // 使用默认拷贝赋值操作符
  };
  ```

  - 默认的拷贝赋值操作符会按成员逐个赋值，这在某些情况下是你需要的行为。如果你没有自定义拷贝赋值操作符，可以使用 `= default` 来显式地告诉编译器使用默认的拷贝赋值操作符。

  #### **移动构造函数和移动赋值操作符**

  ```cpp
  class MyClass {
  public:
      MyClass(MyClass&&) = default;  // 使用默认移动构造函数
      MyClass& operator=(MyClass&&) = default;  // 使用默认移动赋值操作符
  };
  ```

  - 如果你的类只包含可移动的资源（如智能指针），并且你希望编译器生成一个默认的移动构造函数或移动赋值操作符，可以使用 `= default;`。

  ### **4. 总结**

  - **`= default;`** 显式要求编译器生成默认的实现，通常用于构造函数、拷贝构造函数、赋值操作符等。
  - 它使得代码更加明确，尤其是在需要组合自定义行为和默认行为时。
  - 可以显式地使用 `= default` 来让编译器为类成员生成默认实现，避免自己编写复杂的实现。
