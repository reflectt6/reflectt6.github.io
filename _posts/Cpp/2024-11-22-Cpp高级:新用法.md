---
layout: page-with-sidebar
title:  "Cpp高级或新用法"
date:   2024-11-22 9:47:03 +0800
author: reflectt6
categories: "C和C++"
mainTag: "编程基础"
secondaryTag: "C和C++"
hideTag: false

---

## 右值引用、移动语义、完美转发

### 什么是左值和右值？

- gpt

  在 C++ 中，左值（lvalue）和右值（rvalue）是两个重要的概念，它们描述了表达式结果在程序中的位置和用途。理解这两个概念对于写出高效且符合语义的代码至关重要。

  ### 左值（lvalue）

  **左值**是指有明确存储位置的值，表示一个可以被取地址的内存位置。
   通常，变量、数组元素、指针解引用等都属于左值。

  #### 特点

  1. **有持久存储空间**：左值表示某个对象在内存中的位置。
  2. **可出现在赋值符号左侧**：左值是赋值的目标。

  #### 示例

  ```cpp
  int x = 10;       // x 是左值，有存储位置
  x = 20;           // 左值 x 出现在赋值号左侧
  int* p = &x;      // 可以对 x 取地址
  ```

  #### 注意

  即使有些表达式是左值，但不能修改（如 `const` 对象）：

  ```cpp
  const int y = 10;
  // y = 20; // 错误，y 是左值但不可修改
  ```

  ------

  ### 右值（rvalue）

  **右值**是指没有明确存储位置的值，通常是表达式的临时结果，或表示一个字面量。
   右值是计算产生的值，仅在表达式中存在。

  #### 特点

  1. **没有持久存储空间**：右值通常是临时值。
  2. **只能出现在赋值符号右侧**：右值不能作为赋值目标。

  #### 示例

  ```cpp
  int x = 10;       // 10 是右值
  int y = x + 5;    // x + 5 的结果是右值
  ```

  ------

  ### 左值和右值的区别

  | **特性**       | **左值（lvalue）** | **右值（rvalue）**     |
  | -------------- | ------------------ | ---------------------- |
  | 是否有存储空间 | 是                 | 否                     |
  | 是否可赋值     | 是                 | 否（除非通过右值引用） |
  | 是否能取地址   | 是                 | 否                     |
  | 生存期         | 与作用域一致       | 通常是临时的           |

  | **特性**       | **左值（lvalue）**                 | **右值（rvalue）**                 |
  | -------------- | ---------------------------------- | ---------------------------------- |
  | **可否取地址** | 可以，使用 `&` 获取其地址          | 不可以                             |
  | **生命周期**   | 通常比表达式更长                   | 临时，通常在表达式结束后销毁       |
  | **可否赋值**   | 可以作为赋值目标                   | 不可以（除非是右值引用）           |
  | **典型例子**   | 变量、数组元素、函数返回的左值引用 | 字面值、表达式结果、函数返回的右值 |
  
  ------
  
  ### 左值和右值引用
  
  C++11 引入了右值引用（`T&&`），使右值能够被引用。
  
  #### 左值引用
  
  只能绑定到左值：
  
  ```cpp
  int x = 10;
  int& ref = x;  // 正确
  // int& ref2 = 10; // 错误，右值不能绑定到左值引用
  ```
  
  #### 右值引用
  
  只能绑定到右值：
  
  ```cpp
  int&& ref = 10; // 正确，右值引用绑定右值
  ref = 20;       // 修改临时对象的值
  std::cout << ref << std::endl; // 输出 20
  ```
  
  右值引用通常用于**移动语义**和**完美转发**，以优化性能。
  
  ------
  
  ### 左值和右值的实际应用
  
  #### 1. 优化性能：移动语义
  
  右值引用允许开发者避免不必要的拷贝操作。
  
  ```cpp
  #include <iostream>
  #include <vector>
  
  std::vector<int> createVector() {
      return std::vector<int>{1, 2, 3}; // 返回右值
  }
  
  int main() {
      std::vector<int> vec = createVector(); // 移动语义避免拷贝
      return 0;
  }
  ```

  #### 2. 区分临时对象和持久对象

  ```cpp
  int x = 10;
  int y = x + 5; // x 是左值，x + 5 是右值
  ```
  
  ------
  
  ### 总结
  
  - **左值**：有地址，可取地址，有持久存储，通常是变量或对象。
  - **右值**：临时值，无地址，不可取地址，通常是表达式结果或字面量。
  - C++11 引入右值引用（`T&&`）扩展了右值的应用场景，如性能优化（移动语义）和函数重载。



### 移动语义

- gpt

  **移动语义**是 C++11 引入的一项强大功能，用于提高程序性能，特别是在资源管理和对象拷贝的场景中。它的核心思想是通过“**移动**”资源，而不是“**拷贝**”资源，来避免不必要的性能开销。

  ------

  ### 背景：为什么需要移动语义？

  在传统 C++ 中，当需要将一个对象的资源传递到另一个对象时，通常会**复制**资源。这会导致额外的性能开销，特别是在涉及动态内存分配的大型对象时。

  #### 示例：拷贝语义的开销

  ```cpp
  #include <vector>
  #include <iostream>
  
  int main() {
      std::vector<int> vec1{1, 2, 3, 4, 5};
      std::vector<int> vec2 = vec1; // 拷贝，vec2 需要重新分配内存并复制数据
      return 0;
  }
  ```

  在上述代码中，`vec1` 的所有数据都会被复制到 `vec2`，这可能会很耗时。

  ------

  ### 什么是移动语义？

  移动语义通过**右值引用（`T&&`）**实现，允许对象的资源所有权从一个对象转移到另一个对象，而不涉及资源的复制。

  #### 移动语义的行为

  1. **资源转移**：移动语义会直接将一个对象的资源“移动”到另一个对象。
  2. **减少开销**：避免重新分配内存或复制数据，提高性能。

  ------

  ### 移动语义的实现

  #### 右值引用（`T&&`）

  右值引用是实现移动语义的关键。它允许我们通过绑定到**右值**来实现资源的移动，而不会对原资源进行拷贝。

  ```cpp
  #include <iostream>
  #include <vector>
  
  int main() {
      std::vector<int> vec1{1, 2, 3, 4, 5};
      std::vector<int> vec2 = std::move(vec1); // 使用 std::move 实现移动
      // vec1 的资源转移到了 vec2，vec1 可能为空
      std::cout << "vec1 size: " << vec1.size() << std::endl;
      std::cout << "vec2 size: " << vec2.size() << std::endl;
      return 0;
  }
  ```

  #### `std::move`

  `std::move` 是一个标准库函数，用于将一个对象（左值）**显式地**转换为右值，以便触发移动语义。

  ------

  ### 移动构造函数和移动赋值运算符

  要支持移动语义，一个类需要实现**移动构造函数**和**移动赋值运算符**。

  #### 示例：实现移动语义的类

  ```cpp
  #include <iostream>
  #include <utility> // for std::move
  
  class MyClass {
  private:
      int* data;
      size_t size;
  
  public:
      // 构造函数
      MyClass(size_t s) : size(s), data(new int[s]) {
          std::cout << "Constructor called" << std::endl;
      }
  
      // 移动构造函数
      MyClass(MyClass&& other) noexcept : size(other.size), data(other.data) {
          other.size = 0;
          other.data = nullptr; // 释放 other 的所有权
          std::cout << "Move Constructor called" << std::endl;
      }
  
      // 移动赋值运算符
      MyClass& operator=(MyClass&& other) noexcept {
          if (this != &other) {
              delete[] data; // 清理自身资源
              size = other.size;
              data = other.data;
  
              other.size = 0;
              other.data = nullptr; // 释放 other 的所有权
              std::cout << "Move Assignment Operator called" << std::endl;
          }
          return *this;
      }
  
      // 析构函数
      ~MyClass() {
          delete[] data;
          std::cout << "Destructor called" << std::endl;
      }
  };
  
  int main() {
      MyClass obj1(10);            // 调用构造函数
      MyClass obj2 = std::move(obj1); // 调用移动构造函数
      return 0;
  }
  ```

  ------

  ### 移动语义 vs. 拷贝语义

  | **特性**     | **拷贝语义**                       | **移动语义**               |
  | ------------ | ---------------------------------- | -------------------------- |
  | **资源管理** | 创建资源的副本                     | 直接转移资源所有权         |
  | **性能**     | 可能较慢（涉及内存分配、数据复制） | 较快（避免资源复制）       |
  | **触发条件** | 需要左值引用或拷贝构造函数         | 需要右值引用或移动构造函数 |

  ------

  ### 使用场景

  1. **容器类**：`std::vector`, `std::string` 等标准容器，避免大量数据拷贝。
  2. **临时对象**：当需要将临时对象的内容转移到另一个对象时。
  3. **资源管理类**：自定义类中涉及动态内存、文件句柄等资源的场景。

  ------

  ### 总结

  - 移动语义通过右值引用和 `std::move` 提高了资源管理的效率。
  - 通过实现移动构造函数和移动赋值运算符，可以自定义类的移动行为。
  - 移动语义是现代 C++ 编程中优化性能的重要工具。

### 完美转发（模版+右值引用）

- gpt

  **完美转发**是 C++11 引入的一种技术，允许一个函数在调用另一个函数时，**完美地传递参数**的值类别（左值或右值），从而保持原始参数的特性。这是通过**右值引用**和**模板**实现的。

  ------

  ### 为什么需要完美转发？

  在传统转发中，如果参数是右值，转发后可能变成左值，从而失去了原始的值类别。这会导致性能问题或行为异常。

  #### 示例：传统转发问题

  ```cpp
  #include <iostream>
  #include <utility>
  
  void targetFunction(int& x) { 
      std::cout << "Lvalue called" << std::endl; 
  }
  
  void targetFunction(int&& x) { 
      std::cout << "Rvalue called" << std::endl; 
  }
  
  template <typename T>
  void forwardFunction(T arg) {
      targetFunction(arg); // 问题：右值被转为左值
  }
  
  int main() {
      int x = 10;
      forwardFunction(x);      // 调用左值版本，输出 "Lvalue called"
      forwardFunction(20);     // 意外调用左值版本，输出 "Lvalue called"
      return 0;
  }
  ```

  **问题**：

  - 当 `forwardFunction(20)` 被调用时，右值 `20` 被传递给 `arg` 后变成左值。
  - 因此，`targetFunction` 的左值版本被调用，而不是右值版本。

  ------

  ### 完美转发的实现

  通过 **右值引用** 和 `std::forward`，可以实现完美转发，保持参数的值类别。

  #### 完美转发的语法

  ```cpp
  template <typename T>
  void forwardFunction(T&& arg) {
      targetFunction(std::forward<T>(arg)); // 使用 std::forward 保留值类别
  }
  ```

  - `T&&` 是**万能引用**（或转发引用），它可以同时接受左值和右值。
  - `std::forward` 会根据 `T` 的具体类型（左值引用或右值引用）进行正确的转发。

  ------

  ### 示例：完美转发

  ```cpp
  #include <iostream>
  #include <utility>
  
  void targetFunction(int& x) { 
      std::cout << "Lvalue called" << std::endl; 
  }
  
  void targetFunction(int&& x) { 
      std::cout << "Rvalue called" << std::endl; 
  }
  
  template <typename T>
  void forwardFunction(T&& arg) {
      targetFunction(std::forward<T>(arg)); // 完美转发
  }
  
  int main() {
      int x = 10;
      forwardFunction(x);      // 调用左值版本，输出 "Lvalue called"
      forwardFunction(20);     // 调用右值版本，输出 "Rvalue called"
      return 0;
  }
  ```

  **解释**：

  1. 当传递 `x` 时，`T` 推导为 `int&`，`std::forward<int&>` 将 `arg` 转发为左值。
  2. 当传递 `20` 时，`T` 推导为 `int`，`std::forward<int>` 将 `arg` 转发为右值。

  ------

  ### 核心概念

  #### 1. **万能引用**

  ```cpp
  template <typename T>
  void func(T&& arg);
  ```

  - **万能引用**（或转发引用）可以绑定到左值或右值。
  - 左值传入时，`T` 推导为左值引用类型，例如 `int&`。
  - 右值传入时，`T` 推导为普通类型，例如 `int`。

  #### 2. **`std::forward`**

  - `std::forward` 是一个标准库工具，用于根据模板参数的类型，正确地将参数转发为左值或右值。

  - 实现示意：

    ```cpp
    template <typename T>
    T&& forward(typename std::remove_reference<T>::type& param) {
        return static_cast<T&&>(param);
    }
    ```

  #### 3. **与 `std::move` 的区别**

  - `std::move` 强制将一个对象视为右值。
  - `std::forward` 根据类型信息进行条件性转发。

  ------

  ### 使用场景

  #### 1. **包装函数调用**

  完美转发常用于包装一个函数，并将参数“原封不动”地传递给目标函数。

  ```cpp
  template <typename F, typename... Args>
  auto invoke(F&& f, Args&&... args) {
      return std::forward<F>(f)(std::forward<Args>(args)...);
  }
  ```

  #### 2. **工厂函数**

  用于动态创建对象时，完美转发可以减少不必要的拷贝。

  ```cpp
  #include <string>
  #include <iostream>
  
  class MyClass {
  public:
      MyClass(const std::string& name) { 
          std::cout << "Lvalue Constructor: " << name << std::endl; 
      }
  
      MyClass(std::string&& name) { 
          std::cout << "Rvalue Constructor: " << name << std::endl; 
      }
  };
  
  template <typename T>
  MyClass createMyClass(T&& name) {
      return MyClass(std::forward<T>(name));
  }
  
  int main() {
      std::string name = "Hello";
      createMyClass(name);          // 调用左值构造函数
      createMyClass("World");       // 调用右值构造函数
      return 0;
  }
  ```

  ------

  ### 总结

  1. **完美转发**允许函数在不改变参数值类别的情况下，将参数传递给另一个函数。
  2. 它通过 **万能引用**（`T&&`）和 `std::forward` 实现，保证了左值被转发为左值，右值被转发为右值。
  3. 常用于函数包装器、工厂函数和高效的资源管理场景，是现代 C++ 编程中的重要技术。





## tie(C++11)/结构化绑定(C++17)

- gpt

  在 C++ 中，**`std::tie`** 和 **结构化绑定** 都是为了方便处理多个返回值或多值解构的工具。它们使代码更简洁且更具可读性。

  ------

  ### **`std::tie`**

  #### 1. 基本介绍

  `std::tie` 是 C++11 引入的工具，用于解构多个返回值或变量。它将多个变量**绑定到元组的对应元素**，实现类似“解包”的效果。

  #### 2. 使用场景

  - 从返回的元组中提取值。
  - 忽略不需要的返回值。

  #### 3. 语法

  ```cpp
  std::tie(var1, var2, ...) = tuple;
  ```

  #### 4. 示例代码

  **解构元组**

  ```cpp
  #include <iostream>
  #include <tuple>
  
  std::tuple<int, std::string, double> getInfo() {
      return {42, "example", 3.14};
  }
  
  int main() {
      int num;
      std::string text;
      double value;
  
      // 使用 std::tie 解构元组
      std::tie(num, text, value) = getInfo();
  
      std::cout << "Number: " << num << ", Text: " << text << ", Value: " << value << std::endl;
      return 0;
  }
  ```

  **忽略某些返回值**

  ```cpp
  #include <tuple>
  #include <iostream>
  
  std::tuple<int, double, char> getData() {
      return {10, 3.14, 'A'};
  }
  
  int main() {
      int x;
      char z;
  
      // 使用 std::ignore 忽略第二个返回值
      std::tie(x, std::ignore, z) = getData();
  
      std::cout << "x = " << x << ", z = " << z << std::endl;
      return 0;
  }
  ```

  #### 5. 注意

  - 使用 `std::tie` 时，被绑定的变量必须是左值（可修改）。
  - 如果只需要一部分值，使用 `std::ignore` 忽略不需要的部分。

  

  ### **结构化绑定**

  #### 1. 基本介绍

  结构化绑定是 C++17 引入的一种更现代的语法，用于直接解构元组、结构体、数组等数据结构，无需显式使用 `std::tie`。
   它更加简洁、直观，推荐在支持 C++17 的环境中使用。

  #### 2. 使用场景

  - 解构元组、数组、`std::pair`。
  - 从结构体中提取成员变量。

  #### 3. 语法

  ```cpp
  auto [var1, var2, ...] = object;
  ```

  #### 4. 示例代码

  **解构元组**

  ```cpp
  #include <tuple>
  #include <iostream>
  
  std::tuple<int, std::string, double> getInfo() {
      return {42, "example", 3.14};
  }
  
  int main() {
      auto [num, text, value] = getInfo();
  
      std::cout << "Number: " << num << ", Text: " << text << ", Value: " << value << std::endl;
      return 0;
  }
  ```

  **解构 `std::pair`**

  ```cpp
  #include <iostream>
  #include <utility>
  
  std::pair<int, std::string> getPair() {
      return {42, "example"};
  }
  
  int main() {
      auto [id, name] = getPair();
  
      std::cout << "ID: " << id << ", Name: " << name << std::endl;
      return 0;
  }
  ```

  **解构结构体**

  ```cpp
  #include <iostream>
  #include <string>
  
  struct Person {
      std::string name;
      int age;
  };
  
  int main() {
      Person p{"Alice", 30};
  
      // 解构结构体
      auto [personName, personAge] = p;
  
      std::cout << "Name: " << personName << ", Age: " << personAge << std::endl;
      return 0;
  }
  ```

  **解构数组**

  ```cpp
  #include <iostream>
  
  int main() {
      int arr[] = {1, 2, 3};
  
      auto [x, y, z] = arr;
  
      std::cout << "x: " << x << ", y: " << y << ", z: " << z << std::endl;
      return 0;
  }
  ```

  #### 5. 注意

  - 结构化绑定要求对象是可以解构的，例如元组、数组、`std::pair` 或支持 `std::tuple_size` 的类型。
  - 使用结构化绑定时，生成的变量是新的本地变量。

  ------

  ### **`std::tie` vs. 结构化绑定**

  | **特性**             | **`std::tie`**               | **结构化绑定**                        |
  | -------------------- | ---------------------------- | ------------------------------------- |
  | 引入版本             | C++11                        | C++17                                 |
  | 是否需要显式绑定变量 | 是，需要提前定义绑定变量     | 否，直接解构生成新变量                |
  | 语法复杂性           | 相对复杂                     | 简洁直观                              |
  | 是否支持忽略值       | 使用 `std::ignore` 明确忽略  | 无法直接忽略（可以使用 `_` 或不使用） |
  | 适用场景             | 解构元组，通常与已有变量绑定 | 解构元组、结构体、数组等              |

  ------

  ### **总结**

  - 如果你使用的是 C++17 或更高版本，**结构化绑定**是推荐的选择，因为它语法简洁、功能强大。
  - 在 C++11 和 C++14 中，可以使用 **`std::tie`** 来解构元组，并通过 `std::ignore` 忽略不需要的值。



## 函数指针、std::function(C++11)、lambda

- gpt

  **函数指针** 是 C++ 中的一种类型，可以存储函数的地址，从而动态调用不同的函数。这种特性可以用于实现回调机制、动态函数选择等。

  ------

  ### **基本概念**

  #### 定义

  **函数指针**是指向函数的指针。它存储了函数的入口地址，允许通过该指针调用目标函数。

  #### 语法

  ```cpp
  返回类型 (*指针名称)(参数列表);
  ```

  - **返回类型**：函数的返回值类型。
  - **参数列表**：函数的参数类型和顺序必须与指针声明一致。

  ------

  ### **示例：基本用法**

  ```cpp
  #include <iostream>
  
  // 函数定义
  int add(int a, int b) {
      return a + b;
  }
  
  int subtract(int a, int b) {
      return a - b;
  }
  
  int main() {
      // 定义一个函数指针，指向具有相同签名的函数
      int (*funcPtr)(int, int);
  
      // 指向函数 add
      funcPtr = add;
      std::cout << "Addition: " << funcPtr(10, 5) << std::endl; // 调用 add
  
      // 指向函数 subtract
      funcPtr = subtract;
      std::cout << "Subtraction: " << funcPtr(10, 5) << std::endl; // 调用 subtract
  
      return 0;
  }
  ```

  **输出：**

  ```
  Addition: 15
  Subtraction: 5
  ```

  ------

  ### **函数指针的典型用法**

  #### 1. **作为参数传递**

  函数指针可以作为另一个函数的参数，从而实现动态调用。

  **示例：实现回调机制**

  ```cpp
  #include <iostream>
  
  void execute(int a, int b, int (*operation)(int, int)) {
      std::cout << "Result: " << operation(a, b) << std::endl;
  }
  
  int multiply(int x, int y) {
      return x * y;
  }
  
  int divide(int x, int y) {
      return y != 0 ? x / y : 0;
  }
  
  int main() {
      execute(6, 3, multiply); // 将函数指针传递给 execute
      execute(6, 3, divide);   // 动态调用不同的函数
      return 0;
  }
  ```

  **输出：**

  ```
  Result: 18
  Result: 2
  ```

  #### 2. **作为返回值**

  函数指针可以作为函数的返回值，从而实现函数的动态选择。

  **示例：返回函数指针**

  ```cpp
  #include <iostream>
  
  int add(int a, int b) { return a + b; }
  int subtract(int a, int b) { return a - b; }
  
  int (*getOperation(char op))(int, int) {
      if (op == '+') return add;
      else if (op == '-') return subtract;
      else return nullptr;
  }
  
  int main() {
      auto func = getOperation('+');
      if (func) std::cout << "Result: " << func(7, 3) << std::endl; // 调用 add
  
      func = getOperation('-');
      if (func) std::cout << "Result: " << func(7, 3) << std::endl; // 调用 subtract
  
      return 0;
  }
  ```

  **输出：**

  ```
  Result: 10
  Result: 4
  ```

  ------

  ### **函数指针数组**

  为了管理一组函数，可以使用函数指针数组。这在需要根据索引动态选择函数时非常有用。

  **示例：函数指针数组**

  ```cpp
  #include <iostream>
  
  int add(int a, int b) { return a + b; }
  int subtract(int a, int b) { return a - b; }
  int multiply(int a, int b) { return a * b; }
  
  int main() {
      // 定义函数指针数组
      int (*operations[3])(int, int) = {add, subtract, multiply};
  
      // 动态调用函数
      std::cout << "Addition: " << operations[0](10, 5) << std::endl;
      std::cout << "Subtraction: " << operations[1](10, 5) << std::endl;
      std::cout << "Multiplication: " << operations[2](10, 5) << std::endl;
  
      return 0;
  }
  ```

  **输出：**

  ```
  Addition: 15
  Subtraction: 5
  Multiplication: 50
  ```

  ------

  ### **C++ 中的函数指针与现代替代方法**

  #### 1. **`std::function`**

  C++11 引入了 `std::function`，它是通用的可调用对象包装器，可以封装函数指针、lambda 表达式等。

  **示例：用 `std::function` 替代函数指针**

  ```cpp
  #include <iostream>
  #include <functional>
  
  int add(int a, int b) { return a + b; }
  
  int main() {
      std::function<int(int, int)> func = add;
      std::cout << "Addition: " << func(10, 5) << std::endl;
  
      // 使用 lambda 表达式
      func = [](int a, int b) { return a * b; };
      std::cout << "Multiplication: " << func(10, 5) << std::endl;
  
      return 0;
  }
  ```

  **输出：**

  ```
  Addition: 15
  Multiplication: 50
  ```

  #### 2. **Lambda 表达式**

  Lambda 表达式在现代 C++ 中非常常用，能够快速定义匿名函数，并与函数指针兼容。

  **示例：Lambda 与函数指针**

  ```cpp
  #include <iostream>
  
  int main() {
      // 定义一个 lambda 表达式
      auto multiply = [](int a, int b) { return a * b; };
  
      // 定义函数指针并赋值为 lambda
      int (*funcPtr)(int, int) = [](int a, int b) { return a + b; };
  
      std::cout << "Lambda Multiply: " << multiply(6, 7) << std::endl;
      std::cout << "Function Pointer Add: " << funcPtr(6, 7) << std::endl;
  
      return 0;
  }
  ```

  **输出：**

  ```
  Lambda Multiply: 42
  Function Pointer Add: 13
  ```

  ------

  ### **总结**

  1. **函数指针的核心用途**
     - 动态调用函数。
     - 实现回调机制。
     - 在运行时选择函数。
  2. **函数指针的优势**
     - 灵活性高，能提高代码复用性。
  3. **现代替代方案**
     - 在现代 C++ 中，`std::function` 和 lambda 表达式在很多场景下替代了传统函数指针，提供了更强的功能和更好的可读性。



## 可变参模版替换va_arg

可变参模版在C++11中有介绍，其中折叠表达式在C++17中有介绍

- va_arg用法 注意此用法已经被可变参模版安全替换，因此这里不详细介绍用法

  ```C++
  #include <stdarg.h>
  #include <iostream>
  
  // 定义一个可变参数函数
  int sum(int count, ...) {
      int total = 0;
  
      // 定义 va_list 并初始化
      va_list args;
      va_start(args, count);
  
      // 使用 va_arg 提取参数
      for (int i = 0; i < count; ++i) {
          total += va_arg(args, int); // 提取 int 类型的参数
      }
  
      // 清理
      va_end(args);
      return total;
  }
  
  int main() {
      std::cout << "Sum of 1, 2, 3: " << sum(3, 1, 2, 3) << std::endl;
      std::cout << "Sum of 4, 5: " << sum(2, 4, 5) << std::endl;
      return 0;
  }
  ```






## 慎用友元 friend关键字

friend除了在操作符重载场景，其他场景不要使用

- gpt

  **`friend`** 关键字是 C++ 中的一种特殊声明方式，用于授予非成员函数、类或其他实体对一个类的**私有成员**或**保护成员**的访问权限。通常情况下，类的私有或保护成员只能被类的成员函数或其派生类访问，但通过 `friend`，可以打破这种封装规则。

  ------

  ### **`friend` 的基本语法和用途**

  #### **1. 友元函数**

  友元函数是一个非成员函数，通过 `friend` 声明，可以访问类的私有和保护成员。

  ##### **语法**

  ```cpp
  class ClassName {
      friend ReturnType FunctionName(Parameters); // 声明一个友元函数
  };
  ```

  ##### **示例**

  ```cpp
  #include <iostream>
  
  class Box {
  private:
      double length;
  
  public:
      Box(double len) : length(len) {}
  
      // 友元函数声明
      friend void printLength(const Box& b);
  };
  
  // 友元函数定义
  void printLength(const Box& b) {
      // 访问私有成员 length
      std::cout << "Box length: " << b.length << std::endl;
  }
  
  int main() {
      Box b(10.5);
      printLength(b); // 调用友元函数
      return 0;
  }
  ```

  **输出：**

  ```
  Box length: 10.5
  ```

  ------

  #### **2. 友元类**

  友元类是另一个类，通过 `friend` 声明后，它可以访问当前类的私有和保护成员。

  ##### **语法**

  ```cpp
  class ClassName {
      friend class FriendClassName; // 声明一个友元类
  };
  ```

  ##### **示例**

  ```cpp
  #include <iostream>
  
  class Box {
  private:
      double length;
  
  public:
      Box(double len) : length(len) {}
  
      // 声明 Friend 类为友元类
      friend class BoxInspector;
  };
  
  class BoxInspector {
  public:
      void inspect(const Box& b) {
          // 访问 Box 的私有成员 length
          std::cout << "Inspecting Box length: " << b.length << std::endl;
      }
  };
  
  int main() {
      Box b(15.5);
      BoxInspector inspector;
      inspector.inspect(b); // 友元类访问 Box 的私有成员
      return 0;
  }
  ```

  **输出：**

  ```
  Inspecting Box length: 15.5
  ```

  ------

  #### **3. 友元函数模板**

  可以使用 `friend` 声明一个模板函数作为类的友元。

  ##### **示例**

  ```cpp
  #include <iostream>
  
  template <typename T>
  class Box {
  private:
      T length;
  
  public:
      Box(T len) : length(len) {}
  
      // 声明友元函数模板
      template <typename U>
      friend void printLength(const Box<U>& b);
  };
  
  template <typename U>
  void printLength(const Box<U>& b) {
      // 访问私有成员 length
      std::cout << "Box length: " << b.length << std::endl;
  }
  
  int main() {
      Box<int> b(42);
      printLength(b); // 调用友元函数模板
      return 0;
  }
  ```

  **输出：**

  ```
  Box length: 42
  ```

  ------

  ### **注意事项**

  1. **友元破坏封装性**：
     - 使用 `friend` 会破坏类的封装性，因此应谨慎使用，避免滥用友元。
  2. **友元不继承**：
     - 友元关系是单向的，不会被派生类继承。
     - 例如，如果类 `A` 是类 `B` 的友元，但类 `C` 派生自 `B`，`A` 无法访问 `C` 的私有成员。
  3. **友元关系是非对称的**：
     - 如果类 `A` 是类 `B` 的友元，`B` 并不会自动成为 `A` 的友元。
  4. **友元关系是非传递的**：
     - 如果类 `A` 是类 `B` 的友元，且类 `B` 是类 `C` 的友元，那么 `A` 并不是类 `C` 的友元。

  ------

  ### **友元的应用场景**

  1. **运算符重载**：

     - 友元函数常用于运算符重载，特别是需要访问类的私有成员时。

     - 示例：

       ```cpp
       #include <iostream>
       class Box {
       private:
           double length;
       
       public:
           Box(double len) : length(len) {}
       
           // 声明运算符重载函数为友元
           friend Box operator+(const Box& b1, const Box& b2);
       };
       
       Box operator+(const Box& b1, const Box& b2) {
           return Box(b1.length + b2.length);
       }
       
       int main() {
           Box b1(3.5), b2(4.5);
           Box b3 = b1 + b2;
           // 假设我们定义了一个成员函数用于打印长度
           return 0;
       }
       ```

  2. **调试工具**：

     - 用友元类或友元函数创建专门的调试工具，能直接访问目标类的私有成员。

  3. **复杂的对象之间协作**：

     - 当两个类需要共享内部实现细节，可以通过友元类简化协作逻辑。

  ------

  ### **总结**

  - **`friend` 的功能**：允许非成员函数或类访问类的私有和保护成员。

  - `friend` 的种类

    ：

    - 友元函数
    - 友元类
    - 友元模板

  - **谨慎使用**：虽然友元关键字很强大，但过度使用可能导致代码结构混乱，违反封装原则。



## 不变式

- gpt

  在面向对象编程中，**构造对象满足不变式**的意思是：对象在其生命周期内的**状态**始终满足某些预期的条件（或约束），这些条件被称为**类的不变式（class invariant）**。

  在 C++ 中，类的不变式通常指类的成员变量和状态在任何时候都保持逻辑上的一致性，而构造函数的作用是确保对象在被构造时立即进入一种**有效状态**，满足这些不变式。

  ------

  ### **什么是不变式？**

  **不变式（Invariant）** 是类的逻辑约束条件，这些条件在对象的生命周期中始终应该成立。
   例如：

  - 数学中的矩阵类可能要求行数和列数是正数。
  - 银行账户类要求余额不能小于零。

  **不变式的特点：**

  1. 在构造函数完成后，不变式应该成立。
  2. 在所有公共成员函数的调用完成后，不变式应该仍然成立。

  ------

  ### **构造函数中的不变式保证**

  当对象被创建时，构造函数应该：

  1. **初始化对象的成员变量**，确保对象处于逻辑上有效的状态。
  2. **满足类定义的不变式**，确保对象对外部使用是安全的。

  如果构造函数未能确保对象满足不变式，程序可能会在对象使用过程中表现出未定义行为，或导致逻辑错误。

  ------

  ### **示例：简单的不变式**

  假设有一个表示圆的类 `Circle`，要求：

  1. 半径必须为非负数。
  2. 面积和周长可以通过半径计算。

  ```cpp
  #include <iostream>
  #include <stdexcept>
  
  class Circle {
  private:
      double radius; // 半径，不变式要求 radius >= 0
  
  public:
      // 构造函数，确保 radius >= 0
      Circle(double r) : radius(r) {
          if (radius < 0) {
              throw std::invalid_argument("Radius cannot be negative");
          }
      }
  
      double getRadius() const { return radius; }
  
      // 成员函数，确保不变式仍然成立
      void setRadius(double r) {
          if (r < 0) {
              throw std::invalid_argument("Radius cannot be negative");
          }
          radius = r;
      }
  
      double getArea() const { return 3.14159 * radius * radius; }
      double getCircumference() const { return 2 * 3.14159 * radius; }
  };
  
  int main() {
      try {
          Circle c(-5); // 尝试创建半径为负的圆
      } catch (const std::invalid_argument& e) {
          std::cout << e.what() << std::endl; // 输出: "Radius cannot be negative"
      }
  
      Circle c(5);
      std::cout << "Area: " << c.getArea() << std::endl;
  
      return 0;
  }
  ```

  在这个例子中：

  - **不变式**：半径（`radius`）必须为非负值。
  - **构造函数**：检查并初始化半径，确保不变式成立。
  - **`setRadius`**：更新半径时也进行检查，以防止对象进入无效状态。

  ------

  ### **不变式的维护**

  1. **构造函数确保初始不变式**：对象在创建时，所有约束都应该满足。
  2. **公共方法的实现也应维护不变式**：对成员变量的任何修改，必须确保不变式继续成立。
  3. **析构函数无需关心不变式**：析构函数通常用于清理资源，不涉及逻辑约束。

  ------

  ### **不变式的实际意义**

  1. **防止无效对象**：
     - 构造函数确保对象初始状态正确。
     - 无需在每个使用对象的地方检查对象是否有效。
  2. **简化代码逻辑**：
     - 如果每个公共成员函数都确保操作后不变式成立，调用者可以确信对象始终处于有效状态。
  3. **异常安全性**：
     - 如果构造函数无法满足不变式，应抛出异常，防止创建无效对象。

  ------

  ### **更复杂的不变式**

  #### **示例：银行账户**

  一个银行账户类要求：

  - 余额必须为非负值。
  - `withdraw` 方法不能导致余额小于零。

  ```cpp
  #include <iostream>
  #include <stdexcept>
  
  class BankAccount {
  private:
      double balance; // 余额，不变式：balance >= 0
  
  public:
      // 构造函数，初始化余额并确保不变式成立
      BankAccount(double initialBalance) : balance(initialBalance) {
          if (balance < 0) {
              throw std::invalid_argument("Initial balance cannot be negative");
          }
      }
  
      double getBalance() const { return balance; }
  
      // 存钱，保持不变式
      void deposit(double amount) {
          if (amount < 0) {
              throw std::invalid_argument("Deposit amount cannot be negative");
          }
          balance += amount;
      }
  
      // 取钱，保持不变式
      void withdraw(double amount) {
          if (amount < 0) {
              throw std::invalid_argument("Withdraw amount cannot be negative");
          }
          if (amount > balance) {
              throw std::invalid_argument("Insufficient balance");
          }
          balance -= amount;
      }
  };
  
  int main() {
      BankAccount account(100);
  
      account.deposit(50); // 增加余额
      std::cout << "Balance: " << account.getBalance() << std::endl;
  
      account.withdraw(30); // 减少余额
      std::cout << "Balance: " << account.getBalance() << std::endl;
  
      try {
          account.withdraw(200); // 超额取款，抛出异常
      } catch (const std::invalid_argument& e) {
          std::cout << e.what() << std::endl; // 输出: "Insufficient balance"
      }
  
      return 0;
  }
  ```

  ------

  ### **总结**

  1. **构造对象满足不变式**：
     - 构造函数的任务是确保对象在创建时处于有效状态。
     - 任何破坏不变式的初始值或逻辑都应该通过检查或异常处理来避免。
  2. **不变式的维护**：
     - 不变式是类行为的核心约束，所有公共成员函数都应遵守并维护不变式。
  3. **实践意义**：
     - 使用不变式可以提高代码的健壮性和可维护性，减少潜在错误。



## 单参数构造函数 声明 explicit

- gpt

  在 C++ 中，单参数构造函数声明为 **`explicit`** 是为了避免**隐式转换**，从而提高代码的安全性和可读性。

  ------

  ### **问题背景**

  当类有一个单参数构造函数时，编译器会尝试使用它进行**隐式类型转换**。这可能导致意外的行为。

  #### 示例：隐式转换问题

  ```cpp
  #include <iostream>
  
  class MyClass {
  public:
      // 单参数构造函数
      MyClass(int x) {
          std::cout << "MyClass constructor called with x = " << x << std::endl;
      }
  };
  
  void printMyClass(const MyClass& obj) {
      std::cout << "printMyClass called" << std::endl;
  }
  
  int main() {
      MyClass obj1 = 42; // 隐式调用构造函数，创建 MyClass 对象
      printMyClass(7);   // 隐式类型转换：int -> MyClass
  
      return 0;
  }
  ```

  **输出：**

  ```
  MyClass constructor called with x = 42
  MyClass constructor called with x = 7
  printMyClass called
  ```

  **问题：**

  - 编译器自动使用单参数构造函数将 `42` 和 `7` 转换为 `MyClass` 对象。
  - 如果程序逻辑复杂，可能引入意料之外的错误。

  ------

  ### **`explicit` 的作用**

  将单参数构造函数声明为 **`explicit`**，可以禁止这种隐式转换，要求调用者必须显式调用构造函数。

  #### 示例：`explicit` 的使用

  ```cpp
  #include <iostream>
  
  class MyClass {
  public:
      // 单参数构造函数声明为 explicit
      explicit MyClass(int x) {
          std::cout << "MyClass constructor called with x = " << x << std::endl;
      }
  };
  
  void printMyClass(const MyClass& obj) {
      std::cout << "printMyClass called" << std::endl;
  }
  
  int main() {
      MyClass obj1 = 42; // 错误：不能进行隐式转换
      MyClass obj2(42);  // 正确：显式调用构造函数
      printMyClass(7);   // 错误：不能隐式转换 int -> MyClass
      printMyClass(MyClass(7)); // 正确：显式调用构造函数
  
      return 0;
  }
  ```

  **输出：**

  ```
  MyClass constructor called with x = 42
  MyClass constructor called with x = 7
  printMyClass called
  ```

  ------

  ### **`explicit` 的优点**

  1. **防止意外隐式转换**：
     - 隐式转换可能导致难以察觉的逻辑错误。
     - 使用 `explicit` 明确要求程序员对构造函数的调用负责。
  2. **增强代码可读性**：
     - 明确表达了程序员的意图，避免模糊的语义。
  3. **提高安全性**：
     - 禁止自动类型转换，减少程序运行时意外行为的可能性。

  ------

  ### **什么时候使用 `explicit`？**

  1. **单参数构造函数**：尤其是那些有可能被错误用作隐式转换的构造函数。
  2. **防止类型误用的场景**：例如避免将基本类型直接转化为复杂对象。

  ------

  ### **总结**

  - 单参数构造函数如果不加 `explicit`，编译器会尝试隐式转换，可能导致意外行为。
  - 使用 `explicit` 禁止隐式转换，要求调用者显式调用构造函数，提高代码的安全性和可读性。
  - **推荐规则**：除非明确需要隐式转换，否则单参数构造函数应加 `explicit`。
