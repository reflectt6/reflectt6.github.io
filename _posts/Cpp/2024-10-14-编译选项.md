---
layout: page-with-sidebar
title:  "编译选项"
date:   2024-10-09 9:47:03 +0800
author: reflectt6
categories: "C和C++"
mainTag: "编程基础"
secondaryTag: "C和C++"
hideTag: false

---

### -Wl, --whole-archive

- gpt

  `-Wl, --whole-archive` 是 GCC（GNU Compiler Collection）中的一个链接器选项，用于控制静态库的链接行为。这两个选项是传递给 GNU 链接器 `ld` 的，`-Wl,` 让编译器将后续的选项直接传递给链接器，而 `--whole-archive` 则是链接器选项本身。

  ### 1. `-Wl,` 选项
  `-Wl,` 是 GCC 的一个特殊选项，用于指示编译器将其后面的选项传递给链接器。例如：

  ```bash
  gcc -Wl,--whole-archive -o my_program my_objects.o -lmylib -Wl,--no-whole-archive
  ```

  在这条命令中，`--whole-archive` 和 `--no-whole-archive` 选项被传递给链接器，而不是由 GCC 自己处理。

  ### 2. `--whole-archive`
  `--whole-archive` 是 GNU 链接器的一个选项，用于告诉链接器将指定的静态库的 **所有** 对象文件都链接到最终的可执行文件或共享库中，而不仅仅是那些被显式引用的符号。

  通常，链接器在处理静态库时会采用一种按需加载的策略。也就是说，链接器只会从静态库中提取那些被当前程序需要的符号（即引用的函数或变量），而未引用的部分则不会被包含在最终的可执行文件中。这样可以减少生成文件的大小。

  `--whole-archive` 选项改变了这一默认行为。它告诉链接器从指定的静态库中提取 **所有** 的对象文件并将它们全部包含到最终的可执行文件中，即使它们没有被显式引用。

  #### 示例：
  ```bash
  gcc -o my_program my_objects.o -Wl,--whole-archive -lmylib -Wl,--no-whole-archive
  ```

  在这个例子中：
  - `--whole-archive` 告诉链接器把 `libmylib.a` 静态库中的所有对象文件都包含到 `my_program` 中。
  - `--no-whole-archive` 恢复默认的链接行为，即之后的库只按需链接。

  ### 3. `--no-whole-archive`
  `--no-whole-archive` 是与 `--whole-archive` 配对的选项，它将链接行为恢复到默认模式，即按需从静态库中提取符号。这通常用来在需要某些静态库被完全链接后，继续正常处理其他静态库。

  #### 为什么使用 `--whole-archive`？
  1. **静态库中的全局构造函数**：有时库中的全局构造函数或其他重要符号可能不会被显式引用，但你仍然需要它们被包含在最终的可执行文件或共享库中。使用 `--whole-archive` 可以确保它们被包含。
     
  2. **所有对象文件的强制链接**：如果你需要确保库的所有对象文件都被链接到可执行文件中，而不管是否被引用，`--whole-archive` 是一个好方法。比如，某些情况下，静态库中的对象文件可能包含初始化逻辑，这些逻辑在不显式引用时也必须被包含进来。

  ### 小结
  - `-Wl,` 用于让 GCC 将选项传递给链接器。
  - `--whole-archive` 告诉链接器将整个静态库中的所有对象文件都链接到输出文件中，无论它们是否被显式引用。
  - `--no-whole-archive` 恢复默认的按需链接行为，确保之后的库不会被完全包含。

  这种选项组合在需要强制链接静态库的所有部分时非常有用，比如某些库的全局初始化、构造函数或特殊的符号。
