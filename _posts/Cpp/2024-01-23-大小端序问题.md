---
layout: page-with-sidebar
title:  "大小端序问题"
date:   2024-01-23 9:47:03 +0800
author: reflectt6
categories: "C和C++"
mainTag: "C/C++"
secondaryTag: ""
---

## 什么是大小端序？

大端序（Big-endian）和小端序（Little-endian）是指在多字节数据类型的存储中，字节的排列顺序的两种不同规定。

1. **大端序（Big-endian）：** 在大端序中，多字节数据类型的最高有效字节（Most Significant Byte，MSB）存储在最低的内存地址，而最低有效字节（Least Significant Byte，LSB）存储在最高的内存地址。这种字节序的存储方式类似于书写数字时，高位在前，低位在后。

   示例：对于十六进制数 `0x12345678`，在大端序中存储为：

   ```
   0x12 0x34 0x56 0x78
   ```

2. **小端序（Little-endian）：** 在小端序中，多字节数据类型的最低有效字节（LSB）存储在最低的内存地址，而最高有效字节（MSB）存储在最高的内存地址。这种字节序的存储方式类似于书写数字时，低位在前，高位在后。

   示例：对于十六进制数 `0x12345678`，在小端序中存储为：

   ```
   0x78 0x56 0x34 0x12
   ```

在计算机体系结构中，x86 和 x86-64 等架构通常采用小端序，而一些其他架构如 SPARC 和 PowerPC 则采用大端序。网络协议通常规定使用大端序，因此在进行网络通信时，需要注意字节序的转换。



## Java和大小端有关系吗？

这个我不好说，毕竟Java有一套自己的虚拟机，也许在虚拟机里面可以实现与操作系统不同的大小端序，但是我们可以通过简单的程序测试一下：

```java
long a = (long)Math.pow(2,32); // 4294967296
byte b = (byte)(a >> 32); // 1
long c = (long)Math.pow(2,33); // 8589934592
byte d = (byte)(c >> 32); // 2
```

java中long类型占8个字节，2的32次方的二进制表示是一个1后面32个零。放在8字节的long类型中就是第四个字节的最后一位是1，而第五、六、七、八字节都是0，这时候我们将整个long类型右移4个字节，如果是大端序，那么结果应该是1，如果是小端序，那么结果应该是0；

经过测试，在windows下java是大端序。

不过我还是有点不确定，于是问了chat gpt：

Java 使用网络字节序（big-endian）来表示多字节数据类型，这与大端序（big-endian）相同。网络字节序是一种规范，要求在网络通信中使用大端序，以确保不同计算机体系结构之间的数据交换正确。

由JVM来保证大小端序，确实可以做到，合理！



## C++使用什么端序？

Java可以通过JVM保证大小端序，C++只能依赖操作系统本身，而操作系统本身的大小端序各不相同。

所以C++没有确定的端序，在程序中常使用宏来判断，现在的系统是个什么序，例如rocksdb源码port_posix.h中就有判断大小端序的宏

```c++
#define PLATFORM_IS_LITTLE_ENDIAN \
  (__DARWIN_BYTE_ORDER == __DARWIN_LITTLE_ENDIAN)
```

chat gpt：

C++ 并没有规定使用特定的字节序，它是由底层硬件架构决定的。不同的计算机体系结构可能使用大端序（big-endian）或小端序（little-endian），或者其他一些字节序。

通常来说，x86 和 x86-64 架构使用小端序，而一些其他体系结构如 SPARC 和 PowerPC 则使用大端序。因此，在编写 C++ 代码时，尤其是涉及网络通信、文件存储或与其他系统交互时，需要谨慎处理字节序的问题。



