---
layout: page-with-sidebar
title:  "编程规范"
date:   2023-12-20 9:47:03 +0800
author: reflectt6
categories: "C和C++"
mainTag: "编程基础"
secondaryTag: "C和C++"
hideTag: false
---

## 保证静态类型安全



## 尽量避免void*类型参数



## 枚举

unscoped enum 没有默认的潜在类型，编译器会根据情况选一个最小的类型。因此在将int值转化为普通枚举（unscoped enum）可能出现超出枚举类型表示范围的情况。因此当使用这种枚举时推荐手动设置潜在类型。

```c++
// unscoped enum
enum Color : int ; // 编程规范推荐 加上int 作为潜在类型，防止编译器将它优化成更小的类型，否则在表达式转枚举时容易出错。
enum Font : int {F1, F2}; // 没有默认的潜在类型，需要编译器推导一个最小类型
enum Font2 : int {F2, F3}; // 报错 unscoped enum作用域在全局 ， 两个F2会命名冲突

// scoped enum
enum class Font {F1, F2}; // 不用加潜在类型，默认的潜在类型就是int
enum class Font2 {F2, F3}; // 不报错 两个F2的作用域分别在Font和Font2中，不冲突
```





## 命名

由于我比较熟悉Java，这里和Java编程规范对比着来

c++中：命名空间、类、结构体、联合体、枚举类型、typedef定义的类型、类型别名 都和java中的类、枚举一样使用大驼峰

c++中的函数使用大驼峰，而java中使用小驼峰（有区别）

C++中全局变量建议使用g_前缀加上小驼峰，而java中仅使用小驼峰（有区别）

C++中枚举值、常量使用全大写但下划线分割的命名方式：如QQQ_WWW，而java中一般不回去分割（有区别）

| **类别**         | **C++**            | **Java**                                                     |
| ---------------- | ------------------ | ------------------------------------------------------------ |
| **函数**         | 大驼峰             | 小驼峰                                                       |
| **全局变量**     | 带'g_'前缀的小驼峰 | 小驼峰（java不存在脱离class的全局变量，只有class内的静态变量） |
| **枚举值、常量** | 全大写，下划线分割 | 全大写，下划线分割                                           |
| **宏，goto标签** | 全大写，下划线分割 | -                                                            |

注：C++的常量指全局范围内的对象，使用constexpr、const修饰



## 头文件职责

头文件中 定义内联函数、（c++17支持）定义内联变量（全局的）

cpp文件定义 函数



## C++ 11 支持\{\} 初始化后 优先使用\{\}初始化

- 窄式转化检查

  \{\}初始化会检查窄式转换

  用=或()初始化时，不会检查

- 避免语法解析歧义

  ```c++
  Font a();//Font的默认构造函数和 函数声明冲突了，会被解释为一个函数，而不是一个类对象；
  Font b{};//使用大括号构造对象 免除歧义
  ```

  

- 更强的通用性

  =或()在一些场景下不能用于初始化，而\{\}一直可以

- 使用()规避Std::initializer_list的重载构造

  这段代码中，`std::vector` 的初始化方式通过花括号 `{}` 和圆括号 `()` 表示不同的语义，具体含义如下：

  ------

  ### **代码逐一分析**

  ```cpp
  std::vector<int> v1{5};
  ```

  - 解释

    ：

    - 使用花括号 `{}`，表示列表初始化。
    - `v1` 被初始化为包含一个元素 `5` 的向量，等效于 `std::vector<int> v1 = {5};`。

  - 效果

    ：

    - 向量内容：`v1 = {5}`。
    - 向量大小：`v1.size() == 1`。

  ------

  ```cpp
  std::vector<int> v2(5);
  ```

  - 解释

    ：

    - 使用圆括号 `()`，表示构造函数调用。
    - `v2` 被初始化为包含 5 个默认值（`int` 类型默认值为 0）的向量。

  - 效果

    ：

    - 向量内容：`v2 = {0, 0, 0, 0, 0}`。
    - 向量大小：`v2.size() == 5`。

  ------

  ```cpp
  std::vector<int> v3{1, 2};
  ```

  - 解释

    ：

    - 使用花括号 `{}`，表示列表初始化。
    - `v3` 被初始化为包含两个元素 `1` 和 `2` 的向量。

  - 效果

    ：

    - 向量内容：`v3 = {1, 2}`。
    - 向量大小：`v3.size() == 2`。

  ------

  ```cpp
  std::vector<int> v4(1, 2);
  ```

  - 解释

    ：

    - 使用圆括号 `()`，表示构造函数调用。
    - `v4` 被初始化为包含 1 个元素的向量，该元素的值为 `2`。
    - 构造函数语义：第一个参数是向量大小，第二个参数是初始化值。

  - 效果

    ：

    - 向量内容：`v4 = {2}`。
    - 向量大小：`v4.size() == 1`。

  ------

  ### **总结对比**

  | 初始化方式           | 示例代码                    | 初始化语义                             | 向量内容          | 向量大小 |
  | -------------------- | --------------------------- | -------------------------------------- | ----------------- | -------- |
  | **列表初始化**       | `std::vector<int> v1{5};`   | 初始化为包含一个元素 `5` 的向量        | `{5}`             | `1`      |
  | **构造函数调用**     | `std::vector<int> v2(5);`   | 初始化为包含 5 个 `0` 的向量           | `{0, 0, 0, 0, 0}` | `5`      |
  | **列表初始化多个值** | `std::vector<int> v3{1,2};` | 初始化为包含两个元素 `1` 和 `2` 的向量 | `{1, 2}`          | `2`      |
  | **带大小和初值**     | `std::vector<int> v4(1,2);` | 初始化为 1 个元素的向量，值为 `2`      | `{2}`             | `1`      |

  ------

  ### **注意事项**

  - 花括号 

    ```
    {}
    ```

     和圆括号 

    ```
    ()
    ```

     的语义是不同的：

    - `{}` 更倾向于列表初始化，直接初始化内容。
    - `()` 调用构造函数，语义可能因参数数量不同而变化。

  - 避免混淆：对于类似 `std::vector<int> v{5}` 和 `std::vector<int> v(5)` 的初始化，理解语义非常重要，以免产生误解。

- s





## 未定义的行为

c++中有许多未定义的行为，一旦你的代码做出了该行为，那么程序可能做出任何非预期反应。

- [i++ + i++ 为什么是未定义的行为](https://www.coonote.com/c-note/i-jiajia.html)
- 除0
- 越界访问
- new数组，delete时却没有加[ ]
- 等。。。





## 尽量使用c++标准库而不是c标准库

```c++
// c 标准库
#include <stdlib.h>

// c++ 标准库
#include <cstdlib.h>
```



## 高风险函数

- alloc、realloc

  ### **1. `realloc` 和 `alloca` 的作用**

  两者都是 C 标准库中用来管理内存的函数，但它们有不同的用途和特性：

  | **函数**  | **作用**                                                     |
  | --------- | ------------------------------------------------------------ |
  | `realloc` | 用于调整已分配的动态内存块的大小，并可能将数据迁移到新的内存位置。 |
  | `alloca`  | 在 **栈上** 分配内存，分配的内存块在函数返回时自动释放（与动态内存分配不同）。 |

  ------

  ### **2. `realloc`**

  #### **作用**

  - **重新分配内存**：用于调整已分配内存块的大小（增加或减少）。

  - 如果需要更大的内存且当前块无法扩展，

    ```
    realloc
    ```

     会：

    1. 分配一个新的内存块。
    2. 将旧内存的数据复制到新内存。
    3. 释放旧内存。

  #### **函数签名**

  ```c
  void* realloc(void* ptr, size_t size);
  ```

  - 参数

    ：

    - `ptr`：指向要重新分配的内存块（由 `malloc` 或 `realloc` 分配）。
    - `size`：新的内存大小（以字节为单位）。

  - 返回值

    ：

    - 成功：指向新内存块的指针。
    - 失败：`NULL`，原内存块保持不变。

  ------

  #### **用法示例**

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  
  int main() {
      int* arr = (int*)malloc(5 * sizeof(int)); // 分配初始内存
      if (!arr) {
          perror("malloc failed");
          return 1;
      }
  
      for (int i = 0; i < 5; i++) {
          arr[i] = i + 1; // 初始化数组
      }
  
      // 调整内存大小以容纳更多元素
      int* newArr = (int*)realloc(arr, 10 * sizeof(int));
      if (!newArr) {
          perror("realloc failed");
          free(arr); // realloc 失败时需要释放原内存
          return 1;
      }
  
      arr = newArr; // 更新指针
      for (int i = 5; i < 10; i++) {
          arr[i] = i + 1; // 初始化新分配的元素
      }
  
      for (int i = 0; i < 10; i++) {
          printf("%d ", arr[i]);
      }
      printf("\n");
  
      free(arr); // 释放内存
      return 0;
  }
  ```

  #### **注意事项**

  1. 如果 `size == 0`，`realloc` 等效于 `free(ptr)`。
  2. 如果 `ptr == NULL`，`realloc` 等效于 `malloc(size)`。
  3. 调用 `realloc` 后，原内存块可能会被释放，旧指针不再有效。

  ------

  ### **3. `alloca`**

  #### **作用**

  - 在栈上分配内存，分配的内存会在当前函数返回时自动释放。
  - **不需要手动释放内存**，分配的内存块生命周期与函数调用一致。

  #### **函数签名**

  ```c
  void* alloca(size_t size);
  ```

  - 参数

    ：

    - `size`：要分配的内存大小（字节数）。

  - 返回值

    ：

    - 成功：返回指向分配内存的指针。
    - 失败：未定义行为（通常是栈溢出）。

  ------

  #### **用法示例**

  ```c
  #include <stdio.h>
  #include <alloca.h>
  
  void example(int n) {
      // 在栈上分配数组
      int* stackArray = (int*)alloca(n * sizeof(int));
      for (int i = 0; i < n; i++) {
          stackArray[i] = i + 1; // 初始化数组
      }
  
      for (int i = 0; i < n; i++) {
          printf("%d ", stackArray[i]);
      }
      printf("\n");
  
      // 不需要调用 free，内存会在函数返回时自动释放
  }
  
  int main() {
      example(5);
      example(10);
      return 0;
  }
  ```

  #### **注意事项**

  1. 生命周期限制

     ：

     - 分配的内存仅在当前函数调用期间有效，函数返回后内存会自动释放。
     - 尝试在函数外部使用分配的内存会导致 **未定义行为**。

  2. 栈溢出风险

     ：

     - `alloca` 使用栈空间，分配过大的内存会导致栈溢出（`stack overflow`）。

  3. 可移植性

     ：

     - 并非所有系统都支持 `alloca`，其行为可能与实现相关（属于扩展函数，不在标准 C 中）。

  ------

  ### **4. 对比 `realloc` 和 `alloca`**

  | **特性**         | **`realloc`**                      | **`alloca`**                 |
  | ---------------- | ---------------------------------- | ---------------------------- |
  | **内存分配位置** | 堆                                 | 栈                           |
  | **内存生命周期** | 需要手动释放（调用 `free`）        | 随函数调用结束自动释放       |
  | **灵活性**       | 可以扩展或收缩已有内存块           | 仅在函数调用期间有效         |
  | **性能**         | 较慢（堆分配和释放需要管理器参与） | 较快（栈分配直接调整栈指针） |
  | **内存大小限制** | 大小受堆的可用内存限制             | 大小受栈的限制（通常较小）   |
  | **可移植性**     | 完全标准 C                         | 属于扩展函数，部分系统不支持 |

  ------

  ### **5. 总结**

  - `realloc`

    ：

    - 用于调整动态分配的堆内存的大小，适合需要灵活调整内存大小的场景。
    - 手动管理生命周期，注意释放内存以避免内存泄漏。

  - `alloca`

    ：

    - 在栈上分配内存，分配和释放效率更高，适合短生命周期且小规模的临时内存需求。
    - 注意栈溢出风险，且不适用于跨函数使用内存的场景。

  合理选择 `realloc` 或 `alloca`，可以帮助更高效地管理内存资源。

- exec系列函数 

  ### **Exec 系列函数**

  `exec` 系列函数属于 POSIX 标准，提供了在当前进程中 **加载并执行另一个程序** 的能力。
   当一个进程调用 `exec` 系列函数时，**当前进程的地址空间会被新程序完全替换**，包括代码段、数据段和堆栈。
   唯一保持不变的是 **进程的 PID**（进程 ID）和一些资源（如打开的文件描述符，取决于设置）。

  ------

  ### **1. `exec` 系列函数的概述**

  #### **头文件**

  所有 `exec` 函数都定义在 `<unistd.h>` 中。

  #### **函数类型**

  `exec` 系列包括以下六个函数：

  - `execl`
  - `execle`
  - `execlp`
  - `execv`
  - `execve`
  - `execvp`

  ------

  ### **2. 函数原型和参数说明**

  #### **(1) `execl`**

  ```c
  int execl(const char *path, const char *arg0, ..., NULL);
  ```

  - **功能**：执行指定路径的程序，传递参数列表。

  - 参数

    ：

    - `path`：要执行程序的路径。
    - `arg0`：程序的第一个参数，通常是程序名。
    - 后续参数为程序需要的命令行参数，必须以 `NULL` 结尾。

  - **示例**：

  ```c
  execl("/bin/ls", "ls", "-l", "/home", NULL);
  ```

  ------

  #### **(2) `execle`**

  ```c
  int execle(const char *path, const char *arg0, ..., NULL, char *const envp[]);
  ```

  - **功能**：类似 `execl`，但允许显式指定环境变量。

  - 参数

    ：

    - 除了和 `execl` 类似的参数外，最后一个参数 `envp` 是环境变量数组。

  - **示例**：

  ```c
  char *envp[] = {"PATH=/bin", NULL};
  execle("/bin/ls", "ls", "-l", "/home", NULL, envp);
  ```

  ------

  #### **(3) `execlp`**

  ```c
  int execlp(const char *file, const char *arg0, ..., NULL);
  ```

  - **功能**：与 `execl` 类似，但会通过 `PATH` 环境变量自动搜索可执行文件的位置。

  - 参数

    ：

    - `file`：要执行的程序名（不需要完整路径）。

  - **示例**：

  ```c
  execlp("ls", "ls", "-l", "/home", NULL);
  ```

  ------

  #### **(4) `execv`**

  ```c
  int execv(const char *path, char *const argv[]);
  ```

  - **功能**：执行指定路径的程序，传递参数数组。

  - 参数

    ：

    - `path`：要执行程序的路径。
    - `argv`：参数数组，`argv[0]` 通常是程序名，最后一个元素必须是 `NULL`。

  - **示例**：

  ```c
  char *args[] = {"ls", "-l", "/home", NULL};
  execv("/bin/ls", args);
  ```

  ------

  #### **(5) `execve`**

  ```c
  int execve(const char *path, char *const argv[], char *const envp[]);
  ```

  - **功能**：最底层的 `exec` 函数，可同时指定参数和环境变量。

  - 参数

    ：

    - `path`：要执行程序的路径。
    - `argv`：参数数组。
    - `envp`：环境变量数组。

  - **示例**：

  ```c
  char *args[] = {"ls", "-l", "/home", NULL};
  char *envp[] = {"PATH=/bin", NULL};
  execve("/bin/ls", args, envp);
  ```

  ------

  #### **(6) `execvp`**

  ```c
  int execvp(const char *file, char *const argv[]);
  ```

  - **功能**：类似 `execv`，但会通过 `PATH` 环境变量搜索可执行文件。

  - 参数

    ：

    - `file`：可执行文件名（不需要完整路径）。
    - `argv`：参数数组。

  - **示例**：

  ```c
  char *args[] = {"ls", "-l", "/home", NULL};
  execvp("ls", args);
  ```

  ------

  ### **3. 执行失败的情况**

  - 如果 `exec` 系列函数执行失败，会返回 `-1`，并设置 `errno` 以说明错误原因。
  - 常见原因：
    1. 文件路径错误。
    2. 可执行文件不存在或没有执行权限。
    3. 参数或环境变量数组设置错误。

  ------

  ### **4. 执行特点**

  1. 覆盖进程

     ：

     - 调用 `exec` 后，当前进程的所有代码和数据会被新程序覆盖。
     - 当前进程不会继续执行调用 `exec` 之后的代码。

  2. 共享 PID

     ：

     - 执行新程序时，PID 不会改变，仍然是当前进程的 PID。

  3. 返回值

     ：

     - 如果执行成功，`exec` 不会返回；只有失败时才会返回 `-1`。

  ------

  ### **5. `exec` 系列函数的对比**

  | **函数** | **参数类型** | **环境变量**       | **路径搜索** |
  | -------- | ------------ | ------------------ | ------------ |
  | `execl`  | 可变参数     | 使用调用进程的环境 | 不搜索       |
  | `execle` | 可变参数     | 显式指定环境变量   | 不搜索       |
  | `execlp` | 可变参数     | 使用调用进程的环境 | 搜索 `PATH`  |
  | `execv`  | 参数数组     | 使用调用进程的环境 | 不搜索       |
  | `execve` | 参数数组     | 显式指定环境变量   | 不搜索       |
  | `execvp` | 参数数组     | 使用调用进程的环境 | 搜索 `PATH`  |

  ------

  ### **6. 示例：在子进程中调用 `exec`**

  ```c
  #include <unistd.h>
  #include <stdio.h>
  #include <stdlib.h>
  
  int main() {
      pid_t pid = fork();
  
      if (pid == 0) { // 子进程
          execlp("ls", "ls", "-l", NULL);
          perror("execlp failed");
          exit(1);
      } else if (pid > 0) { // 父进程
          wait(NULL); // 等待子进程完成
          printf("Child process completed.\n");
      } else {
          perror("fork failed");
          exit(1);
      }
  
      return 0;
  }
  ```

  **输出**：

  ```
  文件列表（由 `ls -l` 命令生成）
  Child process completed.
  ```

  ------

  ### **7. 总结**

  - `exec` 系列函数用于执行新程序，是进程控制的核心功能之一。

  - 根据需要选择适合的函数：

    - 参数形式：可变参数（`execl`）或数组（`execv`）。
    - 环境变量：默认继承（`execl`）或显式设置（`execle`）。
    - 路径搜索：需要自动搜索（`execlp`）还是提供完整路径（`execl`）。

  - 使用时注意

    ：

    - 调用 `exec` 后当前进程代码将被覆盖，调用之后的代码不会执行。
    - 必须验证返回值处理可能的失败情况。
