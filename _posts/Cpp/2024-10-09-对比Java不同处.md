---
layout: page-with-sidebar
title:  "对比JAVA不同处"
date:   2024-10-09 9:47:03 +0800
author: reflectt6
categories: "C和C++"
mainTag: "编程基础"
secondaryTag: "C和C++"
hideTag: false

---

## 创建对象

### JAVA创建对象

- 先说java，在java中除了静态成员、静态函数、静态类等静态的不需要手动创建外（JVM自动创建，全局保证只存在一份）。其他的对象均使用new关键字来创建

  ```java
  // 直接创建出一个Apple对象
  Apple a = new Apple();
  ```


### C++创建对象

- C++中有几种创建对象的方式

  在C++中，创建对象有多种方式，不同的方式会影响对象的生命周期、内存分配、销毁时机等。下面将详细讲解C++中创建对象的几种常见方式，以及每种方式的特点和适用场景。

  ### 1. **栈上创建对象**
  这是最常见的创建对象方式，使用类名和对象变量名即可。

  ```cpp
  A a;
  ```

  #### 特点：
  - **自动管理内存**：对象位于栈上，作用域结束时，C++会自动调用析构函数并释放内存。
  - **高效**：栈上的内存分配和释放速度快，通常比堆分配更高效。
  - **生命周期**：对象的生命周期与作用域相关，超出作用域时自动销毁。

  #### 示例：
  ```cpp
  class A {
  public:
      A() { std::cout << "Constructor called\n"; }
      ~A() { std::cout << "Destructor called\n"; }
  };
  
  int main() {
      A a;  // 栈上创建对象a
      return 0;  // 离开作用域时，a自动销毁
  }
  ```

  #### 适用场景：
  当对象的生命周期在某个函数或块的作用域内时，适合使用栈上对象，因为不需要手动管理内存。

  ### 2. **堆上创建对象（动态分配）**
  通过 `new` 关键字在堆上创建对象，需要使用 `delete` 释放内存。

  ```cpp
  // 和java不同，c++创建出来的是一个对象指针
  A* a = new A();
  ```

  #### 特点：
  - **动态分配**：对象位于堆上，生命周期不受函数或块的作用域限制。
  - **手动管理内存**：创建的对象需要显式调用 `delete` 释放内存，否则会导致内存泄漏。
  - **灵活性**：对象可以在程序的任何地方存在，直到显式销毁。

  #### 示例：
  ```cpp
  class A {
  public:
      A() { std::cout << "Constructor called\n"; }
      ~A() { std::cout << "Destructor called\n"; }
  };
  
  int main() {
      A* a = new A();  // 堆上创建对象
      delete a;  // 手动销毁对象，释放内存
      return 0;
  }
  ```

  #### 适用场景：
  当对象需要跨多个作用域或者在运行时动态决定时，适合使用堆上对象。但是使用堆对象时必须小心管理内存，防止内存泄漏。

  ### 3. **使用智能指针**
  智能指针是C++11引入的工具，用于自动管理堆对象的生命周期，避免手动调用 `delete`。常见的智能指针包括 `std::unique_ptr` 和 `std::shared_ptr`。

  #### a. **`std::unique_ptr`**
  `std::unique_ptr` 表示唯一拥有的指针，即某个对象只能被一个 `unique_ptr` 所拥有。对象在指针销毁时自动释放。

  ```cpp
  std::unique_ptr<A> ptr = std::make_unique<A>();
  ```

  #### 特点：
  - **自动释放内存**：当智能指针超出作用域时，自动调用析构函数并释放内存。
  - **所有权唯一**：一个对象只能被一个 `unique_ptr` 管理，不能被复制。

  #### 示例：
  ```cpp
  #include <memory>
  
  class A {
  public:
      A() { std::cout << "Constructor called\n"; }
      ~A() { std::cout << "Destructor called\n"; }
  };
  
  int main() {
      std::unique_ptr<A> ptr = std::make_unique<A>();  // 使用智能指针管理对象
      return 0;  // 离开作用域时，智能指针自动释放对象
  }
  ```

  #### b. **`std::shared_ptr`**
  `std::shared_ptr` 允许多个智能指针共享同一个对象，当最后一个 `shared_ptr` 被销毁时，对象才会被释放。

  ```cpp
  std::shared_ptr<A> ptr1 = std::make_shared<A>();
  std::shared_ptr<A> ptr2 = ptr1;  // ptr1 和 ptr2 共享对象
  ```

  #### 特点：
  - **引用计数**：`shared_ptr` 通过引用计数管理对象，只有当引用计数为0时，才销毁对象。
  - **适合共享对象**：多个指针可以共享同一个对象的所有权。

  #### 示例：
  ```cpp
  #include <memory>
  
  class A {
  public:
      A() { std::cout << "Constructor called\n"; }
      ~A() { std::cout << "Destructor called\n"; }
  };
  
  int main() {
      std::shared_ptr<A> ptr1 = std::make_shared<A>();  // 创建shared_ptr
      std::shared_ptr<A> ptr2 = ptr1;  // ptr2 共享 ptr1 的对象
      return 0;  // 当最后一个指针销毁时，对象才会被释放
  }
  ```

  #### 适用场景：
  - `unique_ptr` 适用于需要独占对象所有权的情况。
  - `shared_ptr` 适用于多个对象共享资源的情况。

  ### 4. **拷贝创建对象**
  通过已有对象来创建新对象，称为拷贝构造。C++提供了默认的拷贝构造函数，但也可以自定义。

  ```cpp
  A a1;
  A a2 = a1;  // 拷贝构造a2
  ```

  #### 特点：
  - **浅拷贝与深拷贝**：默认的拷贝构造是浅拷贝（简单地复制对象成员的值），如果对象包含指针类型成员，可能需要实现深拷贝（复制指针指向的内容）。
  - **自定义拷贝构造函数**：可以定义自己的拷贝构造函数以满足特定需求。

  #### 示例：
  ```cpp
  class A {
  public:
      int x;
      A(int value) : x(value) {}
      
      // 自定义拷贝构造函数
      A(const A& other) {
          x = other.x;
          std::cout << "Copy constructor called\n";
      }
  };
  
  int main() {
      A a1(10);
      A a2 = a1;  // 使用拷贝构造函数
      return 0;
  }
  ```

  ### 5. **通过类的静态成员函数创建对象**
  有时候我们会使用类的静态成员函数来创建和管理对象。这种方式常用于工厂模式（Factory Pattern），即通过一个静态方法来返回一个新创建的对象。

  ```cpp
  class A {
  public:
      static A create() {
          return A();  // 返回一个A类对象
      }
  };
  
  int main() {
      A a = A::create();  // 通过静态成员函数创建对象
      return 0;
  }
  ```

  #### 特点：
  - 适合用来控制对象创建的过程，特别是在工厂模式中使用。
  - 可以隐藏构造函数的细节，通过静态方法返回对象。

  ### 6. **使用C++的对象数组**
  创建对象数组时，多个对象会在同一时刻创建并使用默认构造函数初始化。

  ```cpp
  A arr[5];  // 创建包含5个A对象的数组
  ```

  #### 示例：
  ```cpp
  class A {
  public:
      A() {
          std::cout << "Constructor called\n";
      }
  };
  
  int main() {
      A arr[3];  // 创建3个A类对象
      return 0;
  }
  ```

  #### 适用场景：
  当需要同时创建多个对象时，使用对象数组是一个方便的选择。

  ### 总结
  C++中创建对象的几种方式包括：
  1. **栈上创建**：自动管理内存，离开作用域时自动销毁。
  2. **堆上创建**：动态分配内存，需要手动释放，适合需要控制生命周期的对象。
  3. **智能指针**：通过 `unique_ptr` 和 `shared_ptr` 来管理堆对象的生命周期，避免手动管理内存。
  4. **拷贝创建**：通过拷贝构造函数创建对象，适合复制已有对象的场景。
  5. **静态成员函数创建**：通过类的静态方法创建对象，常用于工厂模式。
  6. **对象数组**：用于同时创建多个对象。

  每种方式都有其特定的应用场景，选择合适的方式可以使代码更加高效、可维护。

  

## 对比堆栈模型

| **方面**         | **C++ 堆栈模型**             | **JVM 堆栈模型**                     |
| ---------------- | ---------------------------- | ------------------------------------ |
| **栈上存储**     | 局部变量、对象、函数调用信息 | 局部变量、原始数据类型、对象引用     |
| **堆上存储**     | 动态分配的对象（需手动管理） | 所有对象都在堆上，自动管理           |
| **内存管理**     | 栈自动管理，堆需手动管理     | 栈自动管理，堆通过垃圾回收器自动管理 |
| **垃圾回收**     | 无自动垃圾回收（需手动管理） | 自动垃圾回收，程序员不显式释放内存   |
| **对象创建位置** | 可以在栈或堆上创建对象       | 所有对象都在堆上，通过栈引用         |
| **线程模型**     | 栈是线程私有，堆是共享的     | 栈是线程私有，堆是共享的             |





## 命名

| **类别**         | **C++**            | **Java**           |
| ---------------- | ------------------ | ------------------ |
| **函数**         | 大驼峰             | 小驼峰             |
| **全局变量**     | 带'g_'前缀的小驼峰 | 小驼峰             |
| **枚举值、常量** | 全大写，下划线分割 | 全大写，下划线分割 |
| **宏，goto标签** | 全大写，下划线分割 | -                  |

注：C++的常量指全局范围内的对象，使用constexpr、const修饰
