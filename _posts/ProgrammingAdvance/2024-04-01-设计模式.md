---
layout: page-with-sidebar
title:  "设计模式"
date:   2024-04-01 9:47:03 +0800
author: reflectt6
categories: "编程基础"
mainTag: "编程基础"
secondaryTag: "模型工程"
hideTag: false
---

## 23种设计模式

创建型

- 单例模式
- 工厂模式
- 抽象工厂模式
- 建造者模式
- 原型模式

结构型

- 代理模式
- 桥接模式
- 装饰器模式
- 适配器模式
- 门面模式
- 组合模式
- 享元模式

行为型

- 观察者模式
- 模版模式
- 策略模式
- 责任链模式
- 状态模式
- 迭代器模式
- 访问者模式
- 备忘录模式
- 命令模式
- 解释器模式
- 中介模式



## 尝试一句话概括一种设计模式

### 创建型（4种）

- 单例模式

  1、进程内唯一，进程间不一定唯一。可以使用ThreadLocal实现线程内唯一、线程间不一定唯一。可以使用文件锁，实现集群内的单例模式

  2、几种实现：饿汉、懒汉、双重检测、静态内部类、枚举

  饿汉不支持延迟加载、懒汉不支持高并发，双重检测可以解决这个问题

  ```java
  import java.util.concurrent.atomic.AtomicLong;
  // 既可以延迟加载，也能支持并发
  public class IdGenerator {
      private AtomicLong id = new AtomicLong(0);
      private static IdGenerator instance;
  
      private IdGenerator() {
      }
  
      public static IdGenerator getInstance() {
          if (instance == null) {
              synchronized (IdGenerator.class) {
                  if (instance == null) {
                      instance = new IdGenerator();
                  }
              }
          }
          return instance;
      }
  
      public long getId() {
          return id.incrementAndGet();
      }
  }
  ```

  内部静态类可以借用java内在机制，快速实现类似双重检测方法的效率

  ```java
  import java.util.concurrent.atomic.AtomicLong;
  
  public class IdGenerator2 {
      private AtomicLong id = new AtomicLong(0);
  
      private IdGenerator2() {}
  
      private static class SingletonHolder {
          private static final IdGenerator2 instance = new IdGenerator2();
      }
  
      public static IdGenerator2 getInstance() {
          return SingletonHolder.instance;
      }
      public long getId() {
          return id.incrementAndGet();
      }
  }
  ```

  

- 工厂模式

  - 通过逻辑代码，自动创建不同的类对象

- 抽象工厂模式

  - 工厂的工厂，核心思想在于解耦。比如gluten中的SparkPlanExecApi等

- 建造者模式

  - 最常见的protobuf，广泛使用该模式。你看创建protobuf都需要创建一个Builder对象，然后通过链式写法，`builder.set().set()......build()`

  - 这样做的好处在于，当创建一个类的构造参数过多时，很容易传错。于是我们使用set方法去设置类的成员变量。

  - 考虑更复杂的情况，如果成员变量之间存在依赖关系，或者有些成员是必填项，有些是可选项，这样我们使用set（）也容易遗漏或者出错。这时候使用Builder建造者模式，可以在建造者内部写校验逻辑，这样你set出问题的时候，builder会报错提示你。

- 原型模式

  - 创建对象一般是很快，但是如果对象的构造参数需要从磁盘、网络或者是计算得来，那么创建对象的成本就比较高了。这时候如果有一个原型，我们只需要复制原型对象的成员变量就可以了。这样我们只需要获取成员变量中存在差异的部分即可，减少构建时间。


### 结构型（7种）

- 代理模式
  - 分静态代理和动态代理
  - 目的是不改动原先代码的情况下，给老代码增加新功能（常用常见有metrics、缓存）
  - 当代理类过多时，考虑使用反射实现动态代理

- 桥接模式
  - 比较抽象，组合优于继承的思路，将复杂的部分拆成两个独立的类，组合起来

- 装饰器模式
  - 和代理模式类似，也是不改动原先代码的情况下，增加新功能
  - 区别在于：
    - 装饰器类和原始类继承自同一个父类，表示对原始类功能的增强（景上添花，例如InputStream的装饰类BufferedInputStream，可以看看java IO源码）
    - 代理类不用和原始类继承同一个类，而且代理类一般的功能是原始类没有的（雪中送碳）

- 适配器模式
  - 最近做的项目中，spark-extend-omni-adpator就是一种适配器模式，他将spark的执行计划转化为统一接口中的substrait模型。
  - 这种适配统一接口的代码，一般都是适配器模式，就是为了适配某个规范，而对原有代码做一些修改。

- 门面模式
  - 就是为了适配某些场景，把几个接口组合封装起来做成新接口。也就是新的门面。（让子系统更易用）

- 组合模式
  - 主要处理树形结构的数据，表示一种“部分-整体”的层次结构，比如linux中的文件系统，采用目录、文件的树形结构就是一种组合模式。

- 享元模式
  - 被共享的单元，比如Integer类中的-128到127就是享元对象，你创建的`Integer i = 127`实际上是IntegerCache初始化时就缓存好的。


### 行为型（11种）

- 观察者模式
  - 也叫发布订阅模式

- 模版模式
- 策略模式
- 责任链模式
- 状态模式
- 迭代器模式
- 访问者模式
- 备忘录模式
- 命令模式
- 解释器模式
- 中介模式



## 设计模式细节







[资料1](https://design-patterns.readthedocs.io/zh-cn/latest/)

资料2 设计模式之美 - 王争

