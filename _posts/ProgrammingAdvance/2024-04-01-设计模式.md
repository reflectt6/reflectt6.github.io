---
layout: page-with-sidebar
title:  "设计模式"
date:   2024-04-01 9:47:03 +0800
author: reflectt6
categories: "模型工程"
mainTag: "编程高级"
secondaryTag: "模型工程"
hideTag: false
---

## 23种设计模式

创建型

- 单例模式
- 工厂模式
- 抽象工厂模式
- 建造者模式
- 原型模式

结构型

- 代理模式
- 桥接模式
- 装饰器模式
- 适配器模式
- 门面模式
- 组合模式
- 享元模式

行为型

- 观察者模式
- 模版模式
- 策略模式
- 责任链模式
- 状态模式
- 迭代器模式
- 访问者模式
- 备忘录模式
- 命令模式
- 解释器模式
- 中介模式



## 尝试一句话概括一种设计模式

### 创建型（4种）

- 单例模式

  1、进程内唯一，进程间不一定唯一。可以使用ThreadLocal实现线程内唯一、线程间不一定唯一。可以使用文件锁，实现集群内的单例模式

  2、几种实现：饿汉、懒汉、双重检测、静态内部类、枚举

  饿汉不支持延迟加载、懒汉不支持高并发，双重检测可以解决这个问题

  ```java
  import java.util.concurrent.atomic.AtomicLong;
  // 既可以延迟加载，也能支持并发
  public class IdGenerator {
      private AtomicLong id = new AtomicLong(0);
      private static IdGenerator instance;
  
      private IdGenerator() {
      }
  
      public static IdGenerator getInstance() {
          if (instance == null) {
              synchronized (IdGenerator.class) {
                  if (instance == null) {
                      instance = new IdGenerator();
                  }
              }
          }
          return instance;
      }
  
      public long getId() {
          return id.incrementAndGet();
      }
  }
  ```

  内部静态类可以借用java内在机制，快速实现类似双重检测方法的效率

  ```java
  import java.util.concurrent.atomic.AtomicLong;
  
  public class IdGenerator2 {
      private AtomicLong id = new AtomicLong(0);
  
      private IdGenerator2() {}
  
      private static class SingletonHolder {
          private static final IdGenerator2 instance = new IdGenerator2();
      }
  
      public static IdGenerator2 getInstance() {
          return SingletonHolder.instance;
      }
      public long getId() {
          return id.incrementAndGet();
      }
  }
  ```

  

- 工厂模式

  - 通过逻辑代码，自动创建不同的类对象

- 抽象工厂模式

  - 工厂的工厂，核心思想在于解耦。比如gluten中的SparkPlanExecApi等

- 建造者模式

  - 最常见的protobuf，广泛使用该模式。你看创建protobuf都需要创建一个Builder对象，然后通过链式写法，`builder.set().set()......build()`

  - 这样做的好处在于，当创建一个类的构造参数过多时，很容易传错。于是我们使用set方法去设置类的成员变量。

  - 考虑更复杂的情况，如果成员变量之间存在依赖关系，或者有些成员是必填项，有些是可选项，这样我们使用set（）也容易遗漏或者出错。这时候使用Builder建造者模式，可以在建造者内部写校验逻辑，这样你set出问题的时候，builder会报错提示你。

- 原型模式

  - 创建对象一般是很快，但是如果对象的构造参数需要从磁盘、网络或者是计算得来，那么创建对象的成本就比较高了。这时候如果有一个原型，我们只需要复制原型对象的成员变量就可以了。这样我们只需要获取成员变量中存在差异的部分即可，减少构建时间。


### 结构型（7种）

- 代理模式
  - 分静态代理和动态代理
  - 目的是不改动原先代码的情况下，给老代码增加新功能（常用常见有metrics、缓存）
  - 当代理类过多时，考虑使用反射实现动态代理

- 桥接模式
  - 比较抽象，组合优于继承的思路，将复杂的部分拆成两个独立的类，组合起来

- 装饰器模式
  - 和代理模式类似，也是不改动原先代码的情况下，增加新功能
  - 区别在于：
    - 装饰器类和原始类继承自同一个父类，表示对原始类功能的增强（景上添花，例如InputStream的装饰类BufferedInputStream，可以看看java IO源码）
    - 代理类不用和原始类继承同一个类，而且代理类一般的功能是原始类没有的（雪中送碳）

- 适配器模式
  - 最近做的项目中，spark-extend-omni-adpator就是一种适配器模式，他将spark的执行计划转化为统一接口中的substrait模型。
  - 这种适配统一接口的代码，一般都是适配器模式，就是为了适配某个规范，而对原有代码做一些修改。

- 门面模式
  - 就是为了适配某些场景，把几个接口组合封装起来做成新接口。也就是新的门面。（让子系统更易用）

- 组合模式
  - 主要处理树形结构的数据，表示一种“部分-整体”的层次结构，比如linux中的文件系统，采用目录、文件的树形结构就是一种组合模式。

- 享元模式
  - 被共享的单元，比如Integer类中的-128到127就是享元对象，你创建的`Integer i = 127`实际上是IntegerCache初始化时就缓存好的。


### 行为型（11种）

- 观察者模式

  - 也叫发布订阅模式
  - 常见的命名有：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener
  - 在对象之间定义一个一对多的依赖，当对象状态改变，所有依赖的对象都会自动收到通知
  - 感觉最难理解的一个模式，没有之一

- 模版模式

  - 固定大的流程不变，每个流程中具体怎么实现需要开发者自己去做。这种模式就是模版模式。用户可以在不修改框架代码的情况下，定制化框架的功能。
  - 和模版模式类似功能的还有 -- 回调

- 策略模式

  - 事先定义好几个策略，用户可以根据条件灵活的为对象选择使用哪一个策略

- 责任链模式

  - 将一个处理流程分成多个步骤，每个类负责其中一个步骤，像一条流水线一样，从前到后一次处理
  - Spark中对于Spark Plan有很多优化规则（Rules），这些规则就是从前到后依次作用在Spark plan上，最后得到一个优化好的执行计划，其实这就是责任链模式。

- 状态模式

  - 定义多个状态，每个状态实现自己的行为逻辑。在一段逻辑中，用户只需要切换状态就可以改变相应的行为逻辑。

- 迭代器模式（Iterator Design Pattern）

  - 也叫游标模式（Cursor Design Pattern）
  - 这可能时最容易见到的设计模式了，很多数据结构都支持Iterator，一般都得有个hasNext方法和next方法
  - 好处在于：
    - 1、封装遍历逻辑，使用者无需了解细节即可完成遍历
    - 2、将遍历操作从集合类拆分到迭代器类，职责单一
    - 3、添加新的遍历算法更容易，符合开闭原则。
    - 4、基于接口而非实现编程，替换迭代器更容易

- 访问者模式
  - 核心思路在于将`对某一类对象的操作`提取出来封装成一个`行为类`（符合开闭原则，新增行为不需要改以前的代码，而且新增行为类即可），每个行为类中，实现对于不同对象的操作。由于java是single dispatch，所以你在编译时无法确定传给行为类的对象（抽象类）具体是个什么类型，这样导致编译无法通过。通过给对象类添加accept方法，将行为类通过入参传入，然后通过传入的行为类条用对象类本身，这时候对象类的是知道自己是个什么类型的，因此规避之前的问题。（我知道这么讲，没人看得懂，但是代码太多，懒得敲了，后面再补）

  - 这个模式的实现，其实我也是见过不少的，spark源码、gluten源码（MemoryTarget）中都有accept的影子，当时不理解这样做有啥用。但是现在知道了，其实就是将操作和操作发起者解耦了。

- 备忘录模式

  - 在不违背封装的原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象先前的状态。
  - 这样看，序列化应该就是备忘录模式，hbase中wsl也是备忘录模式

- 命令模式

  - 将`请求（命令）`封装成一个对象，这样可以使用不同的`请求命令`参数化其他对象，并且能支持`请求命令`的排队执行、记录日志、撤销等功能
  - 实际上就是lambda表达式，将函数参数化

- 解释器模式

  - 为某个语言定义他的语法解析规则，核心思想也是解耦，将大的语法解析工作拆分成多个小的语法解析器，然后组合起来
  - antlr4是一个创建语法树的开源项目，将g4文件解析为语法树就是解释器模式

- 中介模式

  - `当控件之间存在多对多的关系时，控件之间的行为相互影响，互相依赖，会导致代码耦合性很高`，这时候我们使用一个中介类，所有控件都和中介类交互，可以简化代码之间耦合性。
  - 弊端在于中介类可能会是个上帝类（god class），大而全导致违反开闭原则。这时候就要平衡耦合和开闭原则，找到更合适的方案。
  - 举个例子：
    - 天上的飞机需要时时互通路线，如果每个飞机之间互相通信就很复杂，但是每个飞机通过同一个中介（塔台）互相通信，就会简单很多
    - 代码的例子，前端页面存在多个可交互的控件，点击其中一个控件，其他相关控件也会做出相应变化。如果控件之间互相调用，会导致代码耦合。这时候我们可以通过中介类完成各个控件的交互


  - 中介模式 vs 观察者模式
    - TODO

## 设计模式细节

### 访问者模式（代码版）

### 观察者模式（代码版）





[资料1](https://design-patterns.readthedocs.io/zh-cn/latest/)

资料2 设计模式之美 - 王争

