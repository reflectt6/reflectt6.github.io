---
layout: page-with-sidebar
title:  "位运算与Java差异"
date:   2023-12-21 9:47:03 +0800
author: reflectt6
categories: "C和C++"
#permalink: 
mainTag: "C/C++"
secondaryTag: ""
---

## 位移运算符差异

### 无符号位移

`无符号位移的核心就是不把最高位当成符号位。这样就很好理解了。如果最高位是符号位，那么不应该将这一位参与运算；如果最高位不是符号位，那么理应参与运算`

Java中存在三种位移运算符，分别为无符号右移、右移、左移: `>>>`、`>>`、`<<`

而C++中只存在两个位移运算符（至少标准库中只有两个），分别为右移和左移：　`>>`、`<<`

不光如此，在运算细节上也有差异，为了方便只测试了Byte类型，也就是8字节的数据类型：

```C++
// C++测试
int main() {
    uint8_t a = 7;
    uint8_t b = -2;
    int8_t c = 7;
    int8_t d = -2;
    
    std::cout << (a << 9) << std::endl; // 3584
    std::cout << (b >> 1) << std::endl; // 127
    std::cout << (b >> 1 << 3) << std::endl; // 1016
    std::cout << (d >> 9) << std::endl; // -1
    std::cout << (d << 9) << std::endl; // -1024
}
// -2 以补码形式存储，补码就是正数的机器码按位取反，再末位加一
// 2 的机器码是 00000010
// -2 的补码形式是 11111110
// 计算过程是 00000010 ——》 11111101 ——》11111110
```

![image-20231221101323836](/assets/images/2023-12-21-位运算与Java差异//image-20231221101323836.png)

从测试中我们可以得知，对于C++来说：

1、有符号数的`>>`是有符号位移、无符号数的`>>`操作是无符号位移

```java
// Java测试
public static void main(String[] args) {
    byte a = 7;
    byte b = -2;
    System.out.println(b >>> 1); // 2147483647
    System.out.println(b >> 1); // -1
    System.out.println(b >> 3); // -1
    System.out.println(b << 9); // -1024
}
```

经过两次测试我们总结一下C++和Java位移运算的异同点：

共同点：

1、两种语言实际上都支持三种位移运算：无符号右移、右移、左移。只不过C++是否无符号位移是根据数据类型是不是无符号来确定的，Java中存在`>>>`正是由于Java中没有无符号数据类型导致的。

```shell
System.out.println(b >>> 1); // 2147483647  对标（无符号右移）  std::cout << (b >> 1) << std::endl; // 127
System.out.println(b >> 1); // -1           对标（有符号右移）  std::cout << (d >> 9) << std::endl; // -1
System.out.println(b << 9); // -1024        对标（有符号左移）  std::cout << (d << 9) << std::endl; // -1024
```

2、由于位移之前将byte类型转为int，所以两种语言在位移之后都超出了原有的数据类型的表示范围

3、操作数进行`有符号`位移操作之前会被转化为int类型,两种语言的转化是一样的，例如负数-2的补码为11111110。

两者都是在前面补1，变成：1111111...111 11111110。

补1好处就是，在扩充位数的基础上，表示的值不变。

不同点：

1、操作数进行`无符号`位移操作之前会被转化为int类型。但是两种语言的`转化思路`有差异，例如-2的补码为11111110。

在java中将其转为int类型之后变成：1111111...111 11111110

在C++中将其转为int类型之后变成：0000000...000 11111110

区别是Java会在前面补1。乍一看认为C++的处理更好。那么Java错了吗？其实也没有。。我们再考虑以下内容

两种语言的处理思路其实都是希望类型转化完之后，位数变多了，但是表示的数不变。

在C++中我们给uint8_t类型赋值为-2，实际上是有点问题的，因为无符号数无法表示负数，我们给他赋值了-2，但实际上，我们给他赋值的是254(0b11111110)。基于此我们在看两种语言的转化思路：

1、Java转化为：1111111...111 11111110，我们要知道Java中的都是有符号的数，那么这个数是多少呢？答案是-2

2、C++转化为：0000000...000 11111110，这是个无符号int数，那么这个数是多少呢？答案是254

在转化之前他们分别是多少呢？

1、Java 转化前就是-2

2、C++转化前，虽然我们赋值时写了-2，但由于无符号数无法表示负数，实际上我们赋值的是254.

此时看两种语言的转化，发现非常合理！

### 有符号右移

`有符号右移的策略两者都是一致的，可以当作是位移完成之后，在空出来的高位补齐符号位的数值，也就是负数全补1，正数全补0`

