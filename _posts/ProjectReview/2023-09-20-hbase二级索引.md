---
layout: page-with-sidebar
title:  "HBase二级索引！"
date:   2023-09-20 19:47:03 +0800
author: reflectt6
categories: "项目回顾"
mainTag: "项目回顾"
secondaryTag: "公司项目"
hideTag: true
---

## 简介

hbase原生通过B-Tree存储rowkey值，相当于对于默认对rowkey设置了索引。但却不支持多级索引。而实际的应用场景中，常常需要设置多级索引，来优化查寻性能。

二级索引就是由此而孕育而生的功能。实际上在传统数据库中，二级索引并不陌生。但是在hbase支持不是太好。官方有推荐，需要用户自己通过mr任务创建二级索引表，然后定时通过mr任务去更新索引表，保证一致性。这种方式显然比较烦人。官方还推荐了另外一种二级索引的实现方式，就是通过Coprocessor来实现。这种方式对于用户有一定的使用门槛，需要用户通过编程实现二级索引。

一般的公司是不愿意花时间和人力去使用Coprocessor实现二级索引的功能的，因为这中间涉及到需求的确认，以及后续的迭代管理，这对于一个关注业务的公司是不能承受之重。这一点Apache基金会自然也知道，于是便有了Phoenix这个项目。

Phoenix是基于HBase做的一个插件项目。他使用Coprocessor实现了HBase的二级索引功能。除此之外，Phoenix最大的意图在于使能大数据的平台（hbase等）使其支持传统数据库的特性。例如在hbase这个nosql的平台上实现了ACID事务管理、支持SQL语法等。

[相关资料](https://zhuanlan.zhihu.com/p/43972378)

## 项目背景

由于用Phoenix，那就必须要使用相应的sql语法，操作流程等都要做较大改变。对于一些用户来讲，可能涉及到业务切换。而我们大数据组希望将二级索引的功能，以插件形式，对HBase原有功能做一个增强。不改变HBase本身的使用逻辑。

## 全局Or本地

二级索引从实现原理上分为全局二级索引和局部二级索引，华为云在前些年实现过hindex，属于本地二级索引，现在补全了全局索引的实现。下面介绍一下两者的区别：

### 全局二级索引

全局二级索引会把索引单独建一张表。所有针对数据表的插入、删除等操作，在实际执行之前会先进行计算，得出索引的rowKey和对应的列值（例如状态列0:x、覆盖索引列）。由于我们实现的就是全局二级索引，下面我展开讲讲细节。

举个例子，数据表为data，他对应一张索引表index。

- 执行 `put 'data', 'row1', 'cf_0:q_0', 'v100'`向数据表data中插入一列数据，列族为cf_01，列名为q_0，rowkey为row1，值为v100

- 在hbase中，插入、删除等操作以batch为单位进行处理，尽管你只输入了一个插入操作，在代码中，他也以batch数组存储，只不过数组长度为1。范型为Mutation，在HBase中插入、追加、删除、自增都是Mutation的子类。

- 在处理这个batch数组之前，会被我们自定义的RegionCoprocessor接管，生成一个preIndexUpdates和一个postIndexUpdates，分别代表在batch执行之前要先执行的操作，和在batch执行之后再执行的操作。

- 根据phoenix对于全局二级索引的设计，再pre阶段，我们会插入一个状态位为无效位的索引值。在post阶段，我们会更新索引行状态位为有效位。这种设计就是为了使得在pre、batch执行、post三个阶段中，某一个阶段失败，数据也能正常（状态位为无效位的索引不会被使用）。关于这种三段式的设计，pheonix给出了[详细的说明](https://engineering.salesforce.com/the-design-of-strongly-consistent-global-secondary-indexes-in-apache-phoenix-part-1-90b90bda4210/)

- 再来谈谈普通索引和覆盖索引的区别

  - 普通索引：数据表的值都存在索引表的行健中
  - 覆盖索引：数据表的值存在索引表的同名列中

  这里涉及到了索引rowKey的设计，比如有个关键问题，如何确定分隔符来划分索引行健中的数据。因为数据表中可能存在和分割符一样的数据，这时你在解析行健的时候如何界定分隔符和数据。

  我提出了一种解决方案：使用标志位记录索引行健中包含了数据表多少列的数据，以及对应的偏移。据此来解析rowkey。

  同事提出了一个新的问题：hbase索引的行健是要排序的。我在开头放标志位，会影响索引行的排序，使得索引行的顺序与数据本身无关了。这导致在scan索引的时候，无法优化（排好序的行，在scan未命中时可以使用二分法等方式优化搜索性能）。

  于是我又提出了将标志位放在最后的解决方案。。

- 这就是全局二级索引的主要实现，由于全局二级索引将索引数据存在新的表中，因此在读索引的时候，都从同一张表中读，可以很快定位到对应的region。适合读操作多的场景。

### 本地二级索引

本地二级索引会把索引数据存储在数据表所在位置，（在华为云的hindex本地二级索引中，本地索引的rowKey是以当前region的startKey开头，后面加value、时间戳等拼接而成），这样索引数据就会被写入当前region了（因为以当前region的startKey开头）。而HBase会根据region的大小进行split，新增的索引会导致原有的region 进行分裂，因此，本地索引的加入会使原本的数据表的region数增加。在不用索引时，跨region查询的概率增加；并且本地二级索引也会污染源数据表；且在scan时，不容易找到本地索引的位置。因此本地二级索引不适合查数据多的场景，适合写数据多的场景。

## 项目实现

### put/delete索引数据生成

生成三段式的任务计划，其中涉及到了并发场景下，如何保证数据一致性，这部分实现主要参考自phoenix。

#### 生成三段式任务的设计思路

因为索引表和数据表要保持一致，所以处理思路要参考数据表。

首先我们先看看数据表在做完这个操作之后会变成什么，在操作之前是什么样的。根据这两个状态，去判断索引应该做什么操作。

#### 解决并发问题的思路

首先明确下，并发场景下，哪里会出问题。三段式计划其中的pre和post会对新的索引行做一个新增操作，会对旧的索引数据做删除操作。在并发场景下，如果不做特殊处理，那么程序会对旧的索引数据产生误解，例如有五个并发同时要生成三段式任务，他们觉得旧的数据都是同一个，然后他们都要删除这个旧的数据，删除了5次，这个倒是没什么，但是他们新增了五个有效的索引行，这就会导致数据一致性问题了。

然后思考下，哪里需要加锁，我们在拿到mutaion后，就可以生成对应的三段式计划了，为了不让线程对旧的数据产生误解，我们需要对这个旧的数据维护一个数据结构。第一个线程来了，旧的数据是从索引表中读出来的；第二个以及以后的线程，这个旧的数据不应该再读表了，应该读我们维护起来的这个数据结构。

因此我们对生成三段式的过程加锁，后一个线程在生成三段式任务时，他的旧数据应该是前一个任务的新数据。

### 索引一致性检查工具

使用mapreduce实现，默认执行两个任务，一个以数据表为源表对索引表进行对比扫描；以索引表为源表对数据表进行对比扫描。

可选项，进行索引修复，从性能角度来看，使用工具修复索引，不如重建索引，只提供了这个选项。

### 视图的crud

视图的创建、删除、更新等操作，需要知会hregionserver的协处理器。我们自己定义一个客户端，通过特殊的命令告诉客户端要进行视图的crud，客户端把我们的指令变成一个RPC请求。而HRegionServer的协处理器还实现RPC请求中service的Interface接口。通过grpc框架，客户端的请求会被我们的协处理器接受，并且处理。

而HBase master对于任务的处理用到了HBase的Procedure类型，用法参考AssignmentManager

