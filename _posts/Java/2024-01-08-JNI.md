---
layout: page-with-sidebar
title:  "JNI"
date:   2024-01-08 9:47:03 +0800
author: reflectt6
categories: "C和C++"
mainTag: "C/C++"
secondaryTag: ""
---

## [JNI](https://zhuanlan.zhihu.com/p/650000825)

JNI提供java代码和本地代码的双向调用接口，也就是说可以通过java调本地代码，也可以通过本地代码调用java代码。



### 简单示例

本示例意图探索如何在一个java为主的项目中嵌入native代码，并对项目结构做了一些优化

![image-20240108164614526](/assets/images/2024-01-08-JNI//image-20240108164614526.png)

首先正常创建java类JNISimpleDemo

```java
package org.example;

public class JNISimpleDemo {
    private native void print();
    public static void main(String[] args) {
        new JNISimpleDemo().print();
    }

    static {
        System.load("/[绝对路径]/libSimpleDemo.so");
    }
}
```

为了使项目结构更清晰，我们给java目录的创建一个平级目录native，进入native目录打开终端,

```shell
# 生成class文件
javac -d . ../java/org/example/JNISimpleDemo.java
# 生成本地方法头文件
javah -jni -cp . org.example.JNISimpleDemo
```

生成的头文件如下：org_example_JNISimpleDemo.h

```c++
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class org_example_JNISimpleDemo */

#ifndef _Included_org_example_JNISimpleDemo
#define _Included_org_example_JNISimpleDemo
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     org_example_JNISimpleDemo
 * Method:    print
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_org_example_JNISimpleDemo_print
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

此时我们自己实现一个c文件：SimpleDemo.cc

```c++
#include <jni.h>
#include <stdio.h>
#include "org_example_JNISimpleDemo.h"

JNIEXPORT void JNICALL Java_org_example_JNISimpleDemo_print(JNIEnv *env, jobject obj)
{
	printf("Hello World!\n");
	return;
}
```

接着使用命令行进行编译

```shell
gcc -I $JAVA_HOME/include/ -I $JAVA_HOME/include/darwin SimpleDemo.cc -shared -o -fPIC -o libSimpleDemo.so
```

将生成的so文件的绝对路径传给System.load，运行java程序，看到HelloWord字样，说明Demo已成功写完！



### 进阶示例

探索复杂类型，java和c++对象如何转化与共享，首先正常创建Java类

```java
package org.example;

import java.nio.charset.StandardCharsets;

// 探索复杂结构如何使用JNI
public class JNIAdvancedDemo {
    static {
        System.load("【动态库的绝对路径】");
    }
    private static native void nativeAdd(NameReceiver nr, String name);

    public static void main(String[] args) {
        NameReceiver nr = new NameReceiver();
        nr.addName("XiaoLi");
        nr.addName("XiaoWang");
        nr.addName("AHo");
        nativeAdd(nr, "LiYou");
        System.out.println(nr.query(3));
    }
}

class NameReceiver {
    int count;
    int maxCnt;
    String[] names;
    byte[][] matrix;

    NameReceiver() {
        count = 0;
        maxCnt = 100;
        names = new String[100];
        matrix = new byte[100][];
    }

    void addName(String name) {
        if (count == maxCnt - 1) {
            throw new RuntimeException("exceed max count");
        }
        matrix[count] = name.getBytes(StandardCharsets.UTF_8);
        names[count] = name;
        count++;
    }

    String query(int index) {
        if (index <= 0) return names[0];
        else if (index >= count) return names[count];
        else return names[index];
    }
}
```

为了使项目结构更清晰，我们给java目录的创建一个平级目录advanced-native，进入advanced-native目录打开终端,

```shell
# 生成class文件
javac -d . ../java/org/example/JNIAdvancedDemo.java
# 生成本地方法头文件
javah -jni -cp . org.example.JNIAdvancedDemo
```

此时生成头文件org_example_JNIAdvancedDemo.h

```C++
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class org_example_JNIAdvancedDemo */

#ifndef _Included_org_example_JNIAdvancedDemo
#define _Included_org_example_JNIAdvancedDemo
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     org_example_JNIAdvancedDemo
 * Method:    nativeAdd
 * Signature: (Lorg/example/NameReceiver;Ljava/lang/String;)V
 */
JNIEXPORT void JNICALL Java_org_example_JNIAdvancedDemo_nativeAdd
  (JNIEnv *, jclass, jobject, jstring);

#ifdef __cplusplus
}
#endif
#endif
```

我们自己写一个org_example_JNIAdvancedDemo.cpp文件，实现nativeAdd方法，目标就是将NameReceiver对象和一个String对象传递给native代码，在native代码中完成NameReceiver对象的AddName函数操作。最后在main方法中观察，nativa方法对于对象的操作是否影响Java对象。

```C++
//
// Created by Rain Night on 2024/1/10.
//

#include "org_example_JNIAdvancedDemo.h"

/*
 * Class:     org_example_JNIAdvancedDemo
 * Method:    nativeAdd
 * Signature: (Lorg/example/NameReceiver;Ljava/lang/String;)V
 */
JNIEXPORT void JNICALL Java_org_example_JNIAdvancedDemo_nativeAdd
        (JNIEnv * env, jclass jc, jobject jo, jstring js) {
    // 获取类引用
    jclass nrClass = env->GetObjectClass(jo);

    // 获取字段ID
    jfieldID maxCntField = env->GetFieldID(nrClass, "maxCnt", "I");
    jfieldID countField = env->GetFieldID(nrClass, "count", "I");

    // 获取字段值
    jint maxCnt = env->GetIntField(jo, maxCntField);
    jint count = env->GetIntField(jo, countField);

    // 在本地代码中使用字段值
    printf("Value of maxCnt: %d\n", maxCnt);
    printf("Value of count: %d\n", count);

    // 调用Java方法
    jmethodID addNameMethod = env->GetMethodID(nrClass, "addName", "(Ljava/lang/String;)V");
    env->CallVoidMethod(jo, addNameMethod, js);
}
```

编译成动态库

```shell
gcc -I $JAVA_HOME/include/ -I $JAVA_HOME/include/darwin org_example_JNIAdvancedDemo.cpp -shared -o -fPIC -o libJNIAdvancedDemo.so
```

开始测试，首先在调用native方法之前，我先加入了三个名称

![image-20240110114332701](/assets/images/2024-01-08-JNI//image-20240110114332701.png)

接着，调用native方法，再观察，发现第四个名称已经被加入进去了

![image-20240110114435759](/assets/images/2024-01-08-JNI//image-20240110114435759.png)

豁然开朗！



### 进阶示例2

在HBase源码中新增UT，比较java版本的bloom和c++版本的ribbon性能差异。首先找到BloomChunk的UT

`/hbase/hbase-server/src/test/java/org/apache/hadoop/hbase/util/TestBloomFilterChunk.java`

在UT末尾添加测试代码：

```java
@Test
public void testBloomChunkAndRibbon() throws Exception {
  BloomFilterChunk bfc = BloomFilterUtil.createBySize(128 * 1024, (float)0.01, 1, 7, BloomType.ROW);
  bfc.allocBloom();
  int keyNum = 109306;
  byte[][] keys = new byte[keyNum * 2][];
  String[] keys2 = new String[keyNum * 2];
  for (int i = 0; i < keyNum * 2; i++) {
    keys[i] = Bytes.toBytes("this is a much larger byte array" + i * 0.618);
    keys2[i] = "this is a much larger byte array" + i * 0.618;
  }

  // test for bloom
  for (int i = 0; i < keyNum; i++) {
    bfc.add(keys[i], 0, keys[i].length);
  }
  for (int i = 0; i < keyNum; i++) {
    assertTrue(BloomFilterUtil.contains(keys[i], 0, keys[i].length, new MultiByteBuff(bfc.bloom), 0,
      (int) bfc.byteSize, bfc.hash, bfc.hashCount));
  }
  int fpCount = 0;
  for (int i = keyNum; i < 2 * keyNum; i++) {
    if (BloomFilterUtil.contains(keys[i], 0, keys[i].length, new MultiByteBuff(bfc.bloom), 0,
      (int) bfc.byteSize, bfc.hash, bfc.hashCount) == true) {
      fpCount++;
    }
  }
  System.out.println("bloom fp rate = " + 0.1 * fpCount / keyNum);


  // test for ribbon
  System.load("");
  RibbonHelper ribbonHelper = new RibbonHelper();
  ribbonHelper.initRibbonFilter();
  for (int i = 0; i < keyNum; i++) {
    ribbonHelper.addKey(keys2[i]);
  }
  ribbonHelper.backSubst();
  for (int i = 0; i < keyNum; i++) {
    assertTrue(ribbonHelper.filterQuery(keys2[i]));
  }
  int fpCount2 = 0;
  for (int i = keyNum; i < 2 * keyNum; i++) {
    if (ribbonHelper.filterQuery(keys2[i])) {
      fpCount++;
    }
  }
  System.out.println("ribbon fp rate = " + 0.1 * fpCount2 / keyNum);
}
```

在`/hbase/hbase-server/src/test/java/org/apache/hadoop/hbase/util/`路径下，新建RibbonHelper.java

```java
public class RibbonHelper {
  public native void initRibbonFilter(int size);
  public native boolean addKey(String s);
  public native void backSubst();
  public native boolean filterQuery(String s);
  public native boolean printDuration();
  public native void close();
}
```

在`/hbase/hbase-server/src/test/`目录下新建native文件夹，进入native文件夹打开终端

```shell
# 生成class文件
javac -d . ../java/org/apache/hadoop/hbase/util/RibbonHelper.java
# 生成本地方法头文件
javah -jni -cp . org.apache.hadoop.hbase.util.RibbonHelper
```

生成的头文件不展示了，我们创建org_apache_hadoop_hbase_util_RibbonHelper.cpp文件，实现一下头文件里的方法

```c++
//
// Created by Rain Night on 2024/1/11.
//
#include "org_apache_hadoop_hbase_util_RibbonHelper.h"
#include <chrono>

using TypeParam = Settings_Coeff128_Homog;
IMPORT_RIBBON_TYPES_AND_SETTINGS(TypeParam);
IMPORT_RIBBON_IMPL_TYPES(TypeParam);

// 全局变量声明
InterleavedSoln *isoln = nullptr;
Banding *banding = nullptr;
Hasher *hasher = nullptr;
double addDurationMs;
double queryDurationMs;
double backSubstMs;
double stringToCharsMs;
double initMs;

/*
 * Class:     org_apache_hadoop_hbase_util_RibbonHelper
 * Method:    initRibbonFilter
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_org_apache_hadoop_hbase_util_RibbonHelper_initRibbonFilter
        (JNIEnv *, jobject, jint ji) {
    auto start_time = std::chrono::high_resolution_clock::now();

//    Index num_slots = 131072;
    Index num_slots = static_cast<uint32_t>(ji);
//    uint32_t num_to_add = 109306;
    uint32_t max_ibytes = static_cast<uint32_t>(sizeof(ResultRow) * num_slots);
    std::unique_ptr<char[]> idata(new char[max_ibytes]);
    isoln = new InterleavedSoln(idata.get(), max_ibytes);
    banding = new Banding();
    banding->SetOrdinalSeed(0);
    banding->Reset(num_slots);
    hasher = new Hasher();
    addDurationMs = 0.0;
    queryDurationMs = 0.0;
    backSubstMs = 0.0;
    stringToCharsMs = 0.0;
    initMs = 0.0;


    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time);
    double duration_ms = static_cast<double>(duration.count()) / 1000.0;
    initMs += duration_ms;
}

/*
 * Class:     org_apache_hadoop_hbase_util_RibbonHelper
 * Method:    addKey
 * Signature: (Ljava/lang/String;)Z
 */
JNIEXPORT jboolean JNICALL Java_org_apache_hadoop_hbase_util_RibbonHelper_addKey
        (JNIEnv * env, jobject jo, jstring js) {
    auto start_time = std::chrono::high_resolution_clock::now();
    const char *cString = env->GetStringUTFChars(js , nullptr);
    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time);
    double duration_ms = static_cast<double>(duration.count()) / 1000.0;
    stringToCharsMs += duration_ms;

    start_time = std::chrono::high_resolution_clock::now();
    bool b = banding->Add(Slice(cString));
    end_time = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time);
    duration_ms = static_cast<double>(duration.count()) / 1000.0;
    addDurationMs += duration_ms;
    return b;
}

/*
 * Class:     org_apache_hadoop_hbase_util_RibbonHelper
 * Method:    backSubst
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_org_apache_hadoop_hbase_util_RibbonHelper_backSubst
        (JNIEnv *, jobject) {
    auto start_time = std::chrono::high_resolution_clock::now();
    isoln->BackSubstFrom(*banding);
    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time);
    double duration_ms = static_cast<double>(duration.count()) / 1000.0;
    backSubstMs += duration_ms;
}

/*
 * Class:     org_apache_hadoop_hbase_util_RibbonHelper
 * Method:    filterQuery
 * Signature: (Ljava/lang/String;)Z
 */
JNIEXPORT jboolean JNICALL Java_org_apache_hadoop_hbase_util_RibbonHelper_filterQuery
        (JNIEnv * env, jobject jo, jstring js) {
    auto start_time = std::chrono::high_resolution_clock::now();
    const char *cString = env->GetStringUTFChars(js , nullptr);
    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time);
    double duration_ms = static_cast<double>(duration.count()) / 1000.0;
    stringToCharsMs += duration_ms;


    start_time = std::chrono::high_resolution_clock::now();
    bool b = isoln->FilterQuery(Slice(cString), *hasher);
    end_time = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time);
    duration_ms = static_cast<double>(duration.count()) / 1000.0;
    queryDurationMs += duration_ms;
    return b;
}

/*
 * Class:     org_apache_hadoop_hbase_util_RibbonHelper
 * Method:    printDuration
 * Signature: ()Z
 */
JNIEXPORT void JNICALL Java_org_apache_hadoop_hbase_util_RibbonHelper_printDuration
        (JNIEnv *, jobject) {
    printf("ribbon native add Key time = %.2f ms\n",addDurationMs);
    printf("ribbon native backSubst time = %.2f ms\n",backSubstMs);
    printf("ribbon native query time = %.2f ms\n",queryDurationMs);
}

/*
 * Class:     org_apache_hadoop_hbase_util_RibbonHelper
 * Method:    getAddDuration
 * Signature: ()D
 */
JNIEXPORT jdouble JNICALL Java_org_apache_hadoop_hbase_util_RibbonHelper_getAddDuration
        (JNIEnv *, jobject) {
    return static_cast<jdouble>(addDurationMs);
}

/*
 * Class:     org_apache_hadoop_hbase_util_RibbonHelper
 * Method:    getBackSubstDuration
 * Signature: ()D
 */
JNIEXPORT jdouble JNICALL Java_org_apache_hadoop_hbase_util_RibbonHelper_getBackSubstDuration
        (JNIEnv *, jobject) {
    return static_cast<jdouble>(backSubstMs);
}

/*
 * Class:     org_apache_hadoop_hbase_util_RibbonHelper
 * Method:    getQueryDuration
 * Signature: ()D
 */
JNIEXPORT jdouble JNICALL Java_org_apache_hadoop_hbase_util_RibbonHelper_getQueryDuration
        (JNIEnv *, jobject) {
    return static_cast<jdouble>(queryDurationMs);
}

/*
 * Class:     org_apache_hadoop_hbase_util_RibbonHelper
 * Method:    getStringToCharsDuration
 * Signature: ()D
 */
JNIEXPORT jdouble JNICALL Java_org_apache_hadoop_hbase_util_RibbonHelper_getStringToCharsDuration
        (JNIEnv *, jobject) {
    return static_cast<jdouble>(stringToCharsMs);
}

/*
 * Class:     org_apache_hadoop_hbase_util_RibbonHelper
 * Method:    getInitDuration
 * Signature: ()D
 */
JNIEXPORT jdouble JNICALL Java_org_apache_hadoop_hbase_util_RibbonHelper_getInitDuration
        (JNIEnv *, jobject) {
    return static_cast<jdouble>(initMs);
}

/*
 * Class:     org_apache_hadoop_hbase_util_RibbonHelper
 * Method:    close
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_org_apache_hadoop_hbase_util_RibbonHelper_close
        (JNIEnv *, jobject) {
    delete banding;
    delete isoln;
    delete hasher;
}
```

编译生成动态库，命令行没生成出来，可以用CmakeList生成

```shell
mkdir build
cd build
cmake ..
make
```





### JNI自动生成的头文件解析

直接看个例子，Java代码如下：

```java
public class JNIAdvancedDemo {
    static {
        System.load。。。。
    }
    private static native void nativeAdd(NameReceiver nr, String name);

    public static void main(String[] args) {
        NameReceiver nr = new NameReceiver();
        nr.addName("XiaoLi");
        nr.addName("XiaoWang");
        nr.addName("AHo");
        nativeAdd(nr, "LiYou");
        System.out.println(nr.query(3));
    }
}

class NameReceiver {
    int count;
    int maxCnt;
    String[] names;
    byte[][] matrix;
		。。。
}
```

生成的头文件如下：

```c++
/*
 * Class:     org_example_JNIAdvancedDemo
 * Method:    nativeAdd
 * Signature: (Lorg/example/NameReceiver;Ljava/lang/String;)V
 */
JNIEXPORT void JNICALL Java_org_example_JNIAdvancedDemo_nativeAdd
  (JNIEnv *, jclass, jobject, jstring);
```

主要讲下这几个参数是干啥的，可以看到java的入参有两个，而c语言的入参有四个，这是因为JNIEnv和jclass参数是固定的，后面的jobject和jstring分别对应java的入参`NameReceiver nr`和`String name`。

头文件中第二个入参是jclass，这是因为我们Java中的native方法是一个静态的，静态方法属于类本身，所以这里是个jclass，代表类。

假如我们Java中的native方法不是一个静态的方法，那么这里的jclass就会变成jobject，因为非静态方法属于对象，所以是一个jobject，代表类对象。

头文件的第三个入参是一个jobject，对应我们传入的类对象`NameReceiver nr`



### JNI方法解析

1、GetMethodID

`GetMethodID` 是 JNI 中用于获取方法标识符（Method ID）的函数。这个函数通常用于在本地代码中调用 Java 类的方法。

```C++
jmethodID GetMethodID(jclass clazz, const char* name, const char* sig);
```

- `clazz`: 表示 Java 类的引用（`jclass`）。
- `name`: 方法的名称。
- `sig`: 方法的签名。



### JNI方法签名

这个东西其实之前就见过，但是不知道是啥

1. **基本数据类型：**
   - `Z`: boolean
   - `B`: byte
   - `C`: char
   - `S`: short
   - `I`: int
   - `J`: long
   - `F`: float
   - `D`: double
   - `V`: void
2. **对象类型：**
   - 对象类型的签名以 "L" 开头，以 ";" 结尾，中间是类的全限定名，例如：`Ljava/lang/String;` 表示 `java.lang.String` 类型。
3. **数组类型：**
   - 数组类型的签名以 "[" 开头，后面是元素的类型签名。例如，`[I` 表示整数数组。
4. **方法签名：**
   - 方法签名的格式是括号内包含参数类型的字符串，后跟返回类型的字符串。例如，无参数且返回类型为 `void` 的方法签名是 `()V`。

下面是一些示例：

- `int` 类型：`I`
- `float` 类型：`F`
- `double` 类型：`D`
- `String` 类型：`Ljava/lang/String;`
- `int[]` 类型：`[I`
- `void method(int, String)`: `(ILjava/lang/String;)V`
- `int[] method(String, boolean)`: `(Ljava/lang/String;Z)[I`

在使用 `GetMethodID` 或其他 JNI 函数时，需要根据方法的参数类型和返回类型构建正确的方法签名。在 JNI 开发中，方法签名是确保调用正确的 Java 方法的关键。



### [JNI联调](https://zhuanlan.zhihu.com/p/113480351)

文章介绍了几种调试方法

1、分析错误堆栈+atos/addr2line

查看错误位置：

```
Stack: [0x000000016b458000,0x000000016b65b000],  sp=0x000000016b65a870,  free space=2058k
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)
V  [libjvm.dylib+0x2d03d8]  jni_CallVoidMethodV+0x138
```

atos定位

```shell
atos -o `echo $JAVA_HOME/jre/lib/server/libjvm.dylib` 0x2d03d8
```

举个例子：

![image-20240110114606982](/assets/images/2024-01-08-JNI//image-20240110114606982.png)

由此定位到问题出在libjvm.dylib的jni_CallStaticFloatMethodA方法中，这是个啥方法呢？这是java官方提供的Jni调用库。官方库出错的概率是极小的，可以忽略不计，那么一定是我们的调用方式出了问题，回去反复检查调用代码，找到问题，修改之后，报错消失。

2、[ASAN](https://link.zhihu.com/?target=https%3A//github.com/google/sanitizers/wiki/AddressSanitizer)

3、调试器：lldb/gdb



### 排错指南

1、javah -jni 【类名】 找不到类文件

首先要确保类已经被编译成了class文件，其次[类名前面要加上包名](https://blog.csdn.net/qq_42572858/article/details/107796445)，最后终端路径要位于包名的上一层目录。

2、System.loadLibrary 找不到 native动态库文件（mac平台上实际为dylib类型，linux上为so类型，具体啥类型可以用file命令查看）

解决方案：使用System.load去加载。System.loadLibrary用于加载系统库，而System.load加载本地库。

```java
在Java中，System.load 和 System.loadLibrary 都是用于加载本地库（native libraries）的方法，但它们之间有一些关键的区别。

System.load:

System.load 方法用于加载指定路径的本地库文件。
你需要提供完整的本地库文件路径，包括文件名和文件扩展名。
示例：System.load("/path/to/mylibrary.so");
System.loadLibrary:

System.loadLibrary 方法用于加载系统库，这些库通常是通过本地语言（如C或C++）编写的，并在Java中使用。
你只需提供库的名称，而不是完整的文件路径，因为Java会根据平台和约定自动确定正确的库文件。
示例：System.loadLibrary("mylibrary");
总体而言，System.load 允许你直接指定本地库的路径，而 System.loadLibrary 则使用平台相关的规则来查找和加载库文件，因此更方便，但是你必须确保库文件位于系统库路径中或者通过java.library.path系统属性正确配置。
```

3、[idea运行报错](https://youtrack.jetbrains.com/issue/FL-15722)：java.lang.NullPointerException: Cannot read field "wordsInUse" because "set" is null

这是个idea的bug，我触发bug的原因是同时使用了idea和clion的cmake管理同一个项目。造成idea出bug无法正常运行任何代码。

解决方案就是别用clion来管理项目，把c++文件拷贝进来，命令行操作。

4、native方法运行报错：Process finished with exit code 134 (interrupted by signal 6: SIGABRT)

可以通过在native代码中打印信息、gdb等方式定位。相关内容见 `JNI联调`
